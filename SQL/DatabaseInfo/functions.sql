[
  {
    "function_name": "accept_slot_offer",
    "function_definition": "CREATE OR REPLACE FUNCTION public.accept_slot_offer(p_slot_offer_id uuid)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_offer record;\r\nBEGIN\r\n    -- Get offer details\r\n    SELECT * INTO v_offer\r\n    FROM slot_offers\r\n    WHERE id = p_slot_offer_id;\r\n\r\n    IF NOT FOUND THEN\r\n        RAISE EXCEPTION 'Slot offer not found';\r\n    END IF;\r\n\r\n    -- Update the player's registration to selected\r\n    UPDATE game_registrations\r\n    SET status = 'selected'\r\n    WHERE game_id = v_offer.game_id\r\n    AND player_id = v_offer.player_id;\r\n\r\n    -- Mark this offer as accepted\r\n    UPDATE slot_offers\r\n    SET status = 'accepted'\r\n    WHERE id = p_slot_offer_id;\r\n\r\n    -- Void all other pending offers for this game\r\n    UPDATE slot_offers\r\n    SET status = 'voided'\r\n    WHERE game_id = v_offer.game_id\r\n    AND id != p_slot_offer_id\r\n    AND status = 'pending';\r\n\r\n    -- Notify other players that their offers were voided\r\n    INSERT INTO notifications (\r\n        player_id,\r\n        type,\r\n        message,\r\n        metadata,\r\n        title,\r\n        priority\r\n    )\r\n    SELECT \r\n        so.player_id,\r\n        'slot_offer_update',\r\n        'The slot has been filled by another player.',\r\n        jsonb_build_object(\r\n            'game_id', so.game_id,\r\n            'slot_offer_id', so.id,\r\n            'status', 'voided'\r\n        ),\r\n        'Slot Offer Voided',\r\n        1\r\n    FROM slot_offers so\r\n    WHERE so.game_id = v_offer.game_id\r\n    AND so.id != p_slot_offer_id\r\n    AND so.status = 'voided';\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "void",
    "source_code": "\r\nDECLARE\r\n    v_offer record;\r\nBEGIN\r\n    -- Get offer details\r\n    SELECT * INTO v_offer\r\n    FROM slot_offers\r\n    WHERE id = p_slot_offer_id;\r\n\r\n    IF NOT FOUND THEN\r\n        RAISE EXCEPTION 'Slot offer not found';\r\n    END IF;\r\n\r\n    -- Update the player's registration to selected\r\n    UPDATE game_registrations\r\n    SET status = 'selected'\r\n    WHERE game_id = v_offer.game_id\r\n    AND player_id = v_offer.player_id;\r\n\r\n    -- Mark this offer as accepted\r\n    UPDATE slot_offers\r\n    SET status = 'accepted'\r\n    WHERE id = p_slot_offer_id;\r\n\r\n    -- Void all other pending offers for this game\r\n    UPDATE slot_offers\r\n    SET status = 'voided'\r\n    WHERE game_id = v_offer.game_id\r\n    AND id != p_slot_offer_id\r\n    AND status = 'pending';\r\n\r\n    -- Notify other players that their offers were voided\r\n    INSERT INTO notifications (\r\n        player_id,\r\n        type,\r\n        message,\r\n        metadata,\r\n        title,\r\n        priority\r\n    )\r\n    SELECT \r\n        so.player_id,\r\n        'slot_offer_update',\r\n        'The slot has been filled by another player.',\r\n        jsonb_build_object(\r\n            'game_id', so.game_id,\r\n            'slot_offer_id', so.id,\r\n            'status', 'voided'\r\n        ),\r\n        'Slot Offer Voided',\r\n        1\r\n    FROM slot_offers so\r\n    WHERE so.game_id = v_offer.game_id\r\n    AND so.id != p_slot_offer_id\r\n    AND so.status = 'voided';\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "add_admin_role",
    "function_definition": "CREATE OR REPLACE FUNCTION public.add_admin_role(p_player_id uuid, p_permissions text[])\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_role_id UUID;\r\nBEGIN\r\n    -- Insert or get admin role\r\n    INSERT INTO admin_roles (player_id)\r\n    VALUES (p_player_id)\r\n    ON CONFLICT (player_id) DO UPDATE\r\n    SET updated_at = NOW()\r\n    RETURNING id INTO v_role_id;\r\n\r\n    -- Add permissions\r\n    INSERT INTO admin_permissions (admin_role_id, permission)\r\n    SELECT v_role_id, unnest(p_permissions)\r\n    ON CONFLICT (admin_role_id, permission) DO NOTHING;\r\n\r\n    RETURN v_role_id;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "uuid",
    "source_code": "\r\nDECLARE\r\n    v_role_id UUID;\r\nBEGIN\r\n    -- Insert or get admin role\r\n    INSERT INTO admin_roles (player_id)\r\n    VALUES (p_player_id)\r\n    ON CONFLICT (player_id) DO UPDATE\r\n    SET updated_at = NOW()\r\n    RETURNING id INTO v_role_id;\r\n\r\n    -- Add permissions\r\n    INSERT INTO admin_permissions (admin_role_id, permission)\r\n    SELECT v_role_id, unnest(p_permissions)\r\n    ON CONFLICT (admin_role_id, permission) DO NOTHING;\r\n\r\n    RETURN v_role_id;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": true
  },
  {
    "function_name": "admin_recalculate_all_player_streaks",
    "function_definition": "CREATE OR REPLACE FUNCTION public.admin_recalculate_all_player_streaks()\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    player_rec RECORD;\r\nBEGIN\r\n    -- Check if user is admin or super admin\r\n    IF NOT EXISTS (\r\n        SELECT 1 \r\n        FROM players \r\n        WHERE user_id = auth.uid() \r\n        AND (is_admin = true OR is_super_admin = true)\r\n    ) THEN\r\n        RAISE EXCEPTION 'Unauthorized: User does not have admin permissions';\r\n    END IF;\r\n\r\n    -- Loop through each player and recalculate their streaks\r\n    FOR player_rec IN SELECT id FROM players\r\n    LOOP\r\n        UPDATE players\r\n        SET \r\n            current_streak = calculate_player_streak(player_rec.id),\r\n            bench_warmer_streak = calculate_bench_warmer_streak(player_rec.id)\r\n        WHERE id = player_rec.id;\r\n    END LOOP;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "void",
    "source_code": "\r\nDECLARE\r\n    player_rec RECORD;\r\nBEGIN\r\n    -- Check if user is admin or super admin\r\n    IF NOT EXISTS (\r\n        SELECT 1 \r\n        FROM players \r\n        WHERE user_id = auth.uid() \r\n        AND (is_admin = true OR is_super_admin = true)\r\n    ) THEN\r\n        RAISE EXCEPTION 'Unauthorized: User does not have admin permissions';\r\n    END IF;\r\n\r\n    -- Loop through each player and recalculate their streaks\r\n    FOR player_rec IN SELECT id FROM players\r\n    LOOP\r\n        UPDATE players\r\n        SET \r\n            current_streak = calculate_player_streak(player_rec.id),\r\n            bench_warmer_streak = calculate_bench_warmer_streak(player_rec.id)\r\n        WHERE id = player_rec.id;\r\n    END LOOP;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": true
  },
  {
    "function_name": "admin_recalculate_all_player_xp",
    "function_definition": "CREATE OR REPLACE FUNCTION public.admin_recalculate_all_player_xp()\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    player_rec RECORD;\r\nBEGIN\r\n    -- Check if user is admin or super admin\r\n    IF NOT EXISTS (\r\n        SELECT 1 \r\n        FROM players \r\n        WHERE user_id = auth.uid() \r\n        AND (is_admin = true OR is_super_admin = true)\r\n    ) THEN\r\n        RAISE EXCEPTION 'Unauthorized: User does not have admin permissions';\r\n    END IF;\r\n\r\n    -- Loop through each player and recalculate their XP\r\n    FOR player_rec IN SELECT id FROM players\r\n    LOOP\r\n        -- Update player_xp table with the calculated XP\r\n        INSERT INTO player_xp (player_id, xp, last_calculated)\r\n        VALUES (\r\n            player_rec.id,\r\n            calculate_player_xp(player_rec.id),\r\n            CURRENT_TIMESTAMP\r\n        )\r\n        ON CONFLICT (player_id) \r\n        DO UPDATE SET \r\n            xp = EXCLUDED.xp,\r\n            last_calculated = EXCLUDED.last_calculated;\r\n    END LOOP;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "void",
    "source_code": "\r\nDECLARE\r\n    player_rec RECORD;\r\nBEGIN\r\n    -- Check if user is admin or super admin\r\n    IF NOT EXISTS (\r\n        SELECT 1 \r\n        FROM players \r\n        WHERE user_id = auth.uid() \r\n        AND (is_admin = true OR is_super_admin = true)\r\n    ) THEN\r\n        RAISE EXCEPTION 'Unauthorized: User does not have admin permissions';\r\n    END IF;\r\n\r\n    -- Loop through each player and recalculate their XP\r\n    FOR player_rec IN SELECT id FROM players\r\n    LOOP\r\n        -- Update player_xp table with the calculated XP\r\n        INSERT INTO player_xp (player_id, xp, last_calculated)\r\n        VALUES (\r\n            player_rec.id,\r\n            calculate_player_xp(player_rec.id),\r\n            CURRENT_TIMESTAMP\r\n        )\r\n        ON CONFLICT (player_id) \r\n        DO UPDATE SET \r\n            xp = EXCLUDED.xp,\r\n            last_calculated = EXCLUDED.last_calculated;\r\n    END LOOP;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "balance_teams",
    "function_definition": "CREATE OR REPLACE FUNCTION public.balance_teams(game_id uuid)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    total_players INTEGER;\r\n    team_size INTEGER;\r\n    player_record RECORD;\r\n    best_difference DECIMAL := 999999;\r\n    current_attempt INTEGER := 0;\r\n    max_attempts INTEGER := 1000;\r\n    best_team_assignments JSONB;\r\n    current_blue_team UUID[];\r\n    current_orange_team UUID[];\r\n    difference DECIMAL;\r\nBEGIN\r\n    -- Get the total number of selected players for this game\r\n    SELECT COUNT(*) INTO total_players\r\n    FROM game_selections\r\n    WHERE game_id = $1 AND status = 'selected';\r\n\r\n    -- Calculate team size (rounded down for even teams)\r\n    team_size := total_players / 2;\r\n\r\n    -- Create temporary table for player ratings\r\n    CREATE TEMP TABLE temp_player_ratings AS\r\n    SELECT \r\n        gs.player_id,\r\n        COALESCE(AVG(pr.attack_rating), 5) as avg_attack,\r\n        COALESCE(AVG(pr.defense_rating), 5) as avg_defense,\r\n        COALESCE(\r\n            (SELECT CAST(COUNT(CASE WHEN g.outcome = 'Blue Win' AND gs2.team = 'Blue' \r\n                                  OR g.outcome = 'Orange Win' AND gs2.team = 'Orange' \r\n                             THEN 1 END) AS DECIMAL) / \r\n                    NULLIF(COUNT(*), 0)\r\n             FROM game_selections gs2\r\n             JOIN games g ON g.id = gs2.game_id\r\n             WHERE gs2.player_id = gs.player_id\r\n               AND g.outcome IS NOT NULL\r\n            ), 0.5\r\n        ) as win_rate\r\n    FROM game_selections gs\r\n    LEFT JOIN player_ratings pr ON pr.rated_player_id = gs.player_id\r\n    WHERE gs.game_id = $1 AND gs.status = 'selected'\r\n    GROUP BY gs.player_id;\r\n\r\n    -- Try different combinations\r\n    WHILE current_attempt < max_attempts LOOP\r\n        -- Get random team assignments\r\n        WITH shuffled_players AS (\r\n            SELECT \r\n                player_id,\r\n                avg_attack,\r\n                avg_defense,\r\n                win_rate,\r\n                ROW_NUMBER() OVER (ORDER BY random()) as rn\r\n            FROM temp_player_ratings\r\n        )\r\n        SELECT \r\n            array_agg(CASE WHEN rn <= team_size THEN player_id END) FILTER (WHERE rn <= team_size),\r\n            array_agg(CASE WHEN rn > team_size THEN player_id END) FILTER (WHERE rn > team_size)\r\n        INTO current_blue_team, current_orange_team\r\n        FROM shuffled_players;\r\n\r\n        -- Calculate team stats\r\n        WITH team_stats AS (\r\n            SELECT \r\n                'Blue' as team,\r\n                AVG(avg_attack) as team_attack,\r\n                AVG(avg_defense) as team_defense,\r\n                AVG(win_rate) as team_win_rate\r\n            FROM temp_player_ratings\r\n            WHERE player_id = ANY(current_blue_team)\r\n            UNION ALL\r\n            SELECT \r\n                'Orange' as team,\r\n                AVG(avg_attack) as team_attack,\r\n                AVG(avg_defense) as team_defense,\r\n                AVG(win_rate) as team_win_rate\r\n            FROM temp_player_ratings\r\n            WHERE player_id = ANY(current_orange_team)\r\n        )\r\n        SELECT \r\n            ABS(MAX(CASE WHEN team = 'Blue' THEN team_attack END) - \r\n                MAX(CASE WHEN team = 'Orange' THEN team_attack END)) +\r\n            ABS(MAX(CASE WHEN team = 'Blue' THEN team_defense END) - \r\n                MAX(CASE WHEN team = 'Orange' THEN team_defense END)) +\r\n            ABS(MAX(CASE WHEN team = 'Blue' THEN team_win_rate END) - \r\n                MAX(CASE WHEN team = 'Orange' THEN team_win_rate END))\r\n        INTO difference\r\n        FROM team_stats;\r\n\r\n        -- Update best teams if current difference is lower\r\n        IF difference < best_difference THEN\r\n            best_difference := difference;\r\n            best_team_assignments := jsonb_build_object(\r\n                'blue', current_blue_team,\r\n                'orange', current_orange_team,\r\n                'difference', difference\r\n            );\r\n        END IF;\r\n\r\n        current_attempt := current_attempt + 1;\r\n    END LOOP;\r\n\r\n    -- Update game_selections with the best team assignments\r\n    UPDATE game_selections\r\n    SET team = 'Blue'\r\n    WHERE game_id = $1 \r\n    AND player_id = ANY((best_team_assignments->>'blue')::uuid[]);\r\n\r\n    UPDATE game_selections\r\n    SET team = 'Orange'\r\n    WHERE game_id = $1 \r\n    AND player_id = ANY((best_team_assignments->>'orange')::uuid[]);\r\n\r\n    -- Clean up\r\n    DROP TABLE temp_player_ratings;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "void",
    "source_code": "\r\nDECLARE\r\n    total_players INTEGER;\r\n    team_size INTEGER;\r\n    player_record RECORD;\r\n    best_difference DECIMAL := 999999;\r\n    current_attempt INTEGER := 0;\r\n    max_attempts INTEGER := 1000;\r\n    best_team_assignments JSONB;\r\n    current_blue_team UUID[];\r\n    current_orange_team UUID[];\r\n    difference DECIMAL;\r\nBEGIN\r\n    -- Get the total number of selected players for this game\r\n    SELECT COUNT(*) INTO total_players\r\n    FROM game_selections\r\n    WHERE game_id = $1 AND status = 'selected';\r\n\r\n    -- Calculate team size (rounded down for even teams)\r\n    team_size := total_players / 2;\r\n\r\n    -- Create temporary table for player ratings\r\n    CREATE TEMP TABLE temp_player_ratings AS\r\n    SELECT \r\n        gs.player_id,\r\n        COALESCE(AVG(pr.attack_rating), 5) as avg_attack,\r\n        COALESCE(AVG(pr.defense_rating), 5) as avg_defense,\r\n        COALESCE(\r\n            (SELECT CAST(COUNT(CASE WHEN g.outcome = 'Blue Win' AND gs2.team = 'Blue' \r\n                                  OR g.outcome = 'Orange Win' AND gs2.team = 'Orange' \r\n                             THEN 1 END) AS DECIMAL) / \r\n                    NULLIF(COUNT(*), 0)\r\n             FROM game_selections gs2\r\n             JOIN games g ON g.id = gs2.game_id\r\n             WHERE gs2.player_id = gs.player_id\r\n               AND g.outcome IS NOT NULL\r\n            ), 0.5\r\n        ) as win_rate\r\n    FROM game_selections gs\r\n    LEFT JOIN player_ratings pr ON pr.rated_player_id = gs.player_id\r\n    WHERE gs.game_id = $1 AND gs.status = 'selected'\r\n    GROUP BY gs.player_id;\r\n\r\n    -- Try different combinations\r\n    WHILE current_attempt < max_attempts LOOP\r\n        -- Get random team assignments\r\n        WITH shuffled_players AS (\r\n            SELECT \r\n                player_id,\r\n                avg_attack,\r\n                avg_defense,\r\n                win_rate,\r\n                ROW_NUMBER() OVER (ORDER BY random()) as rn\r\n            FROM temp_player_ratings\r\n        )\r\n        SELECT \r\n            array_agg(CASE WHEN rn <= team_size THEN player_id END) FILTER (WHERE rn <= team_size),\r\n            array_agg(CASE WHEN rn > team_size THEN player_id END) FILTER (WHERE rn > team_size)\r\n        INTO current_blue_team, current_orange_team\r\n        FROM shuffled_players;\r\n\r\n        -- Calculate team stats\r\n        WITH team_stats AS (\r\n            SELECT \r\n                'Blue' as team,\r\n                AVG(avg_attack) as team_attack,\r\n                AVG(avg_defense) as team_defense,\r\n                AVG(win_rate) as team_win_rate\r\n            FROM temp_player_ratings\r\n            WHERE player_id = ANY(current_blue_team)\r\n            UNION ALL\r\n            SELECT \r\n                'Orange' as team,\r\n                AVG(avg_attack) as team_attack,\r\n                AVG(avg_defense) as team_defense,\r\n                AVG(win_rate) as team_win_rate\r\n            FROM temp_player_ratings\r\n            WHERE player_id = ANY(current_orange_team)\r\n        )\r\n        SELECT \r\n            ABS(MAX(CASE WHEN team = 'Blue' THEN team_attack END) - \r\n                MAX(CASE WHEN team = 'Orange' THEN team_attack END)) +\r\n            ABS(MAX(CASE WHEN team = 'Blue' THEN team_defense END) - \r\n                MAX(CASE WHEN team = 'Orange' THEN team_defense END)) +\r\n            ABS(MAX(CASE WHEN team = 'Blue' THEN team_win_rate END) - \r\n                MAX(CASE WHEN team = 'Orange' THEN team_win_rate END))\r\n        INTO difference\r\n        FROM team_stats;\r\n\r\n        -- Update best teams if current difference is lower\r\n        IF difference < best_difference THEN\r\n            best_difference := difference;\r\n            best_team_assignments := jsonb_build_object(\r\n                'blue', current_blue_team,\r\n                'orange', current_orange_team,\r\n                'difference', difference\r\n            );\r\n        END IF;\r\n\r\n        current_attempt := current_attempt + 1;\r\n    END LOOP;\r\n\r\n    -- Update game_selections with the best team assignments\r\n    UPDATE game_selections\r\n    SET team = 'Blue'\r\n    WHERE game_id = $1 \r\n    AND player_id = ANY((best_team_assignments->>'blue')::uuid[]);\r\n\r\n    UPDATE game_selections\r\n    SET team = 'Orange'\r\n    WHERE game_id = $1 \r\n    AND player_id = ANY((best_team_assignments->>'orange')::uuid[]);\r\n\r\n    -- Clean up\r\n    DROP TABLE temp_player_ratings;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": true
  },
  {
    "function_name": "calculate_balanced_teams",
    "function_definition": "CREATE OR REPLACE FUNCTION public.calculate_balanced_teams(input_game_id uuid)\n RETURNS TABLE(team text, player_id uuid, friendly_name text, attack_rating numeric, defense_rating numeric, experience_factor numeric)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    total_players integer;\r\n    players_per_team integer;\r\nBEGIN\r\n    -- Get total number of confirmed players\r\n    SELECT COUNT(*) INTO total_players\r\n    FROM public.game_registrations gp\r\n    WHERE gp.game_id = input_game_id AND gp.status = 'confirmed';\r\n\r\n    -- Calculate players per team\r\n    players_per_team := total_players / 2;\r\n\r\n    RETURN QUERY\r\n    WITH player_stats AS (\r\n        SELECT \r\n            gp.player_id,\r\n            p.friendly_name,\r\n            COALESCE(ps.attack_rating, 0) as attack_rating,\r\n            COALESCE(ps.defense_rating, 0) as defense_rating,\r\n            -- Calculate experience factor based on caps and streaks\r\n            (COALESCE(ps.caps, 0) * 0.1 + COALESCE(ps.current_streak, 0) * 0.05) as experience_factor,\r\n            -- Calculate weighted total rating\r\n            (COALESCE(ps.attack_rating, 0) + COALESCE(ps.defense_rating, 0)) * \r\n            (1 + (COALESCE(ps.active_bonuses, 0) * 0.1) - (COALESCE(ps.active_penalties, 0) * 0.1)) as weighted_rating\r\n        FROM public.game_registrations gp\r\n        JOIN public.players p ON p.id = gp.player_id\r\n        LEFT JOIN public.player_stats ps ON ps.id = gp.player_id\r\n        WHERE gp.game_id = input_game_id AND gp.status = 'confirmed'\r\n    ),\r\n    ranked_players AS (\r\n        SELECT \r\n            *,\r\n            ROW_NUMBER() OVER (\r\n                ORDER BY weighted_rating DESC\r\n            ) as rank\r\n        FROM player_stats\r\n    ),\r\n    team_assignments AS (\r\n        SELECT \r\n            CASE \r\n                -- Zigzag pattern for more balanced distribution\r\n                WHEN rank % 4 IN (1, 4) THEN 'blue'\r\n                ELSE 'orange'\r\n            END as team,\r\n            player_id,\r\n            friendly_name,\r\n            attack_rating,\r\n            defense_rating,\r\n            experience_factor\r\n        FROM ranked_players\r\n    )\r\n    SELECT \r\n        ta.team,\r\n        ta.player_id,\r\n        ta.friendly_name,\r\n        ta.attack_rating,\r\n        ta.defense_rating,\r\n        ta.experience_factor\r\n    FROM team_assignments ta\r\n    ORDER BY ta.team, (ta.attack_rating + ta.defense_rating) DESC;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "record",
    "source_code": "\r\nDECLARE\r\n    total_players integer;\r\n    players_per_team integer;\r\nBEGIN\r\n    -- Get total number of confirmed players\r\n    SELECT COUNT(*) INTO total_players\r\n    FROM public.game_registrations gp\r\n    WHERE gp.game_id = input_game_id AND gp.status = 'confirmed';\r\n\r\n    -- Calculate players per team\r\n    players_per_team := total_players / 2;\r\n\r\n    RETURN QUERY\r\n    WITH player_stats AS (\r\n        SELECT \r\n            gp.player_id,\r\n            p.friendly_name,\r\n            COALESCE(ps.attack_rating, 0) as attack_rating,\r\n            COALESCE(ps.defense_rating, 0) as defense_rating,\r\n            -- Calculate experience factor based on caps and streaks\r\n            (COALESCE(ps.caps, 0) * 0.1 + COALESCE(ps.current_streak, 0) * 0.05) as experience_factor,\r\n            -- Calculate weighted total rating\r\n            (COALESCE(ps.attack_rating, 0) + COALESCE(ps.defense_rating, 0)) * \r\n            (1 + (COALESCE(ps.active_bonuses, 0) * 0.1) - (COALESCE(ps.active_penalties, 0) * 0.1)) as weighted_rating\r\n        FROM public.game_registrations gp\r\n        JOIN public.players p ON p.id = gp.player_id\r\n        LEFT JOIN public.player_stats ps ON ps.id = gp.player_id\r\n        WHERE gp.game_id = input_game_id AND gp.status = 'confirmed'\r\n    ),\r\n    ranked_players AS (\r\n        SELECT \r\n            *,\r\n            ROW_NUMBER() OVER (\r\n                ORDER BY weighted_rating DESC\r\n            ) as rank\r\n        FROM player_stats\r\n    ),\r\n    team_assignments AS (\r\n        SELECT \r\n            CASE \r\n                -- Zigzag pattern for more balanced distribution\r\n                WHEN rank % 4 IN (1, 4) THEN 'blue'\r\n                ELSE 'orange'\r\n            END as team,\r\n            player_id,\r\n            friendly_name,\r\n            attack_rating,\r\n            defense_rating,\r\n            experience_factor\r\n        FROM ranked_players\r\n    )\r\n    SELECT \r\n        ta.team,\r\n        ta.player_id,\r\n        ta.friendly_name,\r\n        ta.attack_rating,\r\n        ta.defense_rating,\r\n        ta.experience_factor\r\n    FROM team_assignments ta\r\n    ORDER BY ta.team, (ta.attack_rating + ta.defense_rating) DESC;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": true
  },
  {
    "function_name": "calculate_bench_warmer_streak",
    "function_definition": "CREATE OR REPLACE FUNCTION public.calculate_bench_warmer_streak(player_uuid uuid)\n RETURNS integer\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    RETURN (\r\n        SELECT \r\n            COUNT(*)\r\n        FROM players p\r\n        JOIN game_registrations gr ON gr.player_id = p.id\r\n        JOIN games g ON g.id = gr.game_id\r\n        WHERE p.id = player_uuid\r\n        AND gr.status = 'reserve'\r\n        AND g.completed = true\r\n        AND NOT EXISTS (\r\n            SELECT 1\r\n            FROM games g2\r\n            LEFT JOIN game_registrations gr2 ON gr2.game_id = g2.id AND gr2.player_id = p.id\r\n            WHERE g2.sequence_number > g.sequence_number\r\n            AND g2.completed = true\r\n            AND (gr2.id IS NULL OR gr2.status != 'reserve')\r\n        )\r\n    );\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "integer",
    "source_code": "\r\nBEGIN\r\n    RETURN (\r\n        SELECT \r\n            COUNT(*)\r\n        FROM players p\r\n        JOIN game_registrations gr ON gr.player_id = p.id\r\n        JOIN games g ON g.id = gr.game_id\r\n        WHERE p.id = player_uuid\r\n        AND gr.status = 'reserve'\r\n        AND g.completed = true\r\n        AND NOT EXISTS (\r\n            SELECT 1\r\n            FROM games g2\r\n            LEFT JOIN game_registrations gr2 ON gr2.game_id = g2.id AND gr2.player_id = p.id\r\n            WHERE g2.sequence_number > g.sequence_number\r\n            AND g2.completed = true\r\n            AND (gr2.id IS NULL OR gr2.status != 'reserve')\r\n        )\r\n    );\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "calculate_player_caps",
    "function_definition": "CREATE OR REPLACE FUNCTION public.calculate_player_caps(player_id uuid)\n RETURNS integer\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    caps_count INTEGER;\r\nBEGIN\r\n    SELECT COUNT(DISTINCT gr.game_id)\r\n    INTO caps_count\r\n    FROM game_registrations gr\r\n    JOIN games g ON gr.game_id = g.id\r\n    WHERE gr.player_id = calculate_player_caps.player_id\r\n    AND gr.team IS NOT NULL; -- Only count actual players, not reserves\r\n\r\n    RETURN caps_count;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "integer",
    "source_code": "\r\nDECLARE\r\n    caps_count INTEGER;\r\nBEGIN\r\n    SELECT COUNT(DISTINCT gr.game_id)\r\n    INTO caps_count\r\n    FROM game_registrations gr\r\n    JOIN games g ON gr.game_id = g.id\r\n    WHERE gr.player_id = calculate_player_caps.player_id\r\n    AND gr.team IS NOT NULL; -- Only count actual players, not reserves\r\n\r\n    RETURN caps_count;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "calculate_player_rarity",
    "function_definition": "CREATE OR REPLACE FUNCTION public.calculate_player_rarity()\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  WITH player_rankings AS (\r\n    SELECT \r\n      player_id,\r\n      xp,\r\n      CASE\r\n        WHEN percent_rank() OVER (ORDER BY xp DESC) <= 0.02 THEN 'Legendary'\r\n        WHEN percent_rank() OVER (ORDER BY xp DESC) <= 0.07 THEN 'World Class'\r\n        WHEN percent_rank() OVER (ORDER BY xp DESC) <= 0.20 THEN 'Professional'\r\n        WHEN percent_rank() OVER (ORDER BY xp DESC) <= 0.40 THEN 'Semi Pro'\r\n        ELSE 'Amateur'\r\n      END as calculated_rarity\r\n    FROM player_xp\r\n  )\r\n  UPDATE player_xp\r\n  SET rarity = pr.calculated_rarity\r\n  FROM player_rankings pr\r\n  WHERE player_xp.player_id = pr.player_id;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "void",
    "source_code": "\r\nBEGIN\r\n  WITH player_rankings AS (\r\n    SELECT \r\n      player_id,\r\n      xp,\r\n      CASE\r\n        WHEN percent_rank() OVER (ORDER BY xp DESC) <= 0.02 THEN 'Legendary'\r\n        WHEN percent_rank() OVER (ORDER BY xp DESC) <= 0.07 THEN 'World Class'\r\n        WHEN percent_rank() OVER (ORDER BY xp DESC) <= 0.20 THEN 'Professional'\r\n        WHEN percent_rank() OVER (ORDER BY xp DESC) <= 0.40 THEN 'Semi Pro'\r\n        ELSE 'Amateur'\r\n      END as calculated_rarity\r\n    FROM player_xp\r\n  )\r\n  UPDATE player_xp\r\n  SET rarity = pr.calculated_rarity\r\n  FROM player_rankings pr\r\n  WHERE player_xp.player_id = pr.player_id;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "calculate_player_streak",
    "function_definition": "CREATE OR REPLACE FUNCTION public.calculate_player_streak(player_uuid uuid)\n RETURNS integer\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    RETURN (\r\n        SELECT \r\n            COUNT(*)\r\n        FROM players p\r\n        JOIN game_registrations gr ON gr.player_id = p.id\r\n        JOIN games g ON g.id = gr.game_id\r\n        WHERE p.id = player_uuid\r\n        AND gr.status = 'selected'\r\n        AND g.completed = true\r\n        AND NOT EXISTS (\r\n            SELECT 1\r\n            FROM games g2\r\n            LEFT JOIN game_registrations gr2 ON gr2.game_id = g2.id AND gr2.player_id = p.id\r\n            WHERE g2.sequence_number > g.sequence_number\r\n            AND g2.completed = true\r\n            AND (gr2.id IS NULL OR gr2.status != 'selected')\r\n        )\r\n    );\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "integer",
    "source_code": "\r\nBEGIN\r\n    RETURN (\r\n        SELECT \r\n            COUNT(*)\r\n        FROM players p\r\n        JOIN game_registrations gr ON gr.player_id = p.id\r\n        JOIN games g ON g.id = gr.game_id\r\n        WHERE p.id = player_uuid\r\n        AND gr.status = 'selected'\r\n        AND g.completed = true\r\n        AND NOT EXISTS (\r\n            SELECT 1\r\n            FROM games g2\r\n            LEFT JOIN game_registrations gr2 ON gr2.game_id = g2.id AND gr2.player_id = p.id\r\n            WHERE g2.sequence_number > g.sequence_number\r\n            AND g2.completed = true\r\n            AND (gr2.id IS NULL OR gr2.status != 'selected')\r\n        )\r\n    );\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "calculate_player_streaks",
    "function_definition": "CREATE OR REPLACE FUNCTION public.calculate_player_streaks(player_id uuid)\n RETURNS TABLE(current_streak integer, max_streak integer)\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  RETURN QUERY\r\n  WITH consecutive_games AS (\r\n    SELECT \r\n      g.date::date,\r\n      g.is_historical,\r\n      gr.status,\r\n      g.sequence_number,\r\n      CASE \r\n        WHEN gr.status = 'selected' THEN 0\r\n        ELSE 1\r\n      END as streak_break,\r\n      SUM(CASE \r\n        WHEN gr.status = 'selected' THEN 0\r\n        ELSE 1\r\n      END) OVER (ORDER BY g.sequence_number) as streak_group\r\n    FROM games g\r\n    LEFT JOIN game_registrations gr \r\n      ON gr.game_id = g.id \r\n      AND gr.player_id = calculate_player_streaks.player_id\r\n    WHERE g.status = 'completed'\r\n    ORDER BY g.sequence_number DESC\r\n  ),\r\n  streak_lengths AS (\r\n    SELECT \r\n      streak_group,\r\n      (COUNT(*)::integer - SUM(streak_break)::integer)::integer as streak_length,\r\n      ROW_NUMBER() OVER (ORDER BY MIN(sequence_number) DESC) as group_order\r\n    FROM consecutive_games\r\n    GROUP BY streak_group\r\n    HAVING (COUNT(*)::integer - SUM(streak_break)::integer) > 0\r\n  )\r\n  SELECT \r\n    COALESCE((\r\n      SELECT streak_length::integer \r\n      FROM streak_lengths \r\n      WHERE group_order = 1\r\n    ), 0)::integer as current_streak,\r\n    COALESCE((\r\n      SELECT MAX(streak_length)::integer \r\n      FROM streak_lengths\r\n    ), 0)::integer as max_streak;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "record",
    "source_code": "\r\nBEGIN\r\n  RETURN QUERY\r\n  WITH consecutive_games AS (\r\n    SELECT \r\n      g.date::date,\r\n      g.is_historical,\r\n      gr.status,\r\n      g.sequence_number,\r\n      CASE \r\n        WHEN gr.status = 'selected' THEN 0\r\n        ELSE 1\r\n      END as streak_break,\r\n      SUM(CASE \r\n        WHEN gr.status = 'selected' THEN 0\r\n        ELSE 1\r\n      END) OVER (ORDER BY g.sequence_number) as streak_group\r\n    FROM games g\r\n    LEFT JOIN game_registrations gr \r\n      ON gr.game_id = g.id \r\n      AND gr.player_id = calculate_player_streaks.player_id\r\n    WHERE g.status = 'completed'\r\n    ORDER BY g.sequence_number DESC\r\n  ),\r\n  streak_lengths AS (\r\n    SELECT \r\n      streak_group,\r\n      (COUNT(*)::integer - SUM(streak_break)::integer)::integer as streak_length,\r\n      ROW_NUMBER() OVER (ORDER BY MIN(sequence_number) DESC) as group_order\r\n    FROM consecutive_games\r\n    GROUP BY streak_group\r\n    HAVING (COUNT(*)::integer - SUM(streak_break)::integer) > 0\r\n  )\r\n  SELECT \r\n    COALESCE((\r\n      SELECT streak_length::integer \r\n      FROM streak_lengths \r\n      WHERE group_order = 1\r\n    ), 0)::integer as current_streak,\r\n    COALESCE((\r\n      SELECT MAX(streak_length)::integer \r\n      FROM streak_lengths\r\n    ), 0)::integer as max_streak;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "calculate_player_xp",
    "function_definition": "CREATE OR REPLACE FUNCTION public.calculate_player_xp(p_player_id uuid)\n RETURNS integer\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_base_xp integer;\r\n    v_streak_modifier decimal;\r\n    v_bench_warmer_modifier decimal;\r\n    v_unpaid_games_modifier decimal;\r\n    v_total_modifier decimal;\r\n    v_reserve_xp integer;\r\n    v_final_xp integer;\r\n    v_latest_game_number integer;\r\n    v_twenty_four_hours_ago timestamp with time zone;\r\nBEGIN\r\n    -- Set timestamp for unpaid games check\r\n    v_twenty_four_hours_ago := NOW() - INTERVAL '24 hours';\r\n\r\n    -- Get the latest game number from ALL games\r\n    SELECT MAX(sequence_number) INTO v_latest_game_number FROM games WHERE completed = true;\r\n\r\n    -- Calculate base XP from game participation (only for selected players)\r\n    WITH player_games AS (\r\n        SELECT \r\n            g.id,\r\n            g.sequence_number,\r\n            gr.status,\r\n            (v_latest_game_number - g.sequence_number) as games_ago\r\n        FROM game_registrations gr\r\n        JOIN games g ON g.id = gr.game_id\r\n        WHERE gr.player_id = p_player_id\r\n        AND g.completed = true\r\n        AND g.is_historical = true\r\n        AND gr.status = 'selected'\r\n        ORDER BY g.sequence_number DESC\r\n    ),\r\n    game_weights AS (\r\n        SELECT \r\n            id,\r\n            sequence_number,\r\n            games_ago,\r\n            CASE\r\n                WHEN games_ago = 0 THEN 20\r\n                WHEN games_ago BETWEEN 1 AND 2 THEN 18\r\n                WHEN games_ago BETWEEN 3 AND 4 THEN 16\r\n                WHEN games_ago BETWEEN 5 AND 9 THEN 14\r\n                WHEN games_ago BETWEEN 10 AND 19 THEN 12\r\n                WHEN games_ago BETWEEN 20 AND 29 THEN 10\r\n                WHEN games_ago BETWEEN 30 AND 39 THEN 5\r\n                ELSE 0\r\n            END as weight\r\n        FROM player_games\r\n    )\r\n    SELECT COALESCE(SUM(weight), 0)\r\n    INTO v_base_xp \r\n    FROM game_weights;\r\n\r\n    -- Get reserve XP\r\n    SELECT COALESCE(SUM(xp_amount), 0)\r\n    INTO v_reserve_xp\r\n    FROM reserve_xp_transactions\r\n    WHERE player_id = p_player_id;\r\n\r\n    -- Add reserve XP to base XP before multipliers\r\n    v_base_xp := v_base_xp + v_reserve_xp;\r\n\r\n    -- Get streak modifier (+10% per streak level)\r\n    SELECT COALESCE(current_streak * 0.1, 0)\r\n    INTO v_streak_modifier\r\n    FROM players\r\n    WHERE id = p_player_id;\r\n\r\n    -- Get bench warmer modifier (+5% per bench warmer streak level)\r\n    SELECT COALESCE(bench_warmer_streak * 0.05, 0)\r\n    INTO v_bench_warmer_modifier\r\n    FROM players\r\n    WHERE id = p_player_id;\r\n\r\n    -- Calculate unpaid games modifier (-50% per unpaid game)\r\n    WITH unpaid_games AS (\r\n        SELECT COUNT(*) as unpaid_count\r\n        FROM game_registrations gr\r\n        JOIN games g ON g.id = gr.game_id\r\n        WHERE gr.player_id = p_player_id\r\n        AND gr.paid = false\r\n        AND g.date < v_twenty_four_hours_ago\r\n        AND g.completed = true\r\n        AND g.is_historical = true\r\n        AND gr.status != 'reserve'\r\n    )\r\n    SELECT COALESCE(unpaid_count * -0.5, 0)  -- Changed from -0.3 to -0.5\r\n    INTO v_unpaid_games_modifier\r\n    FROM unpaid_games;\r\n\r\n    -- Calculate total modifier by adding all modifiers\r\n    v_total_modifier := 1 + v_streak_modifier + v_bench_warmer_modifier + v_unpaid_games_modifier;\r\n\r\n    -- Calculate final XP and ensure it's never negative\r\n    v_final_xp := GREATEST(0, ROUND(v_base_xp * v_total_modifier));  -- Added GREATEST to ensure non-negative\r\n    \r\n    RETURN v_final_xp;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "integer",
    "source_code": "\r\nDECLARE\r\n    v_base_xp integer;\r\n    v_streak_modifier decimal;\r\n    v_bench_warmer_modifier decimal;\r\n    v_unpaid_games_modifier decimal;\r\n    v_total_modifier decimal;\r\n    v_reserve_xp integer;\r\n    v_final_xp integer;\r\n    v_latest_game_number integer;\r\n    v_twenty_four_hours_ago timestamp with time zone;\r\nBEGIN\r\n    -- Set timestamp for unpaid games check\r\n    v_twenty_four_hours_ago := NOW() - INTERVAL '24 hours';\r\n\r\n    -- Get the latest game number from ALL games\r\n    SELECT MAX(sequence_number) INTO v_latest_game_number FROM games WHERE completed = true;\r\n\r\n    -- Calculate base XP from game participation (only for selected players)\r\n    WITH player_games AS (\r\n        SELECT \r\n            g.id,\r\n            g.sequence_number,\r\n            gr.status,\r\n            (v_latest_game_number - g.sequence_number) as games_ago\r\n        FROM game_registrations gr\r\n        JOIN games g ON g.id = gr.game_id\r\n        WHERE gr.player_id = p_player_id\r\n        AND g.completed = true\r\n        AND g.is_historical = true\r\n        AND gr.status = 'selected'\r\n        ORDER BY g.sequence_number DESC\r\n    ),\r\n    game_weights AS (\r\n        SELECT \r\n            id,\r\n            sequence_number,\r\n            games_ago,\r\n            CASE\r\n                WHEN games_ago = 0 THEN 20\r\n                WHEN games_ago BETWEEN 1 AND 2 THEN 18\r\n                WHEN games_ago BETWEEN 3 AND 4 THEN 16\r\n                WHEN games_ago BETWEEN 5 AND 9 THEN 14\r\n                WHEN games_ago BETWEEN 10 AND 19 THEN 12\r\n                WHEN games_ago BETWEEN 20 AND 29 THEN 10\r\n                WHEN games_ago BETWEEN 30 AND 39 THEN 5\r\n                ELSE 0\r\n            END as weight\r\n        FROM player_games\r\n    )\r\n    SELECT COALESCE(SUM(weight), 0)\r\n    INTO v_base_xp \r\n    FROM game_weights;\r\n\r\n    -- Get reserve XP\r\n    SELECT COALESCE(SUM(xp_amount), 0)\r\n    INTO v_reserve_xp\r\n    FROM reserve_xp_transactions\r\n    WHERE player_id = p_player_id;\r\n\r\n    -- Add reserve XP to base XP before multipliers\r\n    v_base_xp := v_base_xp + v_reserve_xp;\r\n\r\n    -- Get streak modifier (+10% per streak level)\r\n    SELECT COALESCE(current_streak * 0.1, 0)\r\n    INTO v_streak_modifier\r\n    FROM players\r\n    WHERE id = p_player_id;\r\n\r\n    -- Get bench warmer modifier (+5% per bench warmer streak level)\r\n    SELECT COALESCE(bench_warmer_streak * 0.05, 0)\r\n    INTO v_bench_warmer_modifier\r\n    FROM players\r\n    WHERE id = p_player_id;\r\n\r\n    -- Calculate unpaid games modifier (-50% per unpaid game)\r\n    WITH unpaid_games AS (\r\n        SELECT COUNT(*) as unpaid_count\r\n        FROM game_registrations gr\r\n        JOIN games g ON g.id = gr.game_id\r\n        WHERE gr.player_id = p_player_id\r\n        AND gr.paid = false\r\n        AND g.date < v_twenty_four_hours_ago\r\n        AND g.completed = true\r\n        AND g.is_historical = true\r\n        AND gr.status != 'reserve'\r\n    )\r\n    SELECT COALESCE(unpaid_count * -0.5, 0)  -- Changed from -0.3 to -0.5\r\n    INTO v_unpaid_games_modifier\r\n    FROM unpaid_games;\r\n\r\n    -- Calculate total modifier by adding all modifiers\r\n    v_total_modifier := 1 + v_streak_modifier + v_bench_warmer_modifier + v_unpaid_games_modifier;\r\n\r\n    -- Calculate final XP and ensure it's never negative\r\n    v_final_xp := GREATEST(0, ROUND(v_base_xp * v_total_modifier));  -- Added GREATEST to ensure non-negative\r\n    \r\n    RETURN v_final_xp;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "calculate_slot_offer_times",
    "function_definition": "CREATE OR REPLACE FUNCTION public.calculate_slot_offer_times(p_game_id uuid, p_num_players bigint)\n RETURNS TABLE(player_rank bigint, available_time timestamp with time zone, next_player_access_time timestamp with time zone, debug_info jsonb)\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_game record;\r\n    v_total_time interval;\r\n    v_time_interval interval;\r\n    v_game_date timestamp with time zone;\r\nBEGIN\r\n    -- Get game details\r\n    SELECT * INTO v_game FROM games WHERE id = p_game_id;\r\n    IF NOT FOUND THEN\r\n        RAISE EXCEPTION 'Game not found';\r\n    END IF;\r\n\r\n    -- Calculate time intervals\r\n    v_game_date := date_trunc('day', v_game.date) + interval '1 minute';\r\n    v_total_time := v_game_date - CURRENT_TIMESTAMP;\r\n    \r\n    -- Handle case where there are no players\r\n    IF p_num_players = 0 THEN\r\n        RETURN;\r\n    END IF;\r\n    \r\n    v_time_interval := v_total_time / GREATEST(p_num_players, 1);\r\n\r\n    -- Return the results with debug info\r\n    RETURN QUERY\r\n    WITH RankedPlayers AS (\r\n        SELECT \r\n            p.id,\r\n            p.friendly_name,\r\n            p.whatsapp_group_member,\r\n            ps.xp,\r\n            p.current_streak,\r\n            p.caps,\r\n            gr.created_at as registration_time,\r\n            ROW_NUMBER() OVER (\r\n                ORDER BY \r\n                    CASE WHEN p.whatsapp_group_member IN ('Yes', 'Proxy') THEN 0 ELSE 1 END ASC,\r\n                    ps.xp DESC,\r\n                    p.current_streak DESC,\r\n                    p.caps DESC,\r\n                    gr.created_at ASC\r\n            ) as rank\r\n        FROM game_registrations gr\r\n        JOIN players p ON p.id = gr.player_id\r\n        JOIN player_stats ps ON ps.id = p.id\r\n        WHERE gr.game_id = p_game_id\r\n        AND gr.status = 'reserve'\r\n    )\r\n    SELECT \r\n        rank as player_rank,\r\n        CURRENT_TIMESTAMP + ((rank - 1) * v_time_interval) as available_time,\r\n        CURRENT_TIMESTAMP + (rank * v_time_interval) as next_player_access_time,\r\n        jsonb_build_object(\r\n            'player_name', friendly_name,\r\n            'whatsapp_status', whatsapp_group_member,\r\n            'xp', xp,\r\n            'streak', current_streak,\r\n            'caps', caps,\r\n            'registration_time', registration_time,\r\n            'rank', rank,\r\n            'whatsapp_priority', CASE WHEN whatsapp_group_member IN ('Yes', 'Proxy') THEN 0 ELSE 1 END\r\n        ) as debug_info\r\n    FROM RankedPlayers\r\n    ORDER BY rank;\r\n\r\n    -- Log debug info\r\n    RAISE NOTICE 'Game ID: %, Total Players: %, Time Interval: %', p_game_id, p_num_players, v_time_interval;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "record",
    "source_code": "\r\nDECLARE\r\n    v_game record;\r\n    v_total_time interval;\r\n    v_time_interval interval;\r\n    v_game_date timestamp with time zone;\r\nBEGIN\r\n    -- Get game details\r\n    SELECT * INTO v_game FROM games WHERE id = p_game_id;\r\n    IF NOT FOUND THEN\r\n        RAISE EXCEPTION 'Game not found';\r\n    END IF;\r\n\r\n    -- Calculate time intervals\r\n    v_game_date := date_trunc('day', v_game.date) + interval '1 minute';\r\n    v_total_time := v_game_date - CURRENT_TIMESTAMP;\r\n    \r\n    -- Handle case where there are no players\r\n    IF p_num_players = 0 THEN\r\n        RETURN;\r\n    END IF;\r\n    \r\n    v_time_interval := v_total_time / GREATEST(p_num_players, 1);\r\n\r\n    -- Return the results with debug info\r\n    RETURN QUERY\r\n    WITH RankedPlayers AS (\r\n        SELECT \r\n            p.id,\r\n            p.friendly_name,\r\n            p.whatsapp_group_member,\r\n            ps.xp,\r\n            p.current_streak,\r\n            p.caps,\r\n            gr.created_at as registration_time,\r\n            ROW_NUMBER() OVER (\r\n                ORDER BY \r\n                    CASE WHEN p.whatsapp_group_member IN ('Yes', 'Proxy') THEN 0 ELSE 1 END ASC,\r\n                    ps.xp DESC,\r\n                    p.current_streak DESC,\r\n                    p.caps DESC,\r\n                    gr.created_at ASC\r\n            ) as rank\r\n        FROM game_registrations gr\r\n        JOIN players p ON p.id = gr.player_id\r\n        JOIN player_stats ps ON ps.id = p.id\r\n        WHERE gr.game_id = p_game_id\r\n        AND gr.status = 'reserve'\r\n    )\r\n    SELECT \r\n        rank as player_rank,\r\n        CURRENT_TIMESTAMP + ((rank - 1) * v_time_interval) as available_time,\r\n        CURRENT_TIMESTAMP + (rank * v_time_interval) as next_player_access_time,\r\n        jsonb_build_object(\r\n            'player_name', friendly_name,\r\n            'whatsapp_status', whatsapp_group_member,\r\n            'xp', xp,\r\n            'streak', current_streak,\r\n            'caps', caps,\r\n            'registration_time', registration_time,\r\n            'rank', rank,\r\n            'whatsapp_priority', CASE WHEN whatsapp_group_member IN ('Yes', 'Proxy') THEN 0 ELSE 1 END\r\n        ) as debug_info\r\n    FROM RankedPlayers\r\n    ORDER BY rank;\r\n\r\n    -- Log debug info\r\n    RAISE NOTICE 'Game ID: %, Total Players: %, Time Interval: %', p_game_id, p_num_players, v_time_interval;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "check_game_completion_status",
    "function_definition": "CREATE OR REPLACE FUNCTION public.check_game_completion_status()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  -- Check if game is more than 1 hour past kickoff and still in teams_announced status\r\n  IF NEW.status = 'teams_announced' AND \r\n     NEW.date < (NOW() - INTERVAL '1 hour') THEN\r\n    NEW.status := 'pending_completion';\r\n  END IF;\r\n  RETURN NEW;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "trigger",
    "source_code": "\r\nBEGIN\r\n  -- Check if game is more than 1 hour past kickoff and still in teams_announced status\r\n  IF NEW.status = 'teams_announced' AND \r\n     NEW.date < (NOW() - INTERVAL '1 hour') THEN\r\n    NEW.status := 'pending_completion';\r\n  END IF;\r\n  RETURN NEW;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "check_game_registration_permissions",
    "function_definition": "CREATE OR REPLACE FUNCTION public.check_game_registration_permissions(p_game_id uuid, p_player_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_is_admin boolean;\r\n    v_is_owner boolean;\r\nBEGIN\r\n    -- Check if the current user is an admin\r\n    SELECT is_admin INTO v_is_admin\r\n    FROM players\r\n    WHERE id = auth.uid();\r\n\r\n    -- Check if the current user owns this registration\r\n    SELECT (auth.uid() = p_player_id) INTO v_is_owner;\r\n\r\n    -- Return true if user is admin or owns the registration\r\n    RETURN v_is_admin OR v_is_owner;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "boolean",
    "source_code": "\r\nDECLARE\r\n    v_is_admin boolean;\r\n    v_is_owner boolean;\r\nBEGIN\r\n    -- Check if the current user is an admin\r\n    SELECT is_admin INTO v_is_admin\r\n    FROM players\r\n    WHERE id = auth.uid();\r\n\r\n    -- Check if the current user owns this registration\r\n    SELECT (auth.uid() = p_player_id) INTO v_is_owner;\r\n\r\n    -- Return true if user is admin or owns the registration\r\n    RETURN v_is_admin OR v_is_owner;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": true
  },
  {
    "function_name": "check_games_played_together",
    "function_definition": "CREATE OR REPLACE FUNCTION public.check_games_played_together(player1_id uuid, player2_id uuid)\n RETURNS integer\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    games_count INTEGER;\r\nBEGIN\r\n    SELECT COUNT(*) INTO games_count\r\n    FROM game_selections gs1\r\n    JOIN game_selections gs2 ON gs1.game_id = gs2.game_id\r\n    WHERE gs1.player_id = player1_id \r\n    AND gs2.player_id = player2_id\r\n    AND gs1.game_id IN (\r\n        SELECT id FROM games WHERE completed = true\r\n    );\r\n    RETURN games_count;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "integer",
    "source_code": "\r\nDECLARE\r\n    games_count INTEGER;\r\nBEGIN\r\n    SELECT COUNT(*) INTO games_count\r\n    FROM game_selections gs1\r\n    JOIN game_selections gs2 ON gs1.game_id = gs2.game_id\r\n    WHERE gs1.player_id = player1_id \r\n    AND gs2.player_id = player2_id\r\n    AND gs1.game_id IN (\r\n        SELECT id FROM games WHERE completed = true\r\n    );\r\n    RETURN games_count;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "check_rating_eligibility",
    "function_definition": "CREATE OR REPLACE FUNCTION public.check_rating_eligibility()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    IF check_games_played_together(NEW.rater_id, NEW.rated_player_id) < 5 THEN\r\n        RAISE EXCEPTION 'Players must have played at least 5 games together before rating';\r\n    END IF;\r\n    RETURN NEW;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "trigger",
    "source_code": "\r\nBEGIN\r\n    IF check_games_played_together(NEW.rater_id, NEW.rated_player_id) < 5 THEN\r\n        RAISE EXCEPTION 'Players must have played at least 5 games together before rating';\r\n    END IF;\r\n    RETURN NEW;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "cleanup_expired_locks",
    "function_definition": "CREATE OR REPLACE FUNCTION public.cleanup_expired_locks()\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nbegin\r\n  delete from registration_locks\r\n  where locked_until < now();\r\nend;\r\n$function$\n",
    "function_description": null,
    "return_type": "void",
    "source_code": "\r\nbegin\r\n  delete from registration_locks\r\n  where locked_until < now();\r\nend;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "count_games_played_together",
    "function_definition": "CREATE OR REPLACE FUNCTION public.count_games_played_together(player_one_id uuid, player_two_id uuid)\n RETURNS integer\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  RETURN (\r\n    SELECT COUNT(DISTINCT gr1.game_id)\r\n    FROM game_registrations gr1\r\n    INNER JOIN game_registrations gr2 ON gr1.game_id = gr2.game_id\r\n    INNER JOIN games g ON gr1.game_id = g.id\r\n    WHERE gr1.player_id = player_one_id\r\n    AND gr2.player_id = player_two_id\r\n    AND g.completed = true\r\n  );\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "integer",
    "source_code": "\r\nBEGIN\r\n  RETURN (\r\n    SELECT COUNT(DISTINCT gr1.game_id)\r\n    FROM game_registrations gr1\r\n    INNER JOIN game_registrations gr2 ON gr1.game_id = gr2.game_id\r\n    INNER JOIN games g ON gr1.game_id = g.id\r\n    WHERE gr1.player_id = player_one_id\r\n    AND gr2.player_id = player_two_id\r\n    AND g.completed = true\r\n  );\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "create_game",
    "function_definition": "CREATE OR REPLACE FUNCTION public.create_game(p_date timestamp with time zone, p_reg_start timestamp with time zone, p_reg_end timestamp with time zone, p_max_players integer DEFAULT 18, p_random_slots integer DEFAULT 2)\n RETURNS uuid\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_game_id uuid;\r\nBEGIN\r\n    -- Validate dates\r\n    IF p_reg_start >= p_reg_end THEN\r\n        RAISE EXCEPTION 'Registration start must be before registration end';\r\n    END IF;\r\n    \r\n    IF p_reg_end > p_date THEN\r\n        RAISE EXCEPTION 'Registration must end before game starts';\r\n    END IF;\r\n\r\n    -- Insert the game with explicit enum casting\r\n    INSERT INTO games (\r\n        date,\r\n        registration_window_start,\r\n        registration_window_end,\r\n        status,\r\n        needs_completion,\r\n        is_historical,\r\n        teams_announced,\r\n        completed,\r\n        random_slots,\r\n        max_players,\r\n        score_blue,\r\n        score_orange,\r\n        outcome\r\n    ) VALUES (\r\n        p_date,\r\n        p_reg_start,\r\n        p_reg_end,\r\n        'created'::game_status,\r\n        true,\r\n        false,\r\n        false,\r\n        false,\r\n        p_random_slots,\r\n        p_max_players,\r\n        NULL,\r\n        NULL,\r\n        NULL\r\n    )\r\n    RETURNING id INTO v_game_id;\r\n\r\n    RETURN v_game_id;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "uuid",
    "source_code": "\r\nDECLARE\r\n    v_game_id uuid;\r\nBEGIN\r\n    -- Validate dates\r\n    IF p_reg_start >= p_reg_end THEN\r\n        RAISE EXCEPTION 'Registration start must be before registration end';\r\n    END IF;\r\n    \r\n    IF p_reg_end > p_date THEN\r\n        RAISE EXCEPTION 'Registration must end before game starts';\r\n    END IF;\r\n\r\n    -- Insert the game with explicit enum casting\r\n    INSERT INTO games (\r\n        date,\r\n        registration_window_start,\r\n        registration_window_end,\r\n        status,\r\n        needs_completion,\r\n        is_historical,\r\n        teams_announced,\r\n        completed,\r\n        random_slots,\r\n        max_players,\r\n        score_blue,\r\n        score_orange,\r\n        outcome\r\n    ) VALUES (\r\n        p_date,\r\n        p_reg_start,\r\n        p_reg_end,\r\n        'created'::game_status,\r\n        true,\r\n        false,\r\n        false,\r\n        false,\r\n        p_random_slots,\r\n        p_max_players,\r\n        NULL,\r\n        NULL,\r\n        NULL\r\n    )\r\n    RETURNING id INTO v_game_id;\r\n\r\n    RETURN v_game_id;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "create_game_with_status",
    "function_definition": "CREATE OR REPLACE FUNCTION public.create_game_with_status(p_date timestamp with time zone, p_reg_start timestamp with time zone, p_reg_end timestamp with time zone, p_max_players integer DEFAULT 18, p_random_slots integer DEFAULT 2)\n RETURNS uuid\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_game_id uuid;\r\n    v_status text := 'created';\r\nBEGIN\r\n    -- Validate dates\r\n    IF p_reg_start >= p_reg_end THEN\r\n        RAISE EXCEPTION 'Registration start must be before registration end';\r\n    END IF;\r\n    \r\n    IF p_reg_end > p_date THEN\r\n        RAISE EXCEPTION 'Registration must end before game starts';\r\n    END IF;\r\n\r\n    -- Validate status is in allowed values\r\n    IF NOT (v_status = ANY(ARRAY['created', 'registration_open', 'teams_announced', 'pending_completion', 'completed']::text[])) THEN\r\n        RAISE EXCEPTION 'Invalid status value: %', v_status;\r\n    END IF;\r\n\r\n    -- Insert the game with explicit casting of status\r\n    EXECUTE 'INSERT INTO games (\r\n        date,\r\n        registration_window_start,\r\n        registration_window_end,\r\n        status,\r\n        needs_completion,\r\n        is_historical,\r\n        teams_announced,\r\n        completed,\r\n        random_slots,\r\n        max_players,\r\n        score_blue,\r\n        score_orange,\r\n        outcome\r\n    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13) RETURNING id'\r\n    INTO v_game_id\r\n    USING \r\n        p_date,\r\n        p_reg_start,\r\n        p_reg_end,\r\n        v_status,\r\n        true,\r\n        false,\r\n        false,\r\n        false,\r\n        p_random_slots,\r\n        p_max_players,\r\n        NULL,\r\n        NULL,\r\n        NULL;\r\n\r\n    IF v_game_id IS NULL THEN\r\n        RAISE EXCEPTION 'Failed to create game';\r\n    END IF;\r\n\r\n    RETURN v_game_id;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "uuid",
    "source_code": "\r\nDECLARE\r\n    v_game_id uuid;\r\n    v_status text := 'created';\r\nBEGIN\r\n    -- Validate dates\r\n    IF p_reg_start >= p_reg_end THEN\r\n        RAISE EXCEPTION 'Registration start must be before registration end';\r\n    END IF;\r\n    \r\n    IF p_reg_end > p_date THEN\r\n        RAISE EXCEPTION 'Registration must end before game starts';\r\n    END IF;\r\n\r\n    -- Validate status is in allowed values\r\n    IF NOT (v_status = ANY(ARRAY['created', 'registration_open', 'teams_announced', 'pending_completion', 'completed']::text[])) THEN\r\n        RAISE EXCEPTION 'Invalid status value: %', v_status;\r\n    END IF;\r\n\r\n    -- Insert the game with explicit casting of status\r\n    EXECUTE 'INSERT INTO games (\r\n        date,\r\n        registration_window_start,\r\n        registration_window_end,\r\n        status,\r\n        needs_completion,\r\n        is_historical,\r\n        teams_announced,\r\n        completed,\r\n        random_slots,\r\n        max_players,\r\n        score_blue,\r\n        score_orange,\r\n        outcome\r\n    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13) RETURNING id'\r\n    INTO v_game_id\r\n    USING \r\n        p_date,\r\n        p_reg_start,\r\n        p_reg_end,\r\n        v_status,\r\n        true,\r\n        false,\r\n        false,\r\n        false,\r\n        p_random_slots,\r\n        p_max_players,\r\n        NULL,\r\n        NULL,\r\n        NULL;\r\n\r\n    IF v_game_id IS NULL THEN\r\n        RAISE EXCEPTION 'Failed to create game';\r\n    END IF;\r\n\r\n    RETURN v_game_id;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "create_initial_slot_offer",
    "function_definition": "CREATE OR REPLACE FUNCTION public.create_initial_slot_offer(p_game_id uuid, p_admin_id uuid, p_dropped_out_player_id uuid)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_game record;\r\n    v_eligible_players record;\r\n    v_slot_offer_id UUID;\r\n    v_player_count integer;\r\n    v_time_slots record;\r\n    v_current_rank integer := 1;\r\nBEGIN\r\n    -- Get game details\r\n    SELECT * INTO v_game FROM games WHERE id = p_game_id;\r\n    IF NOT FOUND THEN\r\n        RAISE EXCEPTION 'Game not found';\r\n    END IF;\r\n\r\n    -- Get count of eligible players\r\n    SELECT COUNT(*) INTO v_player_count\r\n    FROM players p\r\n    JOIN game_registrations gr ON gr.player_id = p.id\r\n    WHERE gr.game_id = p_game_id\r\n    AND gr.status = 'reserve';\r\n\r\n    -- Get highest XP reserve player\r\n    WITH RankedPlayers AS (\r\n        SELECT \r\n            p.id as player_id,\r\n            p.friendly_name,\r\n            ps.xp,\r\n            ROW_NUMBER() OVER (ORDER BY ps.xp DESC) as rank\r\n        FROM players p\r\n        JOIN game_registrations gr ON gr.player_id = p.id\r\n        JOIN player_stats ps ON ps.player_id = p.id\r\n        WHERE gr.game_id = p_game_id\r\n        AND gr.status = 'reserve'\r\n    )\r\n    SELECT * INTO v_eligible_players\r\n    FROM RankedPlayers\r\n    WHERE rank = 1;\r\n\r\n    -- Calculate time slots\r\n    SELECT * INTO v_time_slots\r\n    FROM calculate_slot_offer_times(p_game_id, v_player_count)\r\n    WHERE player_rank = 1;\r\n\r\n    -- Create slot offer for highest XP player\r\n    INSERT INTO slot_offers (\r\n        game_id,\r\n        player_id,\r\n        status,\r\n        rank,\r\n        available_at,\r\n        expires_at\r\n    ) VALUES (\r\n        p_game_id,\r\n        v_eligible_players.player_id,\r\n        'pending',\r\n        1,\r\n        v_time_slots.available_time,\r\n        v_time_slots.expire_time\r\n    ) RETURNING id INTO v_slot_offer_id;\r\n\r\n    -- Create notification for the eligible player\r\n    INSERT INTO notifications (\r\n        player_id,\r\n        type,\r\n        message,\r\n        metadata,\r\n        title,\r\n        priority\r\n    ) VALUES (\r\n        v_eligible_players.player_id,\r\n        'slot_offer',\r\n        format('A spot has opened up in a game on %s. You have exclusive access until %s!',\r\n               to_char(v_game.date, 'DD/MM/YYYY'),\r\n               to_char(v_time_slots.expire_time, 'HH24:MI')),\r\n        jsonb_build_object(\r\n            'game_id', p_game_id,\r\n            'slot_offer_id', v_slot_offer_id,\r\n            'exclusive_until', v_time_slots.expire_time\r\n        ),\r\n        'Exclusive Game Slot Available!',\r\n        2\r\n    );\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "void",
    "source_code": "\r\nDECLARE\r\n    v_game record;\r\n    v_eligible_players record;\r\n    v_slot_offer_id UUID;\r\n    v_player_count integer;\r\n    v_time_slots record;\r\n    v_current_rank integer := 1;\r\nBEGIN\r\n    -- Get game details\r\n    SELECT * INTO v_game FROM games WHERE id = p_game_id;\r\n    IF NOT FOUND THEN\r\n        RAISE EXCEPTION 'Game not found';\r\n    END IF;\r\n\r\n    -- Get count of eligible players\r\n    SELECT COUNT(*) INTO v_player_count\r\n    FROM players p\r\n    JOIN game_registrations gr ON gr.player_id = p.id\r\n    WHERE gr.game_id = p_game_id\r\n    AND gr.status = 'reserve';\r\n\r\n    -- Get highest XP reserve player\r\n    WITH RankedPlayers AS (\r\n        SELECT \r\n            p.id as player_id,\r\n            p.friendly_name,\r\n            ps.xp,\r\n            ROW_NUMBER() OVER (ORDER BY ps.xp DESC) as rank\r\n        FROM players p\r\n        JOIN game_registrations gr ON gr.player_id = p.id\r\n        JOIN player_stats ps ON ps.player_id = p.id\r\n        WHERE gr.game_id = p_game_id\r\n        AND gr.status = 'reserve'\r\n    )\r\n    SELECT * INTO v_eligible_players\r\n    FROM RankedPlayers\r\n    WHERE rank = 1;\r\n\r\n    -- Calculate time slots\r\n    SELECT * INTO v_time_slots\r\n    FROM calculate_slot_offer_times(p_game_id, v_player_count)\r\n    WHERE player_rank = 1;\r\n\r\n    -- Create slot offer for highest XP player\r\n    INSERT INTO slot_offers (\r\n        game_id,\r\n        player_id,\r\n        status,\r\n        rank,\r\n        available_at,\r\n        expires_at\r\n    ) VALUES (\r\n        p_game_id,\r\n        v_eligible_players.player_id,\r\n        'pending',\r\n        1,\r\n        v_time_slots.available_time,\r\n        v_time_slots.expire_time\r\n    ) RETURNING id INTO v_slot_offer_id;\r\n\r\n    -- Create notification for the eligible player\r\n    INSERT INTO notifications (\r\n        player_id,\r\n        type,\r\n        message,\r\n        metadata,\r\n        title,\r\n        priority\r\n    ) VALUES (\r\n        v_eligible_players.player_id,\r\n        'slot_offer',\r\n        format('A spot has opened up in a game on %s. You have exclusive access until %s!',\r\n               to_char(v_game.date, 'DD/MM/YYYY'),\r\n               to_char(v_time_slots.expire_time, 'HH24:MI')),\r\n        jsonb_build_object(\r\n            'game_id', p_game_id,\r\n            'slot_offer_id', v_slot_offer_id,\r\n            'exclusive_until', v_time_slots.expire_time\r\n        ),\r\n        'Exclusive Game Slot Available!',\r\n        2\r\n    );\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "create_new_game",
    "function_definition": "CREATE OR REPLACE FUNCTION public.create_new_game(p_date timestamp with time zone, p_registration_window_start timestamp with time zone, p_registration_window_end timestamp with time zone, p_max_players integer DEFAULT 18, p_random_slots integer DEFAULT 2)\n RETURNS uuid\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_game_id uuid;\r\nBEGIN\r\n    -- Validate dates\r\n    IF p_registration_window_start >= p_registration_window_end THEN\r\n        RAISE EXCEPTION 'Registration start must be before registration end';\r\n    END IF;\r\n    \r\n    IF p_registration_window_end > p_date THEN\r\n        RAISE EXCEPTION 'Registration must end before game starts';\r\n    END IF;\r\n\r\n    -- Insert the game with initial status\r\n    INSERT INTO games (\r\n        date,\r\n        registration_window_start,\r\n        registration_window_end,\r\n        status,\r\n        needs_completion,\r\n        is_historical,\r\n        teams_announced,\r\n        completed,\r\n        random_slots,\r\n        max_players\r\n    ) VALUES (\r\n        p_date,\r\n        p_registration_window_start,\r\n        p_registration_window_end,\r\n        'created',\r\n        false,\r\n        false,\r\n        false,\r\n        false,\r\n        p_random_slots,\r\n        p_max_players\r\n    )\r\n    RETURNING id INTO v_game_id;\r\n\r\n    RETURN v_game_id;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "uuid",
    "source_code": "\r\nDECLARE\r\n    v_game_id uuid;\r\nBEGIN\r\n    -- Validate dates\r\n    IF p_registration_window_start >= p_registration_window_end THEN\r\n        RAISE EXCEPTION 'Registration start must be before registration end';\r\n    END IF;\r\n    \r\n    IF p_registration_window_end > p_date THEN\r\n        RAISE EXCEPTION 'Registration must end before game starts';\r\n    END IF;\r\n\r\n    -- Insert the game with initial status\r\n    INSERT INTO games (\r\n        date,\r\n        registration_window_start,\r\n        registration_window_end,\r\n        status,\r\n        needs_completion,\r\n        is_historical,\r\n        teams_announced,\r\n        completed,\r\n        random_slots,\r\n        max_players\r\n    ) VALUES (\r\n        p_date,\r\n        p_registration_window_start,\r\n        p_registration_window_end,\r\n        'created',\r\n        false,\r\n        false,\r\n        false,\r\n        false,\r\n        p_random_slots,\r\n        p_max_players\r\n    )\r\n    RETURNING id INTO v_game_id;\r\n\r\n    RETURN v_game_id;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "create_next_slot_offer",
    "function_definition": "CREATE OR REPLACE FUNCTION public.create_next_slot_offer(p_game_id uuid, p_previous_rank integer)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_game record;\r\n    v_next_player record;\r\n    v_slot_offer_id UUID;\r\n    v_player_count integer;\r\n    v_time_slots record;\r\nBEGIN\r\n    -- Get game details\r\n    SELECT * INTO v_game FROM games WHERE id = p_game_id;\r\n    IF NOT FOUND THEN\r\n        RAISE EXCEPTION 'Game not found';\r\n    END IF;\r\n\r\n    -- Get count of remaining eligible players\r\n    SELECT COUNT(*) INTO v_player_count\r\n    FROM players p\r\n    JOIN game_registrations gr ON gr.player_id = p.id\r\n    WHERE gr.game_id = p_game_id\r\n    AND gr.status = 'reserve'\r\n    AND NOT EXISTS (\r\n        SELECT 1 FROM slot_offers so\r\n        WHERE so.game_id = p_game_id\r\n        AND so.player_id = p.id\r\n        AND so.status = 'rejected'\r\n    );\r\n\r\n    -- Recalculate time slots with remaining players\r\n    SELECT * INTO v_time_slots\r\n    FROM calculate_slot_offer_times(p_game_id, v_player_count)\r\n    WHERE player_rank = 1;\r\n\r\n    -- Get next eligible player by XP\r\n    WITH RankedPlayers AS (\r\n        SELECT \r\n            p.id as player_id,\r\n            p.friendly_name,\r\n            ps.xp,\r\n            ROW_NUMBER() OVER (ORDER BY ps.xp DESC) as rank\r\n        FROM players p\r\n        JOIN game_registrations gr ON gr.player_id = p.id\r\n        JOIN player_stats ps ON ps.player_id = p.id\r\n        WHERE gr.game_id = p_game_id\r\n        AND gr.status = 'reserve'\r\n        AND NOT EXISTS (\r\n            SELECT 1 FROM slot_offers so\r\n            WHERE so.game_id = p_game_id\r\n            AND so.player_id = p.id\r\n            AND so.status = 'rejected'\r\n        )\r\n    )\r\n    SELECT * INTO v_next_player\r\n    FROM RankedPlayers\r\n    WHERE rank = 1;\r\n\r\n    -- Create slot offer for next player\r\n    INSERT INTO slot_offers (\r\n        game_id,\r\n        player_id,\r\n        status,\r\n        rank,\r\n        available_at,\r\n        expires_at\r\n    ) VALUES (\r\n        p_game_id,\r\n        v_next_player.player_id,\r\n        'pending',\r\n        p_previous_rank + 1,\r\n        v_time_slots.available_time,\r\n        v_time_slots.expire_time\r\n    ) RETURNING id INTO v_slot_offer_id;\r\n\r\n    -- Create notification for the next player\r\n    INSERT INTO notifications (\r\n        player_id,\r\n        type,\r\n        message,\r\n        metadata,\r\n        title,\r\n        priority\r\n    ) VALUES (\r\n        v_next_player.player_id,\r\n        'slot_offer',\r\n        format('A spot has opened up in a game on %s. You have exclusive access until %s!',\r\n               to_char(v_game.date, 'DD/MM/YYYY'),\r\n               to_char(v_time_slots.expire_time, 'HH24:MI')),\r\n        jsonb_build_object(\r\n            'game_id', p_game_id,\r\n            'slot_offer_id', v_slot_offer_id,\r\n            'exclusive_until', v_time_slots.expire_time\r\n        ),\r\n        'Exclusive Game Slot Available!',\r\n        2\r\n    );\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "void",
    "source_code": "\r\nDECLARE\r\n    v_game record;\r\n    v_next_player record;\r\n    v_slot_offer_id UUID;\r\n    v_player_count integer;\r\n    v_time_slots record;\r\nBEGIN\r\n    -- Get game details\r\n    SELECT * INTO v_game FROM games WHERE id = p_game_id;\r\n    IF NOT FOUND THEN\r\n        RAISE EXCEPTION 'Game not found';\r\n    END IF;\r\n\r\n    -- Get count of remaining eligible players\r\n    SELECT COUNT(*) INTO v_player_count\r\n    FROM players p\r\n    JOIN game_registrations gr ON gr.player_id = p.id\r\n    WHERE gr.game_id = p_game_id\r\n    AND gr.status = 'reserve'\r\n    AND NOT EXISTS (\r\n        SELECT 1 FROM slot_offers so\r\n        WHERE so.game_id = p_game_id\r\n        AND so.player_id = p.id\r\n        AND so.status = 'rejected'\r\n    );\r\n\r\n    -- Recalculate time slots with remaining players\r\n    SELECT * INTO v_time_slots\r\n    FROM calculate_slot_offer_times(p_game_id, v_player_count)\r\n    WHERE player_rank = 1;\r\n\r\n    -- Get next eligible player by XP\r\n    WITH RankedPlayers AS (\r\n        SELECT \r\n            p.id as player_id,\r\n            p.friendly_name,\r\n            ps.xp,\r\n            ROW_NUMBER() OVER (ORDER BY ps.xp DESC) as rank\r\n        FROM players p\r\n        JOIN game_registrations gr ON gr.player_id = p.id\r\n        JOIN player_stats ps ON ps.player_id = p.id\r\n        WHERE gr.game_id = p_game_id\r\n        AND gr.status = 'reserve'\r\n        AND NOT EXISTS (\r\n            SELECT 1 FROM slot_offers so\r\n            WHERE so.game_id = p_game_id\r\n            AND so.player_id = p.id\r\n            AND so.status = 'rejected'\r\n        )\r\n    )\r\n    SELECT * INTO v_next_player\r\n    FROM RankedPlayers\r\n    WHERE rank = 1;\r\n\r\n    -- Create slot offer for next player\r\n    INSERT INTO slot_offers (\r\n        game_id,\r\n        player_id,\r\n        status,\r\n        rank,\r\n        available_at,\r\n        expires_at\r\n    ) VALUES (\r\n        p_game_id,\r\n        v_next_player.player_id,\r\n        'pending',\r\n        p_previous_rank + 1,\r\n        v_time_slots.available_time,\r\n        v_time_slots.expire_time\r\n    ) RETURNING id INTO v_slot_offer_id;\r\n\r\n    -- Create notification for the next player\r\n    INSERT INTO notifications (\r\n        player_id,\r\n        type,\r\n        message,\r\n        metadata,\r\n        title,\r\n        priority\r\n    ) VALUES (\r\n        v_next_player.player_id,\r\n        'slot_offer',\r\n        format('A spot has opened up in a game on %s. You have exclusive access until %s!',\r\n               to_char(v_game.date, 'DD/MM/YYYY'),\r\n               to_char(v_time_slots.expire_time, 'HH24:MI')),\r\n        jsonb_build_object(\r\n            'game_id', p_game_id,\r\n            'slot_offer_id', v_slot_offer_id,\r\n            'exclusive_until', v_time_slots.expire_time\r\n        ),\r\n        'Exclusive Game Slot Available!',\r\n        2\r\n    );\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "create_slot_offers",
    "function_definition": "CREATE OR REPLACE FUNCTION public.create_slot_offers(p_game_id uuid)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n  v_total_players INTEGER;\r\n  v_available_slots INTEGER;\r\n  v_pending_offers INTEGER;\r\n  v_game_date TIMESTAMP WITH TIME ZONE;\r\n  v_total_hours NUMERIC;\r\n  v_hours_per_player NUMERIC;\r\n  v_players_to_offer INTEGER;\r\n  v_has_recent_decline BOOLEAN;\r\nBEGIN\r\n  -- Check if there was a recent decline\r\n  SELECT EXISTS (\r\n    SELECT 1 \r\n    FROM slot_offers \r\n    WHERE game_id = p_game_id \r\n    AND status = 'declined'\r\n    AND declined_at >= NOW() - INTERVAL '1 minute'\r\n  ) INTO v_has_recent_decline;\r\n\r\n  -- Get total number of reserve players (excluding declined players)\r\n  SELECT COUNT(*)\r\n  INTO v_total_players\r\n  FROM game_registrations gr\r\n  WHERE gr.game_id = p_game_id\r\n  AND gr.status = 'reserve'\r\n  AND NOT EXISTS (\r\n    SELECT 1 FROM slot_offers so\r\n    WHERE so.game_id = gr.game_id\r\n    AND so.player_id = gr.player_id\r\n    AND so.status = 'declined'\r\n  );\r\n\r\n  -- Get number of available slots\r\n  SELECT COUNT(*)\r\n  INTO v_available_slots\r\n  FROM game_registrations gr\r\n  WHERE gr.game_id = p_game_id\r\n  AND gr.status = 'dropped_out';\r\n\r\n  -- Get number of pending offers\r\n  SELECT COUNT(*)\r\n  INTO v_pending_offers\r\n  FROM slot_offers so\r\n  WHERE so.game_id = p_game_id\r\n  AND so.status = 'pending';\r\n\r\n  IF v_available_slots = 0 OR v_pending_offers >= v_available_slots THEN\r\n    RETURN;\r\n  END IF;\r\n\r\n  -- Get the game date (midnight of game day)\r\n  SELECT DATE_TRUNC('day', date) INTO v_game_date\r\n  FROM games \r\n  WHERE id = p_game_id;\r\n\r\n  -- Calculate total remaining hours and hours per player\r\n  v_total_hours := EXTRACT(EPOCH FROM (v_game_date - NOW())) / 3600;\r\n  v_hours_per_player := v_total_hours / GREATEST(v_total_players, 1);\r\n\r\n  -- If recent decline, offer to next player immediately\r\n  -- Otherwise calculate based on time elapsed\r\n  IF v_has_recent_decline THEN\r\n    v_players_to_offer := 1;\r\n  ELSE\r\n    v_players_to_offer := GREATEST(1, FLOOR(v_total_hours / v_hours_per_player));\r\n  END IF;\r\n\r\n  -- Create offers for eligible players\r\n  WITH ranked_players AS (\r\n    SELECT \r\n      gr.player_id,\r\n      ROW_NUMBER() OVER (ORDER BY ps.xp DESC, gr.created_at ASC) as rank\r\n    FROM game_registrations gr\r\n    JOIN player_stats ps ON ps.id = gr.player_id\r\n    LEFT JOIN slot_offers so ON \r\n      so.game_id = gr.game_id \r\n      AND so.player_id = gr.player_id\r\n      AND so.status = 'pending'\r\n    WHERE gr.game_id = p_game_id\r\n    AND gr.status = 'reserve'\r\n    AND NOT EXISTS (\r\n      SELECT 1 FROM slot_offers so2\r\n      WHERE so2.game_id = gr.game_id\r\n      AND so2.player_id = gr.player_id\r\n      AND so2.status = 'declined'\r\n    )\r\n    AND so.id IS NULL\r\n  )\r\n  INSERT INTO slot_offers (game_id, player_id, status, offered_at)\r\n  SELECT \r\n    p_game_id,\r\n    rp.player_id,\r\n    'pending',\r\n    NOW()\r\n  FROM ranked_players rp\r\n  WHERE rp.rank <= LEAST(\r\n    v_players_to_offer,\r\n    v_available_slots - v_pending_offers\r\n  )\r\n  AND NOT EXISTS (\r\n    SELECT 1 FROM slot_offers so2\r\n    WHERE so2.game_id = p_game_id\r\n    AND so2.player_id = rp.player_id\r\n    AND so2.status = 'pending'\r\n  );\r\n\r\n  -- Create notifications for new offers\r\n  INSERT INTO notifications (\r\n    player_id,\r\n    type,\r\n    message,\r\n    metadata\r\n  )\r\n  SELECT \r\n    so.player_id,\r\n    'slot_offer',\r\n    'A spot has opened up in the game. Would you like to play?',\r\n    jsonb_build_object(\r\n      'game_id', p_game_id,\r\n      'action', 'new_slot_offer'\r\n    )\r\n  FROM slot_offers so\r\n  WHERE so.game_id = p_game_id\r\n  AND so.status = 'pending'\r\n  AND so.offered_at >= NOW() - INTERVAL '1 minute';\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "void",
    "source_code": "\r\nDECLARE\r\n  v_total_players INTEGER;\r\n  v_available_slots INTEGER;\r\n  v_pending_offers INTEGER;\r\n  v_game_date TIMESTAMP WITH TIME ZONE;\r\n  v_total_hours NUMERIC;\r\n  v_hours_per_player NUMERIC;\r\n  v_players_to_offer INTEGER;\r\n  v_has_recent_decline BOOLEAN;\r\nBEGIN\r\n  -- Check if there was a recent decline\r\n  SELECT EXISTS (\r\n    SELECT 1 \r\n    FROM slot_offers \r\n    WHERE game_id = p_game_id \r\n    AND status = 'declined'\r\n    AND declined_at >= NOW() - INTERVAL '1 minute'\r\n  ) INTO v_has_recent_decline;\r\n\r\n  -- Get total number of reserve players (excluding declined players)\r\n  SELECT COUNT(*)\r\n  INTO v_total_players\r\n  FROM game_registrations gr\r\n  WHERE gr.game_id = p_game_id\r\n  AND gr.status = 'reserve'\r\n  AND NOT EXISTS (\r\n    SELECT 1 FROM slot_offers so\r\n    WHERE so.game_id = gr.game_id\r\n    AND so.player_id = gr.player_id\r\n    AND so.status = 'declined'\r\n  );\r\n\r\n  -- Get number of available slots\r\n  SELECT COUNT(*)\r\n  INTO v_available_slots\r\n  FROM game_registrations gr\r\n  WHERE gr.game_id = p_game_id\r\n  AND gr.status = 'dropped_out';\r\n\r\n  -- Get number of pending offers\r\n  SELECT COUNT(*)\r\n  INTO v_pending_offers\r\n  FROM slot_offers so\r\n  WHERE so.game_id = p_game_id\r\n  AND so.status = 'pending';\r\n\r\n  IF v_available_slots = 0 OR v_pending_offers >= v_available_slots THEN\r\n    RETURN;\r\n  END IF;\r\n\r\n  -- Get the game date (midnight of game day)\r\n  SELECT DATE_TRUNC('day', date) INTO v_game_date\r\n  FROM games \r\n  WHERE id = p_game_id;\r\n\r\n  -- Calculate total remaining hours and hours per player\r\n  v_total_hours := EXTRACT(EPOCH FROM (v_game_date - NOW())) / 3600;\r\n  v_hours_per_player := v_total_hours / GREATEST(v_total_players, 1);\r\n\r\n  -- If recent decline, offer to next player immediately\r\n  -- Otherwise calculate based on time elapsed\r\n  IF v_has_recent_decline THEN\r\n    v_players_to_offer := 1;\r\n  ELSE\r\n    v_players_to_offer := GREATEST(1, FLOOR(v_total_hours / v_hours_per_player));\r\n  END IF;\r\n\r\n  -- Create offers for eligible players\r\n  WITH ranked_players AS (\r\n    SELECT \r\n      gr.player_id,\r\n      ROW_NUMBER() OVER (ORDER BY ps.xp DESC, gr.created_at ASC) as rank\r\n    FROM game_registrations gr\r\n    JOIN player_stats ps ON ps.id = gr.player_id\r\n    LEFT JOIN slot_offers so ON \r\n      so.game_id = gr.game_id \r\n      AND so.player_id = gr.player_id\r\n      AND so.status = 'pending'\r\n    WHERE gr.game_id = p_game_id\r\n    AND gr.status = 'reserve'\r\n    AND NOT EXISTS (\r\n      SELECT 1 FROM slot_offers so2\r\n      WHERE so2.game_id = gr.game_id\r\n      AND so2.player_id = gr.player_id\r\n      AND so2.status = 'declined'\r\n    )\r\n    AND so.id IS NULL\r\n  )\r\n  INSERT INTO slot_offers (game_id, player_id, status, offered_at)\r\n  SELECT \r\n    p_game_id,\r\n    rp.player_id,\r\n    'pending',\r\n    NOW()\r\n  FROM ranked_players rp\r\n  WHERE rp.rank <= LEAST(\r\n    v_players_to_offer,\r\n    v_available_slots - v_pending_offers\r\n  )\r\n  AND NOT EXISTS (\r\n    SELECT 1 FROM slot_offers so2\r\n    WHERE so2.game_id = p_game_id\r\n    AND so2.player_id = rp.player_id\r\n    AND so2.status = 'pending'\r\n  );\r\n\r\n  -- Create notifications for new offers\r\n  INSERT INTO notifications (\r\n    player_id,\r\n    type,\r\n    message,\r\n    metadata\r\n  )\r\n  SELECT \r\n    so.player_id,\r\n    'slot_offer',\r\n    'A spot has opened up in the game. Would you like to play?',\r\n    jsonb_build_object(\r\n      'game_id', p_game_id,\r\n      'action', 'new_slot_offer'\r\n    )\r\n  FROM slot_offers so\r\n  WHERE so.game_id = p_game_id\r\n  AND so.status = 'pending'\r\n  AND so.offered_at >= NOW() - INTERVAL '1 minute';\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": true
  },
  {
    "function_name": "create_slot_offers_for_game",
    "function_definition": "CREATE OR REPLACE FUNCTION public.create_slot_offers_for_game(p_game_id uuid, p_admin_id uuid DEFAULT NULL::uuid, p_dropped_out_player_id uuid DEFAULT NULL::uuid)\n RETURNS TABLE(slot_offer_id uuid, debug_info jsonb)\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_game record;\r\n    v_highest_priority_player record;\r\n    v_time_slot record;\r\n    v_reserve_count bigint;\r\n    v_slot_offer_id uuid;\r\n    v_debug_info jsonb;\r\nBEGIN\r\n    -- Get game details\r\n    SELECT * INTO v_game FROM games WHERE id = p_game_id;\r\n    IF NOT FOUND THEN\r\n        RAISE EXCEPTION 'Game not found';\r\n    END IF;\r\n\r\n    -- Get the count of reserve players\r\n    SELECT COUNT(*) INTO v_reserve_count \r\n    FROM game_registrations \r\n    WHERE game_id = p_game_id \r\n    AND status = 'reserve';\r\n\r\n    -- Get the highest priority reserve player\r\n    WITH RankedPlayers AS (\r\n        SELECT \r\n            gr.player_id,\r\n            p.friendly_name,\r\n            p.whatsapp_group_member,\r\n            ps.xp,\r\n            p.current_streak,\r\n            p.caps,\r\n            gr.created_at as registration_time,\r\n            ROW_NUMBER() OVER (\r\n                ORDER BY \r\n                    CASE WHEN p.whatsapp_group_member IN ('Yes', 'Proxy') THEN 0 ELSE 1 END ASC,\r\n                    ps.xp DESC,\r\n                    p.current_streak DESC,\r\n                    p.caps DESC,\r\n                    gr.created_at ASC\r\n            ) as rank\r\n        FROM game_registrations gr\r\n        JOIN players p ON p.id = gr.player_id\r\n        JOIN player_stats ps ON ps.id = p.id\r\n        WHERE gr.game_id = p_game_id\r\n        AND gr.status = 'reserve'\r\n        AND NOT EXISTS (\r\n            -- Exclude players who already have any slot offer (pending or declined) for this game\r\n            SELECT 1 FROM slot_offers so\r\n            WHERE so.player_id = gr.player_id\r\n            AND so.game_id = p_game_id\r\n            AND (so.status = 'pending' OR so.status = 'declined')\r\n        )\r\n    )\r\n    SELECT * INTO v_highest_priority_player\r\n    FROM RankedPlayers\r\n    WHERE rank = 1;\r\n\r\n    -- If no eligible player found, return null\r\n    IF NOT FOUND THEN\r\n        RETURN;\r\n    END IF;\r\n\r\n    -- Get the time slot for the highest priority player with debug info\r\n    SELECT * INTO v_time_slot\r\n    FROM public.calculate_slot_offer_times(p_game_id, v_reserve_count)\r\n    WHERE player_rank = 1;\r\n\r\n    -- Store debug info\r\n    v_debug_info := jsonb_build_object(\r\n        'highest_priority_player', jsonb_build_object(\r\n            'name', v_highest_priority_player.friendly_name,\r\n            'whatsapp_status', v_highest_priority_player.whatsapp_group_member,\r\n            'xp', v_highest_priority_player.xp,\r\n            'rank', v_highest_priority_player.rank\r\n        ),\r\n        'time_slot', jsonb_build_object(\r\n            'available_at', v_time_slot.available_time,\r\n            'expires_at', v_time_slot.next_player_access_time\r\n        ),\r\n        'reserve_count', v_reserve_count,\r\n        'calculated_times_debug', v_time_slot.debug_info\r\n    );\r\n\r\n    -- Create slot offer\r\n    INSERT INTO slot_offers (\r\n        game_id,\r\n        player_id,\r\n        status,\r\n        available_at,\r\n        expires_at,\r\n        admin_id,\r\n        dropped_out_player_id,\r\n        priority\r\n    ) VALUES (\r\n        p_game_id,\r\n        v_highest_priority_player.player_id,\r\n        'pending',\r\n        v_time_slot.available_time,\r\n        v_time_slot.next_player_access_time,\r\n        p_admin_id,\r\n        p_dropped_out_player_id,\r\n        1\r\n    ) RETURNING id INTO v_slot_offer_id;\r\n\r\n    -- Create notification for the eligible player\r\n    INSERT INTO notifications (\r\n        player_id,\r\n        type,\r\n        message,\r\n        metadata,\r\n        title,\r\n        priority\r\n    ) VALUES (\r\n        v_highest_priority_player.player_id,\r\n        'slot_offer',\r\n        format('A spot has opened up in a game on %s. You have exclusive access until %s!',\r\n               to_char(v_game.date, 'DD/MM/YYYY'),\r\n               to_char(v_time_slot.next_player_access_time, 'HH24:MI')),\r\n        jsonb_build_object(\r\n            'game_id', p_game_id,\r\n            'slot_offer_id', v_slot_offer_id,\r\n            'exclusive_until', v_time_slot.next_player_access_time,\r\n            'debug_info', v_debug_info\r\n        ),\r\n        'Exclusive Game Slot Available!',\r\n        2\r\n    );\r\n\r\n    -- Return both the slot offer ID and debug info\r\n    RETURN QUERY\r\n    SELECT v_slot_offer_id, v_debug_info;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "record",
    "source_code": "\r\nDECLARE\r\n    v_game record;\r\n    v_highest_priority_player record;\r\n    v_time_slot record;\r\n    v_reserve_count bigint;\r\n    v_slot_offer_id uuid;\r\n    v_debug_info jsonb;\r\nBEGIN\r\n    -- Get game details\r\n    SELECT * INTO v_game FROM games WHERE id = p_game_id;\r\n    IF NOT FOUND THEN\r\n        RAISE EXCEPTION 'Game not found';\r\n    END IF;\r\n\r\n    -- Get the count of reserve players\r\n    SELECT COUNT(*) INTO v_reserve_count \r\n    FROM game_registrations \r\n    WHERE game_id = p_game_id \r\n    AND status = 'reserve';\r\n\r\n    -- Get the highest priority reserve player\r\n    WITH RankedPlayers AS (\r\n        SELECT \r\n            gr.player_id,\r\n            p.friendly_name,\r\n            p.whatsapp_group_member,\r\n            ps.xp,\r\n            p.current_streak,\r\n            p.caps,\r\n            gr.created_at as registration_time,\r\n            ROW_NUMBER() OVER (\r\n                ORDER BY \r\n                    CASE WHEN p.whatsapp_group_member IN ('Yes', 'Proxy') THEN 0 ELSE 1 END ASC,\r\n                    ps.xp DESC,\r\n                    p.current_streak DESC,\r\n                    p.caps DESC,\r\n                    gr.created_at ASC\r\n            ) as rank\r\n        FROM game_registrations gr\r\n        JOIN players p ON p.id = gr.player_id\r\n        JOIN player_stats ps ON ps.id = p.id\r\n        WHERE gr.game_id = p_game_id\r\n        AND gr.status = 'reserve'\r\n        AND NOT EXISTS (\r\n            -- Exclude players who already have any slot offer (pending or declined) for this game\r\n            SELECT 1 FROM slot_offers so\r\n            WHERE so.player_id = gr.player_id\r\n            AND so.game_id = p_game_id\r\n            AND (so.status = 'pending' OR so.status = 'declined')\r\n        )\r\n    )\r\n    SELECT * INTO v_highest_priority_player\r\n    FROM RankedPlayers\r\n    WHERE rank = 1;\r\n\r\n    -- If no eligible player found, return null\r\n    IF NOT FOUND THEN\r\n        RETURN;\r\n    END IF;\r\n\r\n    -- Get the time slot for the highest priority player with debug info\r\n    SELECT * INTO v_time_slot\r\n    FROM public.calculate_slot_offer_times(p_game_id, v_reserve_count)\r\n    WHERE player_rank = 1;\r\n\r\n    -- Store debug info\r\n    v_debug_info := jsonb_build_object(\r\n        'highest_priority_player', jsonb_build_object(\r\n            'name', v_highest_priority_player.friendly_name,\r\n            'whatsapp_status', v_highest_priority_player.whatsapp_group_member,\r\n            'xp', v_highest_priority_player.xp,\r\n            'rank', v_highest_priority_player.rank\r\n        ),\r\n        'time_slot', jsonb_build_object(\r\n            'available_at', v_time_slot.available_time,\r\n            'expires_at', v_time_slot.next_player_access_time\r\n        ),\r\n        'reserve_count', v_reserve_count,\r\n        'calculated_times_debug', v_time_slot.debug_info\r\n    );\r\n\r\n    -- Create slot offer\r\n    INSERT INTO slot_offers (\r\n        game_id,\r\n        player_id,\r\n        status,\r\n        available_at,\r\n        expires_at,\r\n        admin_id,\r\n        dropped_out_player_id,\r\n        priority\r\n    ) VALUES (\r\n        p_game_id,\r\n        v_highest_priority_player.player_id,\r\n        'pending',\r\n        v_time_slot.available_time,\r\n        v_time_slot.next_player_access_time,\r\n        p_admin_id,\r\n        p_dropped_out_player_id,\r\n        1\r\n    ) RETURNING id INTO v_slot_offer_id;\r\n\r\n    -- Create notification for the eligible player\r\n    INSERT INTO notifications (\r\n        player_id,\r\n        type,\r\n        message,\r\n        metadata,\r\n        title,\r\n        priority\r\n    ) VALUES (\r\n        v_highest_priority_player.player_id,\r\n        'slot_offer',\r\n        format('A spot has opened up in a game on %s. You have exclusive access until %s!',\r\n               to_char(v_game.date, 'DD/MM/YYYY'),\r\n               to_char(v_time_slot.next_player_access_time, 'HH24:MI')),\r\n        jsonb_build_object(\r\n            'game_id', p_game_id,\r\n            'slot_offer_id', v_slot_offer_id,\r\n            'exclusive_until', v_time_slot.next_player_access_time,\r\n            'debug_info', v_debug_info\r\n        ),\r\n        'Exclusive Game Slot Available!',\r\n        2\r\n    );\r\n\r\n    -- Return both the slot offer ID and debug info\r\n    RETURN QUERY\r\n    SELECT v_slot_offer_id, v_debug_info;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "debug_game_state",
    "function_definition": "CREATE OR REPLACE FUNCTION public.debug_game_state(p_game_id uuid)\n RETURNS TABLE(message text, details jsonb)\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_game record;\r\n    v_selected_count integer;\r\n    v_selected_players text;\r\n    v_debug_info jsonb;\r\nBEGIN\r\n    -- Get game details\r\n    SELECT \r\n        g.*,\r\n        COUNT(CASE WHEN gr.status = 'selected' THEN 1 END) as selected_count,\r\n        string_agg(\r\n            CASE WHEN gr.status = 'selected' THEN \r\n                format('%s (ID: %s)', p.friendly_name, p.id)\r\n            END, \r\n            ', '\r\n        ) as selected_players\r\n    INTO v_game\r\n    FROM games g\r\n    LEFT JOIN game_registrations gr ON gr.game_id = g.id\r\n    LEFT JOIN players p ON p.id = gr.player_id\r\n    WHERE g.id = p_game_id\r\n    GROUP BY g.id;\r\n\r\n    IF NOT FOUND THEN\r\n        RETURN QUERY SELECT 'Game not found'::text, jsonb_build_object('game_id', p_game_id);\r\n        RETURN;\r\n    END IF;\r\n\r\n    -- Return basic game info\r\n    message := 'Game Info';\r\n    details := jsonb_build_object(\r\n        'game_id', v_game.id,\r\n        'max_players', v_game.max_players,\r\n        'selected_count', v_game.selected_count,\r\n        'selected_players', v_game.selected_players\r\n    );\r\n    RETURN NEXT;\r\n\r\n    -- Check for any inconsistencies\r\n    WITH Inconsistencies AS (\r\n        SELECT \r\n            gr.player_id,\r\n            p.friendly_name,\r\n            gr.status as registration_status,\r\n            so.status as offer_status,\r\n            so.accepted_at,\r\n            so.declined_at\r\n        FROM game_registrations gr\r\n        JOIN players p ON p.id = gr.player_id\r\n        LEFT JOIN slot_offers so ON so.game_id = gr.game_id AND so.player_id = gr.player_id\r\n        WHERE gr.game_id = p_game_id\r\n        AND (\r\n            -- Selected but no accepted offer\r\n            (gr.status = 'selected' AND (so.status IS NULL OR so.status != 'accepted'))\r\n            OR\r\n            -- Accepted offer but not selected\r\n            (so.status = 'accepted' AND gr.status != 'selected')\r\n            OR\r\n            -- Accepted timestamp but not accepted status\r\n            (so.accepted_at IS NOT NULL AND so.status != 'accepted')\r\n            OR\r\n            -- Accepted status but no timestamp\r\n            (so.status = 'accepted' AND so.accepted_at IS NULL)\r\n        )\r\n    )\r\n    SELECT \r\n        'Inconsistencies Found',\r\n        jsonb_agg(\r\n            jsonb_build_object(\r\n                'player_id', player_id,\r\n                'player_name', friendly_name,\r\n                'registration_status', registration_status,\r\n                'offer_status', offer_status,\r\n                'accepted_at', accepted_at,\r\n                'declined_at', declined_at\r\n            )\r\n        )\r\n    INTO message, v_debug_info\r\n    FROM Inconsistencies;\r\n\r\n    IF v_debug_info IS NOT NULL THEN\r\n        details := v_debug_info;\r\n        RETURN NEXT;\r\n    END IF;\r\n\r\n    -- Check for pending offers\r\n    WITH PendingOffers AS (\r\n        SELECT \r\n            p.id as player_id,\r\n            p.friendly_name,\r\n            so.status as offer_status,\r\n            so.created_at,\r\n            so.expires_at,\r\n            gr.status as registration_status\r\n        FROM slot_offers so\r\n        JOIN players p ON p.id = so.player_id\r\n        JOIN game_registrations gr ON gr.game_id = so.game_id AND gr.player_id = so.player_id\r\n        WHERE so.game_id = p_game_id\r\n        AND so.status = 'pending'\r\n    )\r\n    SELECT \r\n        'Pending Offers',\r\n        jsonb_agg(\r\n            jsonb_build_object(\r\n                'player_id', player_id,\r\n                'player_name', friendly_name,\r\n                'offer_status', offer_status,\r\n                'created_at', created_at,\r\n                'expires_at', expires_at,\r\n                'registration_status', registration_status\r\n            )\r\n        )\r\n    INTO message, v_debug_info\r\n    FROM PendingOffers;\r\n\r\n    IF v_debug_info IS NOT NULL THEN\r\n        details := v_debug_info;\r\n        RETURN NEXT;\r\n    END IF;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "record",
    "source_code": "\r\nDECLARE\r\n    v_game record;\r\n    v_selected_count integer;\r\n    v_selected_players text;\r\n    v_debug_info jsonb;\r\nBEGIN\r\n    -- Get game details\r\n    SELECT \r\n        g.*,\r\n        COUNT(CASE WHEN gr.status = 'selected' THEN 1 END) as selected_count,\r\n        string_agg(\r\n            CASE WHEN gr.status = 'selected' THEN \r\n                format('%s (ID: %s)', p.friendly_name, p.id)\r\n            END, \r\n            ', '\r\n        ) as selected_players\r\n    INTO v_game\r\n    FROM games g\r\n    LEFT JOIN game_registrations gr ON gr.game_id = g.id\r\n    LEFT JOIN players p ON p.id = gr.player_id\r\n    WHERE g.id = p_game_id\r\n    GROUP BY g.id;\r\n\r\n    IF NOT FOUND THEN\r\n        RETURN QUERY SELECT 'Game not found'::text, jsonb_build_object('game_id', p_game_id);\r\n        RETURN;\r\n    END IF;\r\n\r\n    -- Return basic game info\r\n    message := 'Game Info';\r\n    details := jsonb_build_object(\r\n        'game_id', v_game.id,\r\n        'max_players', v_game.max_players,\r\n        'selected_count', v_game.selected_count,\r\n        'selected_players', v_game.selected_players\r\n    );\r\n    RETURN NEXT;\r\n\r\n    -- Check for any inconsistencies\r\n    WITH Inconsistencies AS (\r\n        SELECT \r\n            gr.player_id,\r\n            p.friendly_name,\r\n            gr.status as registration_status,\r\n            so.status as offer_status,\r\n            so.accepted_at,\r\n            so.declined_at\r\n        FROM game_registrations gr\r\n        JOIN players p ON p.id = gr.player_id\r\n        LEFT JOIN slot_offers so ON so.game_id = gr.game_id AND so.player_id = gr.player_id\r\n        WHERE gr.game_id = p_game_id\r\n        AND (\r\n            -- Selected but no accepted offer\r\n            (gr.status = 'selected' AND (so.status IS NULL OR so.status != 'accepted'))\r\n            OR\r\n            -- Accepted offer but not selected\r\n            (so.status = 'accepted' AND gr.status != 'selected')\r\n            OR\r\n            -- Accepted timestamp but not accepted status\r\n            (so.accepted_at IS NOT NULL AND so.status != 'accepted')\r\n            OR\r\n            -- Accepted status but no timestamp\r\n            (so.status = 'accepted' AND so.accepted_at IS NULL)\r\n        )\r\n    )\r\n    SELECT \r\n        'Inconsistencies Found',\r\n        jsonb_agg(\r\n            jsonb_build_object(\r\n                'player_id', player_id,\r\n                'player_name', friendly_name,\r\n                'registration_status', registration_status,\r\n                'offer_status', offer_status,\r\n                'accepted_at', accepted_at,\r\n                'declined_at', declined_at\r\n            )\r\n        )\r\n    INTO message, v_debug_info\r\n    FROM Inconsistencies;\r\n\r\n    IF v_debug_info IS NOT NULL THEN\r\n        details := v_debug_info;\r\n        RETURN NEXT;\r\n    END IF;\r\n\r\n    -- Check for pending offers\r\n    WITH PendingOffers AS (\r\n        SELECT \r\n            p.id as player_id,\r\n            p.friendly_name,\r\n            so.status as offer_status,\r\n            so.created_at,\r\n            so.expires_at,\r\n            gr.status as registration_status\r\n        FROM slot_offers so\r\n        JOIN players p ON p.id = so.player_id\r\n        JOIN game_registrations gr ON gr.game_id = so.game_id AND gr.player_id = so.player_id\r\n        WHERE so.game_id = p_game_id\r\n        AND so.status = 'pending'\r\n    )\r\n    SELECT \r\n        'Pending Offers',\r\n        jsonb_agg(\r\n            jsonb_build_object(\r\n                'player_id', player_id,\r\n                'player_name', friendly_name,\r\n                'offer_status', offer_status,\r\n                'created_at', created_at,\r\n                'expires_at', expires_at,\r\n                'registration_status', registration_status\r\n            )\r\n        )\r\n    INTO message, v_debug_info\r\n    FROM PendingOffers;\r\n\r\n    IF v_debug_info IS NOT NULL THEN\r\n        details := v_debug_info;\r\n        RETURN NEXT;\r\n    END IF;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "delete_game_cascade",
    "function_definition": "CREATE OR REPLACE FUNCTION public.delete_game_cascade(game_id uuid)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nbegin\r\n  -- Delete game selections first\r\n  delete from game_selections where game_id = $1;\r\n  \r\n  -- Delete game registrations\r\n  delete from game_registrations where game_id = $1;\r\n  \r\n  -- Finally delete the game\r\n  delete from games where id = $1;\r\nend;\r\n$function$\n",
    "function_description": null,
    "return_type": "void",
    "source_code": "\r\nbegin\r\n  -- Delete game selections first\r\n  delete from game_selections where game_id = $1;\r\n  \r\n  -- Delete game registrations\r\n  delete from game_registrations where game_id = $1;\r\n  \r\n  -- Finally delete the game\r\n  delete from games where id = $1;\r\nend;\r\n",
    "volatility": "v",
    "security_definer": true
  },
  {
    "function_name": "delete_payment_request_notification",
    "function_definition": "CREATE OR REPLACE FUNCTION public.delete_payment_request_notification()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n    -- Only proceed if payment_status is being updated to 'admin_verified'\r\n    IF (TG_OP = 'UPDATE' AND NEW.payment_status = 'admin_verified') THEN\r\n        -- Delete the payment_request notification for this game and player\r\n        DELETE FROM notifications \r\n        WHERE type = 'payment_request' \r\n        AND player_id = NEW.player_id \r\n        AND metadata::jsonb->>'game_id' = NEW.game_id::text;\r\n    END IF;\r\n    RETURN NEW;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "trigger",
    "source_code": "\r\nBEGIN\r\n    -- Only proceed if payment_status is being updated to 'admin_verified'\r\n    IF (TG_OP = 'UPDATE' AND NEW.payment_status = 'admin_verified') THEN\r\n        -- Delete the payment_request notification for this game and player\r\n        DELETE FROM notifications \r\n        WHERE type = 'payment_request' \r\n        AND player_id = NEW.player_id \r\n        AND metadata::jsonb->>'game_id' = NEW.game_id::text;\r\n    END IF;\r\n    RETURN NEW;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": true
  },
  {
    "function_name": "expire_slot_offers",
    "function_definition": "CREATE OR REPLACE FUNCTION public.expire_slot_offers()\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n    UPDATE slot_offers\r\n    SET status = 'expired',\r\n        updated_at = NOW()\r\n    WHERE status = 'pending'\r\n    AND expires_at < NOW();\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "void",
    "source_code": "\r\nBEGIN\r\n    UPDATE slot_offers\r\n    SET status = 'expired',\r\n        updated_at = NOW()\r\n    WHERE status = 'pending'\r\n    AND expires_at < NOW();\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": true
  },
  {
    "function_name": "get_balanced_teams",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_balanced_teams(game_id uuid)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    cached_results JSONB;\r\n    calculated_teams JSONB;\r\nBEGIN\r\n    -- Check cache first\r\n    SELECT team_assignments INTO cached_results\r\n    FROM public.balanced_team_assignments bta\r\n    WHERE bta.game_id = get_balanced_teams.game_id \r\n    AND bta.created_at > NOW() - INTERVAL '1 hour';\r\n\r\n    IF FOUND THEN\r\n        RETURN cached_results;\r\n    END IF;\r\n\r\n    -- Calculate teams if not in cache\r\n    WITH calculated_assignments AS (\r\n        SELECT \r\n            jsonb_agg(\r\n                jsonb_build_object(\r\n                    'team', t.team,\r\n                    'player_id', t.player_id,\r\n                    'friendly_name', t.friendly_name,\r\n                    'attack_rating', t.attack_rating,\r\n                    'defense_rating', t.defense_rating,\r\n                    'experience_factor', t.experience_factor\r\n                )\r\n                ORDER BY t.team, (t.attack_rating + t.defense_rating) DESC\r\n            ) as teams,\r\n            SUM(CASE WHEN t.team = 'blue' THEN t.attack_rating ELSE 0 END) as blue_attack,\r\n            SUM(CASE WHEN t.team = 'orange' THEN t.attack_rating ELSE 0 END) as orange_attack,\r\n            SUM(CASE WHEN t.team = 'blue' THEN t.defense_rating ELSE 0 END) as blue_defense,\r\n            SUM(CASE WHEN t.team = 'orange' THEN t.defense_rating ELSE 0 END) as orange_defense,\r\n            SUM(CASE WHEN t.team = 'blue' THEN t.experience_factor ELSE 0 END) as blue_experience,\r\n            SUM(CASE WHEN t.team = 'orange' THEN t.experience_factor ELSE 0 END) as orange_experience\r\n        FROM public.calculate_balanced_teams(get_balanced_teams.game_id) t\r\n    )\r\n    SELECT \r\n        jsonb_build_object(\r\n            'teams', teams,\r\n            'stats', jsonb_build_object(\r\n                'attack_differential', ABS(blue_attack - orange_attack),\r\n                'defense_differential', ABS(blue_defense - orange_defense),\r\n                'experience_differential', ABS(blue_experience - orange_experience),\r\n                'total_differential', ABS(blue_attack + blue_defense - orange_attack - orange_defense),\r\n                'blue_stats', jsonb_build_object(\r\n                    'attack', blue_attack,\r\n                    'defense', blue_defense,\r\n                    'experience', blue_experience\r\n                ),\r\n                'orange_stats', jsonb_build_object(\r\n                    'attack', orange_attack,\r\n                    'defense', orange_defense,\r\n                    'experience', orange_experience\r\n                )\r\n            )\r\n        ) INTO calculated_teams\r\n    FROM calculated_assignments;\r\n\r\n    -- Cache the results\r\n    INSERT INTO public.balanced_team_assignments (\r\n        game_id, \r\n        team_assignments,\r\n        attack_differential,\r\n        defense_differential,\r\n        total_differential,\r\n        experience_differential\r\n    )\r\n    SELECT \r\n        get_balanced_teams.game_id,\r\n        calculated_teams,\r\n        (calculated_teams->'stats'->>'attack_differential')::numeric,\r\n        (calculated_teams->'stats'->>'defense_differential')::numeric,\r\n        (calculated_teams->'stats'->>'total_differential')::numeric,\r\n        (calculated_teams->'stats'->>'experience_differential')::numeric;\r\n\r\n    RETURN calculated_teams;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "jsonb",
    "source_code": "\r\nDECLARE\r\n    cached_results JSONB;\r\n    calculated_teams JSONB;\r\nBEGIN\r\n    -- Check cache first\r\n    SELECT team_assignments INTO cached_results\r\n    FROM public.balanced_team_assignments bta\r\n    WHERE bta.game_id = get_balanced_teams.game_id \r\n    AND bta.created_at > NOW() - INTERVAL '1 hour';\r\n\r\n    IF FOUND THEN\r\n        RETURN cached_results;\r\n    END IF;\r\n\r\n    -- Calculate teams if not in cache\r\n    WITH calculated_assignments AS (\r\n        SELECT \r\n            jsonb_agg(\r\n                jsonb_build_object(\r\n                    'team', t.team,\r\n                    'player_id', t.player_id,\r\n                    'friendly_name', t.friendly_name,\r\n                    'attack_rating', t.attack_rating,\r\n                    'defense_rating', t.defense_rating,\r\n                    'experience_factor', t.experience_factor\r\n                )\r\n                ORDER BY t.team, (t.attack_rating + t.defense_rating) DESC\r\n            ) as teams,\r\n            SUM(CASE WHEN t.team = 'blue' THEN t.attack_rating ELSE 0 END) as blue_attack,\r\n            SUM(CASE WHEN t.team = 'orange' THEN t.attack_rating ELSE 0 END) as orange_attack,\r\n            SUM(CASE WHEN t.team = 'blue' THEN t.defense_rating ELSE 0 END) as blue_defense,\r\n            SUM(CASE WHEN t.team = 'orange' THEN t.defense_rating ELSE 0 END) as orange_defense,\r\n            SUM(CASE WHEN t.team = 'blue' THEN t.experience_factor ELSE 0 END) as blue_experience,\r\n            SUM(CASE WHEN t.team = 'orange' THEN t.experience_factor ELSE 0 END) as orange_experience\r\n        FROM public.calculate_balanced_teams(get_balanced_teams.game_id) t\r\n    )\r\n    SELECT \r\n        jsonb_build_object(\r\n            'teams', teams,\r\n            'stats', jsonb_build_object(\r\n                'attack_differential', ABS(blue_attack - orange_attack),\r\n                'defense_differential', ABS(blue_defense - orange_defense),\r\n                'experience_differential', ABS(blue_experience - orange_experience),\r\n                'total_differential', ABS(blue_attack + blue_defense - orange_attack - orange_defense),\r\n                'blue_stats', jsonb_build_object(\r\n                    'attack', blue_attack,\r\n                    'defense', blue_defense,\r\n                    'experience', blue_experience\r\n                ),\r\n                'orange_stats', jsonb_build_object(\r\n                    'attack', orange_attack,\r\n                    'defense', orange_defense,\r\n                    'experience', orange_experience\r\n                )\r\n            )\r\n        ) INTO calculated_teams\r\n    FROM calculated_assignments;\r\n\r\n    -- Cache the results\r\n    INSERT INTO public.balanced_team_assignments (\r\n        game_id, \r\n        team_assignments,\r\n        attack_differential,\r\n        defense_differential,\r\n        total_differential,\r\n        experience_differential\r\n    )\r\n    SELECT \r\n        get_balanced_teams.game_id,\r\n        calculated_teams,\r\n        (calculated_teams->'stats'->>'attack_differential')::numeric,\r\n        (calculated_teams->'stats'->>'defense_differential')::numeric,\r\n        (calculated_teams->'stats'->>'total_differential')::numeric,\r\n        (calculated_teams->'stats'->>'experience_differential')::numeric;\r\n\r\n    RETURN calculated_teams;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": true
  },
  {
    "function_name": "get_best_buddies",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_best_buddies(target_year integer DEFAULT NULL::integer)\n RETURNS TABLE(id uuid, friendly_name text, buddy_id uuid, buddy_friendly_name text, games_together bigint)\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    RETURN QUERY\r\n    WITH unique_games AS (\r\n        -- First get unique games for the target year\r\n        SELECT g.id as game_id, g.date  -- Be explicit about game_id\r\n        FROM games g\r\n        WHERE g.date <= NOW()\r\n        AND (target_year IS NULL OR EXTRACT(YEAR FROM g.date) = target_year)\r\n    ),\r\n    team_pairs AS (\r\n        -- Then get player pairs who were on the same team\r\n        SELECT \r\n            LEAST(gr1.player_id, gr2.player_id) as player1_id,\r\n            GREATEST(gr1.player_id, gr2.player_id) as player2_id,\r\n            COUNT(DISTINCT gr1.game_id) as games_count  -- Count distinct games to prevent duplicates\r\n        FROM game_registrations gr1\r\n        JOIN game_registrations gr2 \r\n            ON gr1.game_id = gr2.game_id \r\n            AND gr1.team = gr2.team\r\n            AND gr1.player_id < gr2.player_id  -- Only get each pair once\r\n        JOIN unique_games ug \r\n            ON gr1.game_id = ug.game_id  -- Use the aliased game_id\r\n        WHERE gr1.status = 'selected' \r\n        AND gr2.status = 'selected'\r\n        GROUP BY \r\n            LEAST(gr1.player_id, gr2.player_id),\r\n            GREATEST(gr1.player_id, gr2.player_id)\r\n    )\r\n    SELECT \r\n        p1.id,  -- These are now unambiguous since we're explicit about table aliases\r\n        p1.friendly_name,\r\n        p2.id as buddy_id,\r\n        p2.friendly_name as buddy_friendly_name,\r\n        tp.games_count as games_together\r\n    FROM team_pairs tp\r\n    JOIN players p1 ON p1.id = tp.player1_id\r\n    JOIN players p2 ON p2.id = tp.player2_id\r\n    ORDER BY tp.games_count DESC, p1.friendly_name, p2.friendly_name\r\n    LIMIT 3;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "record",
    "source_code": "\r\nBEGIN\r\n    RETURN QUERY\r\n    WITH unique_games AS (\r\n        -- First get unique games for the target year\r\n        SELECT g.id as game_id, g.date  -- Be explicit about game_id\r\n        FROM games g\r\n        WHERE g.date <= NOW()\r\n        AND (target_year IS NULL OR EXTRACT(YEAR FROM g.date) = target_year)\r\n    ),\r\n    team_pairs AS (\r\n        -- Then get player pairs who were on the same team\r\n        SELECT \r\n            LEAST(gr1.player_id, gr2.player_id) as player1_id,\r\n            GREATEST(gr1.player_id, gr2.player_id) as player2_id,\r\n            COUNT(DISTINCT gr1.game_id) as games_count  -- Count distinct games to prevent duplicates\r\n        FROM game_registrations gr1\r\n        JOIN game_registrations gr2 \r\n            ON gr1.game_id = gr2.game_id \r\n            AND gr1.team = gr2.team\r\n            AND gr1.player_id < gr2.player_id  -- Only get each pair once\r\n        JOIN unique_games ug \r\n            ON gr1.game_id = ug.game_id  -- Use the aliased game_id\r\n        WHERE gr1.status = 'selected' \r\n        AND gr2.status = 'selected'\r\n        GROUP BY \r\n            LEAST(gr1.player_id, gr2.player_id),\r\n            GREATEST(gr1.player_id, gr2.player_id)\r\n    )\r\n    SELECT \r\n        p1.id,  -- These are now unambiguous since we're explicit about table aliases\r\n        p1.friendly_name,\r\n        p2.id as buddy_id,\r\n        p2.friendly_name as buddy_friendly_name,\r\n        tp.games_count as games_together\r\n    FROM team_pairs tp\r\n    JOIN players p1 ON p1.id = tp.player1_id\r\n    JOIN players p2 ON p2.id = tp.player2_id\r\n    ORDER BY tp.games_count DESC, p1.friendly_name, p2.friendly_name\r\n    LIMIT 3;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "get_best_buddies",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_best_buddies()\n RETURNS TABLE(id uuid, friendly_name text, buddy_id uuid, buddy_friendly_name text, games_together bigint)\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    RETURN QUERY\r\n    WITH team_pairs AS (\r\n        SELECT \r\n            gr1.player_id as player1_id,\r\n            gr2.player_id as player2_id,\r\n            COUNT(*) as games_together\r\n        FROM game_registrations gr1\r\n        JOIN game_registrations gr2 \r\n            ON gr1.game_id = gr2.game_id \r\n            AND gr1.team = gr2.team\r\n            AND gr1.player_id < gr2.player_id\r\n        WHERE gr1.status = 'selected' \r\n        AND gr2.status = 'selected'\r\n        GROUP BY gr1.player_id, gr2.player_id\r\n    )\r\n    SELECT \r\n        p1.id,\r\n        p1.friendly_name,\r\n        p2.id as buddy_id,\r\n        p2.friendly_name as buddy_friendly_name,\r\n        tp.games_together\r\n    FROM team_pairs tp\r\n    JOIN players p1 ON p1.id = tp.player1_id\r\n    JOIN players p2 ON p2.id = tp.player2_id\r\n    ORDER BY tp.games_together DESC\r\n    LIMIT 3;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "record",
    "source_code": "\r\nBEGIN\r\n    RETURN QUERY\r\n    WITH team_pairs AS (\r\n        SELECT \r\n            gr1.player_id as player1_id,\r\n            gr2.player_id as player2_id,\r\n            COUNT(*) as games_together\r\n        FROM game_registrations gr1\r\n        JOIN game_registrations gr2 \r\n            ON gr1.game_id = gr2.game_id \r\n            AND gr1.team = gr2.team\r\n            AND gr1.player_id < gr2.player_id\r\n        WHERE gr1.status = 'selected' \r\n        AND gr2.status = 'selected'\r\n        GROUP BY gr1.player_id, gr2.player_id\r\n    )\r\n    SELECT \r\n        p1.id,\r\n        p1.friendly_name,\r\n        p2.id as buddy_id,\r\n        p2.friendly_name as buddy_friendly_name,\r\n        tp.games_together\r\n    FROM team_pairs tp\r\n    JOIN players p1 ON p1.id = tp.player1_id\r\n    JOIN players p2 ON p2.id = tp.player2_id\r\n    ORDER BY tp.games_together DESC\r\n    LIMIT 3;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "get_game_years",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_game_years()\n RETURNS TABLE(year integer)\n LANGUAGE plpgsql\nAS $function$\r\n#variable_conflict use_column\r\nBEGIN\r\n  RETURN QUERY\r\n  SELECT DISTINCT \r\n    date_part('year', date)::integer as year\r\n  FROM games\r\n  WHERE date <= CURRENT_TIMESTAMP\r\n  AND completed = true  -- Only include completed games\r\n  ORDER BY year DESC;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "integer",
    "source_code": "\r\n#variable_conflict use_column\r\nBEGIN\r\n  RETURN QUERY\r\n  SELECT DISTINCT \r\n    date_part('year', date)::integer as year\r\n  FROM games\r\n  WHERE date <= CURRENT_TIMESTAMP\r\n  AND completed = true  -- Only include completed games\r\n  ORDER BY year DESC;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "get_next_slot_offer_players",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_next_slot_offer_players(p_game_id uuid, p_hours_until_game numeric)\n RETURNS TABLE(player_id uuid)\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_selected_player uuid;\r\n    v_selected_name text;\r\n    v_selected_xp integer;\r\n    v_selected_whatsapp text;\r\nBEGIN\r\n    -- First get the next eligible player and store their details\r\n    WITH eligible_players AS (\r\n        SELECT \r\n            p.id as eligible_player_id,\r\n            p.friendly_name,\r\n            p.whatsapp_group_member,\r\n            gr.created_at,\r\n            ps.xp,\r\n            p.current_streak,\r\n            p.caps\r\n        FROM game_registrations gr\r\n        INNER JOIN players p ON p.id = gr.player_id\r\n        INNER JOIN player_stats ps ON ps.id = p.id\r\n        WHERE gr.game_id = p_game_id\r\n        AND gr.status = 'reserve'\r\n        AND NOT EXISTS (\r\n            SELECT 1 \r\n            FROM slot_offers so \r\n            WHERE so.game_id = p_game_id \r\n            AND so.player_id = p.id \r\n            AND so.status IN ('pending', 'declined')\r\n        )\r\n    )\r\n    SELECT \r\n        eligible_player_id,\r\n        friendly_name,\r\n        xp,\r\n        whatsapp_group_member\r\n    INTO \r\n        v_selected_player,\r\n        v_selected_name,\r\n        v_selected_xp,\r\n        v_selected_whatsapp\r\n    FROM eligible_players\r\n    ORDER BY \r\n        CASE WHEN whatsapp_group_member IN ('Yes', 'Proxy') THEN 0 ELSE 1 END ASC,\r\n        xp DESC,\r\n        current_streak DESC,\r\n        caps DESC,\r\n        created_at ASC\r\n    LIMIT 1;\r\n\r\n    -- Log the selection process\r\n    IF v_selected_player IS NOT NULL THEN\r\n        INSERT INTO debug_logs (event_type, message, details)\r\n        VALUES (\r\n            'player_selection',\r\n            'Selected next player based on WhatsApp status and XP',\r\n            jsonb_build_object(\r\n                'game_id', p_game_id,\r\n                'selected_player', v_selected_player,\r\n                'player_name', v_selected_name,\r\n                'xp', v_selected_xp,\r\n                'whatsapp_status', v_selected_whatsapp,\r\n                'selection_criteria', 'WhatsApp members first, then by XP'\r\n            )\r\n        );\r\n    ELSE\r\n        INSERT INTO debug_logs (event_type, message, details)\r\n        VALUES (\r\n            'player_selection',\r\n            'No eligible players found',\r\n            jsonb_build_object(\r\n                'game_id', p_game_id\r\n            )\r\n        );\r\n    END IF;\r\n\r\n    -- Return the selected player\r\n    RETURN QUERY\r\n    SELECT v_selected_player AS player_id\r\n    WHERE v_selected_player IS NOT NULL;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "uuid",
    "source_code": "\r\nDECLARE\r\n    v_selected_player uuid;\r\n    v_selected_name text;\r\n    v_selected_xp integer;\r\n    v_selected_whatsapp text;\r\nBEGIN\r\n    -- First get the next eligible player and store their details\r\n    WITH eligible_players AS (\r\n        SELECT \r\n            p.id as eligible_player_id,\r\n            p.friendly_name,\r\n            p.whatsapp_group_member,\r\n            gr.created_at,\r\n            ps.xp,\r\n            p.current_streak,\r\n            p.caps\r\n        FROM game_registrations gr\r\n        INNER JOIN players p ON p.id = gr.player_id\r\n        INNER JOIN player_stats ps ON ps.id = p.id\r\n        WHERE gr.game_id = p_game_id\r\n        AND gr.status = 'reserve'\r\n        AND NOT EXISTS (\r\n            SELECT 1 \r\n            FROM slot_offers so \r\n            WHERE so.game_id = p_game_id \r\n            AND so.player_id = p.id \r\n            AND so.status IN ('pending', 'declined')\r\n        )\r\n    )\r\n    SELECT \r\n        eligible_player_id,\r\n        friendly_name,\r\n        xp,\r\n        whatsapp_group_member\r\n    INTO \r\n        v_selected_player,\r\n        v_selected_name,\r\n        v_selected_xp,\r\n        v_selected_whatsapp\r\n    FROM eligible_players\r\n    ORDER BY \r\n        CASE WHEN whatsapp_group_member IN ('Yes', 'Proxy') THEN 0 ELSE 1 END ASC,\r\n        xp DESC,\r\n        current_streak DESC,\r\n        caps DESC,\r\n        created_at ASC\r\n    LIMIT 1;\r\n\r\n    -- Log the selection process\r\n    IF v_selected_player IS NOT NULL THEN\r\n        INSERT INTO debug_logs (event_type, message, details)\r\n        VALUES (\r\n            'player_selection',\r\n            'Selected next player based on WhatsApp status and XP',\r\n            jsonb_build_object(\r\n                'game_id', p_game_id,\r\n                'selected_player', v_selected_player,\r\n                'player_name', v_selected_name,\r\n                'xp', v_selected_xp,\r\n                'whatsapp_status', v_selected_whatsapp,\r\n                'selection_criteria', 'WhatsApp members first, then by XP'\r\n            )\r\n        );\r\n    ELSE\r\n        INSERT INTO debug_logs (event_type, message, details)\r\n        VALUES (\r\n            'player_selection',\r\n            'No eligible players found',\r\n            jsonb_build_object(\r\n                'game_id', p_game_id\r\n            )\r\n        );\r\n    END IF;\r\n\r\n    -- Return the selected player\r\n    RETURN QUERY\r\n    SELECT v_selected_player AS player_id\r\n    WHERE v_selected_player IS NOT NULL;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "get_player_attendance_streaks",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_player_attendance_streaks(target_year integer DEFAULT NULL::integer)\n RETURNS TABLE(id uuid, friendly_name text, current_streak integer, max_streak integer)\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  latest_game_number integer;\r\nBEGIN\r\n  -- Get the latest game sequence number\r\n  SELECT MAX(sequence_number) INTO latest_game_number\r\n  FROM games\r\n  WHERE completed = true;\r\n\r\n  RETURN QUERY\r\n  WITH player_games AS (\r\n    -- Get all games for each player with their status and sequence number\r\n    SELECT \r\n      p.id as player_id,\r\n      p.friendly_name as player_friendly_name,\r\n      g.date,\r\n      g.sequence_number,\r\n      gr.status,\r\n      CASE \r\n        WHEN target_year IS NOT NULL THEN \r\n          EXTRACT(YEAR FROM g.date) = target_year\r\n        ELSE TRUE\r\n      END as in_target_year,\r\n      -- Calculate the gap between consecutive games for each player\r\n      sequence_number - ROW_NUMBER() OVER (\r\n        PARTITION BY p.id, \r\n        CASE WHEN gr.status = 'selected' AND \r\n          (target_year IS NULL OR EXTRACT(YEAR FROM g.date) = target_year)\r\n        THEN 1 ELSE 0 END \r\n        ORDER BY g.sequence_number\r\n      ) as streak_group\r\n    FROM players p\r\n    LEFT JOIN game_registrations gr ON gr.player_id = p.id\r\n    LEFT JOIN games g ON g.id = gr.game_id\r\n    WHERE g.completed = true\r\n    ORDER BY g.sequence_number\r\n  ),\r\n  streak_lengths AS (\r\n    -- Calculate streak lengths by counting consecutive games in each streak group\r\n    SELECT \r\n      player_id,\r\n      player_friendly_name,\r\n      streak_group,\r\n      CAST(COUNT(*) AS integer) as streak_length,\r\n      MAX(date) as last_game_date,\r\n      MAX(sequence_number) as last_streak_game\r\n    FROM player_games\r\n    WHERE status = 'selected' AND in_target_year\r\n    GROUP BY player_id, player_friendly_name, streak_group\r\n    HAVING COUNT(*) > 0\r\n  ),\r\n  max_streaks AS (\r\n    -- Get the maximum streak for each player\r\n    SELECT \r\n      player_id,\r\n      player_friendly_name,\r\n      CAST(MAX(streak_length) AS integer) as max_streak\r\n    FROM streak_lengths\r\n    GROUP BY player_id, player_friendly_name\r\n  ),\r\n  current_streaks AS (\r\n    -- Get the current streak by finding the most recent streak\r\n    SELECT DISTINCT ON (player_id)\r\n      player_id,\r\n      player_friendly_name,\r\n      CAST(CASE \r\n        WHEN last_streak_game = latest_game_number THEN streak_length \r\n        ELSE 0 \r\n      END AS integer) as current_streak\r\n    FROM streak_lengths\r\n    ORDER BY player_id, last_streak_game DESC\r\n  )\r\n  -- Combine max and current streaks\r\n  SELECT \r\n    ms.player_id as id,\r\n    ms.player_friendly_name as friendly_name,\r\n    COALESCE(cs.current_streak, 0) as current_streak,\r\n    COALESCE(ms.max_streak, 0) as max_streak\r\n  FROM max_streaks ms\r\n  LEFT JOIN current_streaks cs ON cs.player_id = ms.player_id\r\n  WHERE COALESCE(ms.max_streak, 0) > 0 OR COALESCE(cs.current_streak, 0) > 0\r\n  ORDER BY COALESCE(cs.current_streak, 0) DESC, COALESCE(ms.max_streak, 0) DESC;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "record",
    "source_code": "\r\nDECLARE\r\n  latest_game_number integer;\r\nBEGIN\r\n  -- Get the latest game sequence number\r\n  SELECT MAX(sequence_number) INTO latest_game_number\r\n  FROM games\r\n  WHERE completed = true;\r\n\r\n  RETURN QUERY\r\n  WITH player_games AS (\r\n    -- Get all games for each player with their status and sequence number\r\n    SELECT \r\n      p.id as player_id,\r\n      p.friendly_name as player_friendly_name,\r\n      g.date,\r\n      g.sequence_number,\r\n      gr.status,\r\n      CASE \r\n        WHEN target_year IS NOT NULL THEN \r\n          EXTRACT(YEAR FROM g.date) = target_year\r\n        ELSE TRUE\r\n      END as in_target_year,\r\n      -- Calculate the gap between consecutive games for each player\r\n      sequence_number - ROW_NUMBER() OVER (\r\n        PARTITION BY p.id, \r\n        CASE WHEN gr.status = 'selected' AND \r\n          (target_year IS NULL OR EXTRACT(YEAR FROM g.date) = target_year)\r\n        THEN 1 ELSE 0 END \r\n        ORDER BY g.sequence_number\r\n      ) as streak_group\r\n    FROM players p\r\n    LEFT JOIN game_registrations gr ON gr.player_id = p.id\r\n    LEFT JOIN games g ON g.id = gr.game_id\r\n    WHERE g.completed = true\r\n    ORDER BY g.sequence_number\r\n  ),\r\n  streak_lengths AS (\r\n    -- Calculate streak lengths by counting consecutive games in each streak group\r\n    SELECT \r\n      player_id,\r\n      player_friendly_name,\r\n      streak_group,\r\n      CAST(COUNT(*) AS integer) as streak_length,\r\n      MAX(date) as last_game_date,\r\n      MAX(sequence_number) as last_streak_game\r\n    FROM player_games\r\n    WHERE status = 'selected' AND in_target_year\r\n    GROUP BY player_id, player_friendly_name, streak_group\r\n    HAVING COUNT(*) > 0\r\n  ),\r\n  max_streaks AS (\r\n    -- Get the maximum streak for each player\r\n    SELECT \r\n      player_id,\r\n      player_friendly_name,\r\n      CAST(MAX(streak_length) AS integer) as max_streak\r\n    FROM streak_lengths\r\n    GROUP BY player_id, player_friendly_name\r\n  ),\r\n  current_streaks AS (\r\n    -- Get the current streak by finding the most recent streak\r\n    SELECT DISTINCT ON (player_id)\r\n      player_id,\r\n      player_friendly_name,\r\n      CAST(CASE \r\n        WHEN last_streak_game = latest_game_number THEN streak_length \r\n        ELSE 0 \r\n      END AS integer) as current_streak\r\n    FROM streak_lengths\r\n    ORDER BY player_id, last_streak_game DESC\r\n  )\r\n  -- Combine max and current streaks\r\n  SELECT \r\n    ms.player_id as id,\r\n    ms.player_friendly_name as friendly_name,\r\n    COALESCE(cs.current_streak, 0) as current_streak,\r\n    COALESCE(ms.max_streak, 0) as max_streak\r\n  FROM max_streaks ms\r\n  LEFT JOIN current_streaks cs ON cs.player_id = ms.player_id\r\n  WHERE COALESCE(ms.max_streak, 0) > 0 OR COALESCE(cs.current_streak, 0) > 0\r\n  ORDER BY COALESCE(cs.current_streak, 0) DESC, COALESCE(ms.max_streak, 0) DESC;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "get_player_caps",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_player_caps(target_year integer DEFAULT NULL::integer)\n RETURNS TABLE(id uuid, friendly_name text, total_games integer)\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    RETURN QUERY\r\n    SELECT \r\n        p.id,\r\n        p.friendly_name,\r\n        COUNT(gr.id)::integer as total_games\r\n    FROM players p\r\n    JOIN game_registrations gr ON gr.player_id = p.id\r\n    JOIN games g ON gr.game_id = g.id\r\n    WHERE gr.status = 'selected'\r\n    AND g.date <= NOW()  -- Only count games that have already happened\r\n    AND (target_year IS NULL OR EXTRACT(YEAR FROM g.date) = target_year)\r\n    GROUP BY p.id, p.friendly_name\r\n    HAVING COUNT(gr.id) >= 10\r\n    ORDER BY COUNT(gr.id) DESC;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "record",
    "source_code": "\r\nBEGIN\r\n    RETURN QUERY\r\n    SELECT \r\n        p.id,\r\n        p.friendly_name,\r\n        COUNT(gr.id)::integer as total_games\r\n    FROM players p\r\n    JOIN game_registrations gr ON gr.player_id = p.id\r\n    JOIN games g ON gr.game_id = g.id\r\n    WHERE gr.status = 'selected'\r\n    AND g.date <= NOW()  -- Only count games that have already happened\r\n    AND (target_year IS NULL OR EXTRACT(YEAR FROM g.date) = target_year)\r\n    GROUP BY p.id, p.friendly_name\r\n    HAVING COUNT(gr.id) >= 10\r\n    ORDER BY COUNT(gr.id) DESC;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "get_player_game_sequences",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_player_game_sequences()\n RETURNS TABLE(player_id uuid, game_sequences bigint[])\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  RETURN QUERY\r\n  WITH game_numbers AS (\r\n    SELECT \r\n      gr.player_id,\r\n      g.id as game_id,\r\n      ROW_NUMBER() OVER (PARTITION BY gr.player_id ORDER BY g.date DESC) as game_sequence\r\n    FROM game_registrations gr\r\n    JOIN games g ON gr.game_id = g.id\r\n    WHERE gr.status = 'selected'\r\n  )\r\n  SELECT \r\n    gn.player_id,\r\n    ARRAY_AGG(gn.game_sequence ORDER BY gn.game_sequence) as game_sequences\r\n  FROM game_numbers gn\r\n  GROUP BY gn.player_id;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "record",
    "source_code": "\r\nBEGIN\r\n  RETURN QUERY\r\n  WITH game_numbers AS (\r\n    SELECT \r\n      gr.player_id,\r\n      g.id as game_id,\r\n      ROW_NUMBER() OVER (PARTITION BY gr.player_id ORDER BY g.date DESC) as game_sequence\r\n    FROM game_registrations gr\r\n    JOIN games g ON gr.game_id = g.id\r\n    WHERE gr.status = 'selected'\r\n  )\r\n  SELECT \r\n    gn.player_id,\r\n    ARRAY_AGG(gn.game_sequence ORDER BY gn.game_sequence) as game_sequences\r\n  FROM game_numbers gn\r\n  GROUP BY gn.player_id;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "get_player_rank",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_player_rank(player_uuid uuid)\n RETURNS integer\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    RETURN (\r\n        SELECT rank\r\n        FROM player_xp\r\n        WHERE player_id = player_uuid\r\n    );\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "integer",
    "source_code": "\r\nBEGIN\r\n    RETURN (\r\n        SELECT rank\r\n        FROM player_xp\r\n        WHERE player_id = player_uuid\r\n    );\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "get_player_stats",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_player_stats(target_year integer DEFAULT NULL::integer)\n RETURNS TABLE(id uuid, friendly_name text, caps integer, win_rate numeric, current_streak integer, max_streak integer, recent_games integer)\n LANGUAGE sql\nAS $function$\r\n  WITH player_base AS (\r\n    SELECT \r\n      p.id::uuid as player_id,\r\n      p.friendly_name::text,\r\n      COUNT(DISTINCT g.id)::integer as total_games,\r\n      SUM(CASE \r\n        WHEN (gr.team = 'blue' AND g.score_blue > g.score_orange) OR \r\n             (gr.team = 'orange' AND g.score_orange > g.score_blue) \r\n        THEN 1 \r\n        ELSE 0\r\n      END)::integer as wins,\r\n      COUNT(CASE WHEN g.score_blue != g.score_orange THEN 1 END)::integer as non_draws\r\n    FROM players p\r\n    LEFT JOIN game_registrations gr ON gr.player_id = p.id\r\n    LEFT JOIN games g ON g.id = gr.game_id \r\n      AND gr.status = 'selected'\r\n      AND g.status = 'completed'\r\n      AND (target_year IS NULL OR EXTRACT(YEAR FROM g.created_at)::integer = target_year)\r\n    GROUP BY p.id, p.friendly_name\r\n    HAVING COUNT(DISTINCT g.id) >= 10\r\n  ),\r\n  player_streaks AS (\r\n    SELECT \r\n      pb.player_id,\r\n      s.current_streak,\r\n      s.max_streak\r\n    FROM player_base pb\r\n    CROSS JOIN LATERAL calculate_player_streaks(pb.player_id) s\r\n  ),\r\n  recent_games AS (\r\n    SELECT \r\n      pb.player_id,\r\n      COUNT(*)::integer as recent_count\r\n    FROM player_base pb\r\n    JOIN game_registrations gr ON gr.player_id = pb.player_id\r\n    JOIN games g ON g.id = gr.game_id\r\n    WHERE gr.status = 'selected'\r\n    AND g.status = 'completed'\r\n    AND g.created_at >= (\r\n      SELECT g2.created_at \r\n      FROM games g2\r\n      JOIN game_registrations gr2 ON gr2.game_id = g2.id\r\n      WHERE gr2.player_id = pb.player_id\r\n      AND gr2.status = 'selected'\r\n      AND g2.status = 'completed'\r\n      ORDER BY g2.created_at DESC\r\n      OFFSET 9 LIMIT 1\r\n    )\r\n    GROUP BY pb.player_id\r\n  )\r\n  SELECT \r\n    pb.player_id::uuid as id,\r\n    pb.friendly_name::text,\r\n    pb.total_games::integer as caps,\r\n    ROUND((pb.wins::numeric / NULLIF(pb.non_draws, 0)::numeric), 3) as win_rate,\r\n    COALESCE(ps.current_streak, 0)::integer as current_streak,\r\n    COALESCE(ps.max_streak, 0)::integer as max_streak,\r\n    COALESCE(rg.recent_count, 0)::integer as recent_games\r\n  FROM player_base pb\r\n  LEFT JOIN player_streaks ps ON ps.player_id = pb.player_id\r\n  LEFT JOIN recent_games rg ON rg.player_id = pb.player_id\r\n  ORDER BY \r\n    CASE WHEN target_year IS NULL THEN ps.max_streak ELSE ps.current_streak END DESC NULLS LAST,\r\n    pb.total_games DESC;\r\n$function$\n",
    "function_description": null,
    "return_type": "record",
    "source_code": "\r\n  WITH player_base AS (\r\n    SELECT \r\n      p.id::uuid as player_id,\r\n      p.friendly_name::text,\r\n      COUNT(DISTINCT g.id)::integer as total_games,\r\n      SUM(CASE \r\n        WHEN (gr.team = 'blue' AND g.score_blue > g.score_orange) OR \r\n             (gr.team = 'orange' AND g.score_orange > g.score_blue) \r\n        THEN 1 \r\n        ELSE 0\r\n      END)::integer as wins,\r\n      COUNT(CASE WHEN g.score_blue != g.score_orange THEN 1 END)::integer as non_draws\r\n    FROM players p\r\n    LEFT JOIN game_registrations gr ON gr.player_id = p.id\r\n    LEFT JOIN games g ON g.id = gr.game_id \r\n      AND gr.status = 'selected'\r\n      AND g.status = 'completed'\r\n      AND (target_year IS NULL OR EXTRACT(YEAR FROM g.created_at)::integer = target_year)\r\n    GROUP BY p.id, p.friendly_name\r\n    HAVING COUNT(DISTINCT g.id) >= 10\r\n  ),\r\n  player_streaks AS (\r\n    SELECT \r\n      pb.player_id,\r\n      s.current_streak,\r\n      s.max_streak\r\n    FROM player_base pb\r\n    CROSS JOIN LATERAL calculate_player_streaks(pb.player_id) s\r\n  ),\r\n  recent_games AS (\r\n    SELECT \r\n      pb.player_id,\r\n      COUNT(*)::integer as recent_count\r\n    FROM player_base pb\r\n    JOIN game_registrations gr ON gr.player_id = pb.player_id\r\n    JOIN games g ON g.id = gr.game_id\r\n    WHERE gr.status = 'selected'\r\n    AND g.status = 'completed'\r\n    AND g.created_at >= (\r\n      SELECT g2.created_at \r\n      FROM games g2\r\n      JOIN game_registrations gr2 ON gr2.game_id = g2.id\r\n      WHERE gr2.player_id = pb.player_id\r\n      AND gr2.status = 'selected'\r\n      AND g2.status = 'completed'\r\n      ORDER BY g2.created_at DESC\r\n      OFFSET 9 LIMIT 1\r\n    )\r\n    GROUP BY pb.player_id\r\n  )\r\n  SELECT \r\n    pb.player_id::uuid as id,\r\n    pb.friendly_name::text,\r\n    pb.total_games::integer as caps,\r\n    ROUND((pb.wins::numeric / NULLIF(pb.non_draws, 0)::numeric), 3) as win_rate,\r\n    COALESCE(ps.current_streak, 0)::integer as current_streak,\r\n    COALESCE(ps.max_streak, 0)::integer as max_streak,\r\n    COALESCE(rg.recent_count, 0)::integer as recent_games\r\n  FROM player_base pb\r\n  LEFT JOIN player_streaks ps ON ps.player_id = pb.player_id\r\n  LEFT JOIN recent_games rg ON rg.player_id = pb.player_id\r\n  ORDER BY \r\n    CASE WHEN target_year IS NULL THEN ps.max_streak ELSE ps.current_streak END DESC NULLS LAST,\r\n    pb.total_games DESC;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "get_player_team_colors",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_player_team_colors(target_year integer DEFAULT NULL::integer)\n RETURNS TABLE(id uuid, friendly_name text, team text, team_frequency numeric, caps integer)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n  RETURN QUERY\r\n  WITH player_games AS (\r\n    -- Get total games for each player\r\n    SELECT \r\n      p.id as player_id,\r\n      p.friendly_name as player_name,\r\n      COUNT(*)::integer as total_games\r\n    FROM players p\r\n    JOIN game_registrations gr ON p.id = gr.player_id\r\n    JOIN games g ON gr.game_id = g.id\r\n    WHERE gr.status = 'selected'\r\n    AND (target_year IS NULL OR EXTRACT(YEAR FROM g.created_at) = target_year)\r\n    GROUP BY p.id, p.friendly_name\r\n    HAVING COUNT(*) >= 10\r\n  ),\r\n  team_frequencies AS (\r\n    -- Calculate frequency for each team\r\n    SELECT \r\n      p.id as player_id,\r\n      p.friendly_name as player_name,\r\n      gr.team as player_team,\r\n      COUNT(*)::numeric as team_games,\r\n      pg.total_games,\r\n      ROUND(COUNT(*)::numeric / pg.total_games, 3) as frequency\r\n    FROM players p\r\n    JOIN game_registrations gr ON p.id = gr.player_id\r\n    JOIN games g ON gr.game_id = g.id\r\n    JOIN player_games pg ON p.id = pg.player_id\r\n    WHERE gr.status = 'selected'\r\n    AND gr.team IN ('blue', 'orange')\r\n    AND (target_year IS NULL OR EXTRACT(YEAR FROM g.created_at) = target_year)\r\n    GROUP BY p.id, p.friendly_name, gr.team, pg.total_games\r\n  )\r\n  SELECT\r\n    tf1.player_id as id,\r\n    tf1.player_name as friendly_name,\r\n    tf1.player_team as team,\r\n    tf1.frequency as team_frequency,\r\n    tf1.total_games as caps\r\n  FROM team_frequencies tf1\r\n  WHERE tf1.frequency >= 0.5  -- Only show players who play on a team more than 50% of the time\r\n  AND NOT EXISTS (\r\n    -- Exclude if they play more on the other team\r\n    SELECT 1 FROM team_frequencies tf2\r\n    WHERE tf1.player_id = tf2.player_id\r\n    AND tf2.frequency > tf1.frequency\r\n  )\r\n  ORDER BY tf1.frequency DESC, tf1.total_games DESC;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "record",
    "source_code": "\r\nBEGIN\r\n  RETURN QUERY\r\n  WITH player_games AS (\r\n    -- Get total games for each player\r\n    SELECT \r\n      p.id as player_id,\r\n      p.friendly_name as player_name,\r\n      COUNT(*)::integer as total_games\r\n    FROM players p\r\n    JOIN game_registrations gr ON p.id = gr.player_id\r\n    JOIN games g ON gr.game_id = g.id\r\n    WHERE gr.status = 'selected'\r\n    AND (target_year IS NULL OR EXTRACT(YEAR FROM g.created_at) = target_year)\r\n    GROUP BY p.id, p.friendly_name\r\n    HAVING COUNT(*) >= 10\r\n  ),\r\n  team_frequencies AS (\r\n    -- Calculate frequency for each team\r\n    SELECT \r\n      p.id as player_id,\r\n      p.friendly_name as player_name,\r\n      gr.team as player_team,\r\n      COUNT(*)::numeric as team_games,\r\n      pg.total_games,\r\n      ROUND(COUNT(*)::numeric / pg.total_games, 3) as frequency\r\n    FROM players p\r\n    JOIN game_registrations gr ON p.id = gr.player_id\r\n    JOIN games g ON gr.game_id = g.id\r\n    JOIN player_games pg ON p.id = pg.player_id\r\n    WHERE gr.status = 'selected'\r\n    AND gr.team IN ('blue', 'orange')\r\n    AND (target_year IS NULL OR EXTRACT(YEAR FROM g.created_at) = target_year)\r\n    GROUP BY p.id, p.friendly_name, gr.team, pg.total_games\r\n  )\r\n  SELECT\r\n    tf1.player_id as id,\r\n    tf1.player_name as friendly_name,\r\n    tf1.player_team as team,\r\n    tf1.frequency as team_frequency,\r\n    tf1.total_games as caps\r\n  FROM team_frequencies tf1\r\n  WHERE tf1.frequency >= 0.5  -- Only show players who play on a team more than 50% of the time\r\n  AND NOT EXISTS (\r\n    -- Exclude if they play more on the other team\r\n    SELECT 1 FROM team_frequencies tf2\r\n    WHERE tf1.player_id = tf2.player_id\r\n    AND tf2.frequency > tf1.frequency\r\n  )\r\n  ORDER BY tf1.frequency DESC, tf1.total_games DESC;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": true
  },
  {
    "function_name": "get_player_win_rates",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_player_win_rates(target_year integer DEFAULT NULL::integer)\n RETURNS TABLE(id uuid, friendly_name text, total_games integer, wins integer, draws integer, losses integer, win_rate numeric)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n    RETURN QUERY\r\n    WITH player_games AS (\r\n        SELECT \r\n            p.id,\r\n            p.friendly_name,\r\n            g.outcome,\r\n            gr.team,\r\n            -- Count players on each team\r\n            (SELECT COUNT(*) FILTER (WHERE team = 'blue' AND status = 'selected') \r\n             FROM game_registrations gr2 \r\n             WHERE gr2.game_id = g.id) as blue_count,\r\n            (SELECT COUNT(*) FILTER (WHERE team = 'orange' AND status = 'selected') \r\n             FROM game_registrations gr2 \r\n             WHERE gr2.game_id = g.id) as orange_count,\r\n            -- Determine result for each player\r\n            CASE \r\n                WHEN g.outcome = 'draw' THEN 'draw'\r\n                WHEN (gr.team = 'blue' AND g.outcome = 'blue_win') OR \r\n                     (gr.team = 'orange' AND g.outcome = 'orange_win') THEN 'win'\r\n                WHEN (gr.team = 'blue' AND g.outcome = 'orange_win') OR \r\n                     (gr.team = 'orange' AND g.outcome = 'blue_win') THEN 'loss'\r\n            END as player_result\r\n        FROM players p\r\n        JOIN game_registrations gr ON gr.player_id = p.id\r\n        JOIN games g ON g.id = gr.game_id\r\n        WHERE gr.status = 'selected'\r\n        AND g.outcome IS NOT NULL\r\n        AND (target_year IS NULL OR EXTRACT(YEAR FROM g.date) = target_year)\r\n    )\r\n    SELECT \r\n        p.id,\r\n        p.friendly_name,\r\n        -- Count all games with even teams\r\n        COUNT(*) FILTER (WHERE pg.blue_count = pg.orange_count)::integer as total_games,\r\n        COUNT(*) FILTER (WHERE pg.blue_count = pg.orange_count AND pg.player_result = 'win')::integer as wins,\r\n        COUNT(*) FILTER (WHERE pg.blue_count = pg.orange_count AND pg.player_result = 'draw')::integer as draws,\r\n        COUNT(*) FILTER (WHERE pg.blue_count = pg.orange_count AND pg.player_result = 'loss')::integer as losses,\r\n        -- Calculate win rate percentage only if they have 10+ games\r\n        CASE \r\n            WHEN COUNT(*) FILTER (WHERE pg.blue_count = pg.orange_count) >= 10 THEN\r\n                ROUND(\r\n                    COUNT(*) FILTER (WHERE pg.blue_count = pg.orange_count AND pg.player_result = 'win')::numeric / \r\n                    NULLIF(COUNT(*) FILTER (WHERE pg.blue_count = pg.orange_count), 0) * 100,\r\n                    1\r\n                )\r\n            ELSE NULL\r\n        END as win_rate\r\n    FROM players p\r\n    LEFT JOIN player_games pg ON pg.id = p.id\r\n    GROUP BY p.id, p.friendly_name\r\n    ORDER BY win_rate DESC NULLS LAST;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "record",
    "source_code": "\r\nBEGIN\r\n    RETURN QUERY\r\n    WITH player_games AS (\r\n        SELECT \r\n            p.id,\r\n            p.friendly_name,\r\n            g.outcome,\r\n            gr.team,\r\n            -- Count players on each team\r\n            (SELECT COUNT(*) FILTER (WHERE team = 'blue' AND status = 'selected') \r\n             FROM game_registrations gr2 \r\n             WHERE gr2.game_id = g.id) as blue_count,\r\n            (SELECT COUNT(*) FILTER (WHERE team = 'orange' AND status = 'selected') \r\n             FROM game_registrations gr2 \r\n             WHERE gr2.game_id = g.id) as orange_count,\r\n            -- Determine result for each player\r\n            CASE \r\n                WHEN g.outcome = 'draw' THEN 'draw'\r\n                WHEN (gr.team = 'blue' AND g.outcome = 'blue_win') OR \r\n                     (gr.team = 'orange' AND g.outcome = 'orange_win') THEN 'win'\r\n                WHEN (gr.team = 'blue' AND g.outcome = 'orange_win') OR \r\n                     (gr.team = 'orange' AND g.outcome = 'blue_win') THEN 'loss'\r\n            END as player_result\r\n        FROM players p\r\n        JOIN game_registrations gr ON gr.player_id = p.id\r\n        JOIN games g ON g.id = gr.game_id\r\n        WHERE gr.status = 'selected'\r\n        AND g.outcome IS NOT NULL\r\n        AND (target_year IS NULL OR EXTRACT(YEAR FROM g.date) = target_year)\r\n    )\r\n    SELECT \r\n        p.id,\r\n        p.friendly_name,\r\n        -- Count all games with even teams\r\n        COUNT(*) FILTER (WHERE pg.blue_count = pg.orange_count)::integer as total_games,\r\n        COUNT(*) FILTER (WHERE pg.blue_count = pg.orange_count AND pg.player_result = 'win')::integer as wins,\r\n        COUNT(*) FILTER (WHERE pg.blue_count = pg.orange_count AND pg.player_result = 'draw')::integer as draws,\r\n        COUNT(*) FILTER (WHERE pg.blue_count = pg.orange_count AND pg.player_result = 'loss')::integer as losses,\r\n        -- Calculate win rate percentage only if they have 10+ games\r\n        CASE \r\n            WHEN COUNT(*) FILTER (WHERE pg.blue_count = pg.orange_count) >= 10 THEN\r\n                ROUND(\r\n                    COUNT(*) FILTER (WHERE pg.blue_count = pg.orange_count AND pg.player_result = 'win')::numeric / \r\n                    NULLIF(COUNT(*) FILTER (WHERE pg.blue_count = pg.orange_count), 0) * 100,\r\n                    1\r\n                )\r\n            ELSE NULL\r\n        END as win_rate\r\n    FROM players p\r\n    LEFT JOIN player_games pg ON pg.id = p.id\r\n    GROUP BY p.id, p.friendly_name\r\n    ORDER BY win_rate DESC NULLS LAST;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": true
  },
  {
    "function_name": "get_player_with_reserve_xp",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_player_with_reserve_xp(p_player_id uuid)\n RETURNS TABLE(id uuid, friendly_name text, avatar_svg text, caps integer, active_bonuses integer, active_penalties integer, current_streak integer, max_streak integer, win_rate numeric, xp integer, user_id uuid, reserve_xp integer, reserve_count integer)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n    RETURN QUERY\r\n    SELECT \r\n        p.id,\r\n        p.friendly_name,\r\n        p.avatar_svg,\r\n        p.caps,\r\n        p.active_bonuses,\r\n        p.active_penalties,\r\n        p.current_streak,\r\n        p.max_streak,\r\n        p.win_rate,\r\n        COALESCE(px.xp, 0) as xp,\r\n        p.user_id,\r\n        COALESCE(SUM(rt.xp_amount), 0)::INTEGER as reserve_xp,\r\n        COUNT(rt.id)::INTEGER as reserve_count\r\n    FROM players p\r\n    LEFT JOIN player_xp px ON px.player_id = p.id\r\n    LEFT JOIN reserve_xp_transactions rt ON rt.player_id = p.id\r\n    WHERE p.id = p_player_id\r\n    GROUP BY \r\n        p.id,\r\n        p.friendly_name,\r\n        p.avatar_svg,\r\n        p.caps,\r\n        p.active_bonuses,\r\n        p.active_penalties,\r\n        p.current_streak,\r\n        p.max_streak,\r\n        p.win_rate,\r\n        px.xp,\r\n        p.user_id;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "record",
    "source_code": "\r\nBEGIN\r\n    RETURN QUERY\r\n    SELECT \r\n        p.id,\r\n        p.friendly_name,\r\n        p.avatar_svg,\r\n        p.caps,\r\n        p.active_bonuses,\r\n        p.active_penalties,\r\n        p.current_streak,\r\n        p.max_streak,\r\n        p.win_rate,\r\n        COALESCE(px.xp, 0) as xp,\r\n        p.user_id,\r\n        COALESCE(SUM(rt.xp_amount), 0)::INTEGER as reserve_xp,\r\n        COUNT(rt.id)::INTEGER as reserve_count\r\n    FROM players p\r\n    LEFT JOIN player_xp px ON px.player_id = p.id\r\n    LEFT JOIN reserve_xp_transactions rt ON rt.player_id = p.id\r\n    WHERE p.id = p_player_id\r\n    GROUP BY \r\n        p.id,\r\n        p.friendly_name,\r\n        p.avatar_svg,\r\n        p.caps,\r\n        p.active_bonuses,\r\n        p.active_penalties,\r\n        p.current_streak,\r\n        p.max_streak,\r\n        p.win_rate,\r\n        px.xp,\r\n        p.user_id;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": true
  },
  {
    "function_name": "get_players_with_game_count",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_players_with_game_count(current_player_id uuid)\n RETURNS TABLE(id uuid, friendly_name text, games_played bigint)\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    RETURN QUERY\r\n    SELECT \r\n        p.id,\r\n        p.friendly_name,\r\n        COUNT(DISTINCT gr1.game_id)::BIGINT as games_played\r\n    FROM players p\r\n    LEFT JOIN (\r\n        SELECT gr1.player_id, gr1.game_id\r\n        FROM game_registrations gr1\r\n        INNER JOIN game_registrations gr2 ON gr1.game_id = gr2.game_id\r\n            AND gr2.player_id = current_player_id\r\n            AND gr2.status IN ('selected', 'confirmed')\r\n        INNER JOIN games g ON gr1.game_id = g.id\r\n            AND g.completed = true\r\n        WHERE gr1.status IN ('selected', 'confirmed')\r\n    ) gr1 ON gr1.player_id = p.id\r\n    WHERE p.id != current_player_id\r\n    GROUP BY p.id, p.friendly_name\r\n    ORDER BY p.friendly_name;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "record",
    "source_code": "\r\nBEGIN\r\n    RETURN QUERY\r\n    SELECT \r\n        p.id,\r\n        p.friendly_name,\r\n        COUNT(DISTINCT gr1.game_id)::BIGINT as games_played\r\n    FROM players p\r\n    LEFT JOIN (\r\n        SELECT gr1.player_id, gr1.game_id\r\n        FROM game_registrations gr1\r\n        INNER JOIN game_registrations gr2 ON gr1.game_id = gr2.game_id\r\n            AND gr2.player_id = current_player_id\r\n            AND gr2.status IN ('selected', 'confirmed')\r\n        INNER JOIN games g ON gr1.game_id = g.id\r\n            AND g.completed = true\r\n        WHERE gr1.status IN ('selected', 'confirmed')\r\n    ) gr1 ON gr1.player_id = p.id\r\n    WHERE p.id != current_player_id\r\n    GROUP BY p.id, p.friendly_name\r\n    ORDER BY p.friendly_name;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "get_random_weighted_players",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_random_weighted_players()\n RETURNS TABLE(id uuid, friendly_name text, caps integer, chance_of_playing_percentage numeric)\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  team_size integer;\r\nBEGIN\r\n  -- Generate random team size between 18 and 22\r\n  team_size := floor(random() * (22-18+1) + 18)::int;\r\n\r\n  RETURN QUERY\r\n  WITH random_team_size AS (\r\n    SELECT team_size as size\r\n  ),\r\n  player_probabilities AS (\r\n    SELECT \r\n      p.id,\r\n      p.friendly_name,\r\n      COALESCE(p.caps, 0) as caps,\r\n      CASE \r\n        WHEN SUM(COALESCE(p.caps, 0)) OVER () = 0 THEN 1.0/COUNT(*) OVER ()\r\n        ELSE CAST(COALESCE(p.caps, 0) AS FLOAT) / NULLIF(SUM(COALESCE(p.caps, 0)) OVER (), 0)\r\n      END as play_probability\r\n    FROM players p\r\n  ),\r\n  ranked_random_selection AS (\r\n    SELECT \r\n      p.*,\r\n      (SELECT size FROM random_team_size) as team_size,\r\n      ROW_NUMBER() OVER (ORDER BY random() * play_probability DESC) as selection_rank\r\n    FROM player_probabilities p\r\n  )\r\n  SELECT \r\n    rrs.id,\r\n    rrs.friendly_name,\r\n    rrs.caps,\r\n    (rrs.play_probability * 100)::numeric(5,2) as chance_of_playing_percentage\r\n  FROM ranked_random_selection rrs\r\n  WHERE rrs.selection_rank <= rrs.team_size\r\n  ORDER BY rrs.selection_rank;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "record",
    "source_code": "\r\nDECLARE\r\n  team_size integer;\r\nBEGIN\r\n  -- Generate random team size between 18 and 22\r\n  team_size := floor(random() * (22-18+1) + 18)::int;\r\n\r\n  RETURN QUERY\r\n  WITH random_team_size AS (\r\n    SELECT team_size as size\r\n  ),\r\n  player_probabilities AS (\r\n    SELECT \r\n      p.id,\r\n      p.friendly_name,\r\n      COALESCE(p.caps, 0) as caps,\r\n      CASE \r\n        WHEN SUM(COALESCE(p.caps, 0)) OVER () = 0 THEN 1.0/COUNT(*) OVER ()\r\n        ELSE CAST(COALESCE(p.caps, 0) AS FLOAT) / NULLIF(SUM(COALESCE(p.caps, 0)) OVER (), 0)\r\n      END as play_probability\r\n    FROM players p\r\n  ),\r\n  ranked_random_selection AS (\r\n    SELECT \r\n      p.*,\r\n      (SELECT size FROM random_team_size) as team_size,\r\n      ROW_NUMBER() OVER (ORDER BY random() * play_probability DESC) as selection_rank\r\n    FROM player_probabilities p\r\n  )\r\n  SELECT \r\n    rrs.id,\r\n    rrs.friendly_name,\r\n    rrs.caps,\r\n    (rrs.play_probability * 100)::numeric(5,2) as chance_of_playing_percentage\r\n  FROM ranked_random_selection rrs\r\n  WHERE rrs.selection_rank <= rrs.team_size\r\n  ORDER BY rrs.selection_rank;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "get_reserve_players_by_xp",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_reserve_players_by_xp(p_game_id uuid)\n RETURNS TABLE(player_id uuid, xp numeric, rank integer)\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    RETURN QUERY\r\n    WITH player_xp AS (\r\n        SELECT \r\n            p.id,\r\n            (p.caps * \r\n                GREATEST(\r\n                    (10 + \r\n                     COALESCE(p.active_bonuses, 0) - \r\n                     COALESCE(p.active_penalties, 0) + \r\n                     COALESCE(p.current_streak, 0)\r\n                    ), \r\n                    1\r\n                )\r\n            ) as calculated_xp\r\n        FROM game_registrations gr\r\n        INNER JOIN players p ON p.id = gr.player_id\r\n        WHERE gr.game_id = p_game_id\r\n        AND gr.status = 'reserve'\r\n    )\r\n    SELECT \r\n        px.id,\r\n        px.calculated_xp,\r\n        RANK() OVER (ORDER BY px.calculated_xp DESC)::INTEGER\r\n    FROM player_xp px;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "record",
    "source_code": "\r\nBEGIN\r\n    RETURN QUERY\r\n    WITH player_xp AS (\r\n        SELECT \r\n            p.id,\r\n            (p.caps * \r\n                GREATEST(\r\n                    (10 + \r\n                     COALESCE(p.active_bonuses, 0) - \r\n                     COALESCE(p.active_penalties, 0) + \r\n                     COALESCE(p.current_streak, 0)\r\n                    ), \r\n                    1\r\n                )\r\n            ) as calculated_xp\r\n        FROM game_registrations gr\r\n        INNER JOIN players p ON p.id = gr.player_id\r\n        WHERE gr.game_id = p_game_id\r\n        AND gr.status = 'reserve'\r\n    )\r\n    SELECT \r\n        px.id,\r\n        px.calculated_xp,\r\n        RANK() OVER (ORDER BY px.calculated_xp DESC)::INTEGER\r\n    FROM player_xp px;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "get_suggested_players_to_rate",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_suggested_players_to_rate(current_player_id uuid, min_games_together integer DEFAULT 5)\n RETURNS TABLE(id uuid, friendly_name text, games_together bigint, total_players_played_with bigint, total_players_rated bigint, max_games_with_any_player bigint, status text, next_eligible_count bigint)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\ndeclare\r\n  total_played bigint;\r\n  total_rated bigint;\r\n  max_games bigint;\r\n  almost_eligible bigint;\r\nbegin\r\n  -- Get players close to being eligible (3-4 games)\r\n  select count(*)\r\n  into almost_eligible\r\n  from (\r\n    select count(distinct g.id) as games\r\n    from games g\r\n    join game_registrations gr1 on g.id = gr1.game_id\r\n    join game_registrations gr2 on g.id = gr2.game_id\r\n    where gr1.player_id = current_player_id\r\n    and gr2.player_id != current_player_id\r\n    and g.status = 'open'\r\n    and g.date < NOW()\r\n    group by gr2.player_id\r\n    having count(distinct g.id) between 3 and 4\r\n  ) as almost;\r\n\r\n  -- Get total players played with and max games\r\n  with player_games as (\r\n    select distinct \r\n      g.id as game_id,\r\n      p.id as player_id,\r\n      p.friendly_name as player_name\r\n    from games g\r\n    join game_registrations gr1 on g.id = gr1.game_id\r\n    join game_registrations gr2 on g.id = gr2.game_id\r\n    join players p on gr2.player_id = p.id\r\n    where gr1.player_id = current_player_id\r\n    and g.status = 'open'\r\n    and g.date < NOW()\r\n    and gr2.player_id != current_player_id\r\n  ),\r\n  games_count as (\r\n    select \r\n      player_id,\r\n      player_name,\r\n      count(*) as games_count\r\n    from player_games\r\n    group by player_id, player_name\r\n  )\r\n  select \r\n    count(distinct player_id),\r\n    coalesce(max(games_count), 0)\r\n  into\r\n    total_played,\r\n    max_games\r\n  from games_count;\r\n\r\n  -- Get total players rated\r\n  select count(distinct rated_player_id)\r\n  into total_rated\r\n  from player_ratings\r\n  where rater_id = current_player_id;\r\n\r\n  -- Get player to rate if available\r\n  return query\r\n  with games_together as (\r\n    select \r\n      p.id as player_id,\r\n      p.friendly_name as player_name,\r\n      count(distinct g.id) as games_count\r\n    from games g\r\n    join game_registrations gr1 on g.id = gr1.game_id\r\n    join game_registrations gr2 on g.id = gr2.game_id\r\n    join players p on gr2.player_id = p.id\r\n    where gr1.player_id = current_player_id\r\n    and gr2.player_id != current_player_id\r\n    and g.status = 'open'\r\n    and g.date < NOW()\r\n    group by p.id, p.friendly_name\r\n    having count(distinct g.id) >= min_games_together\r\n  ),\r\n  existing_ratings as (\r\n    select distinct rated_player_id\r\n    from player_ratings\r\n    where rater_id = current_player_id\r\n  ),\r\n  player_to_rate as (\r\n    select \r\n      gt.player_id as id,\r\n      gt.player_name as friendly_name,\r\n      gt.games_count as games_together\r\n    from games_together gt\r\n    left join existing_ratings er on gt.player_id = er.rated_player_id\r\n    where er.rated_player_id is null\r\n    order by gt.games_count desc\r\n    limit 1\r\n  )\r\n  select \r\n    ptr.id,\r\n    ptr.friendly_name,\r\n    ptr.games_together,\r\n    total_played,\r\n    total_rated,\r\n    max_games,\r\n    case\r\n      when total_played = 0 then 'No past games found'\r\n      when max_games < min_games_together then \r\n        format('Need to play at least %s games with a player (current max: %s games)', min_games_together, max_games)\r\n      when total_rated >= total_played then \r\n        format('You''ve rated all %s eligible players! (%s/%s players have played %s+ games with you)', \r\n          total_rated, total_rated, total_played, min_games_together)\r\n      else 'Player available to rate'\r\n    end as status,\r\n    almost_eligible as next_eligible_count\r\n  from player_to_rate ptr\r\n  union all\r\n  select \r\n    null::uuid,\r\n    null::text,\r\n    0::bigint,\r\n    total_played,\r\n    total_rated,\r\n    max_games,\r\n    case\r\n      when total_played = 0 then 'No past games found'\r\n      when max_games < min_games_together then \r\n        format('Need to play at least %s games with a player (current max: %s games)', min_games_together, max_games)\r\n      when total_rated >= total_played then \r\n        format('You''ve rated all %s eligible players! (%s/%s players have played %s+ games with you)%s', \r\n          total_rated, total_rated, total_played, min_games_together,\r\n          case when almost_eligible > 0 \r\n            then format(E'\\n%s players are close to being eligible (3-4 games played)', almost_eligible)\r\n            else ''\r\n          end)\r\n      else 'No players to rate'\r\n    end as status,\r\n    almost_eligible as next_eligible_count\r\n  where not exists (select 1 from player_to_rate)\r\n  limit 1;\r\nend;\r\n$function$\n",
    "function_description": null,
    "return_type": "record",
    "source_code": "\r\ndeclare\r\n  total_played bigint;\r\n  total_rated bigint;\r\n  max_games bigint;\r\n  almost_eligible bigint;\r\nbegin\r\n  -- Get players close to being eligible (3-4 games)\r\n  select count(*)\r\n  into almost_eligible\r\n  from (\r\n    select count(distinct g.id) as games\r\n    from games g\r\n    join game_registrations gr1 on g.id = gr1.game_id\r\n    join game_registrations gr2 on g.id = gr2.game_id\r\n    where gr1.player_id = current_player_id\r\n    and gr2.player_id != current_player_id\r\n    and g.status = 'open'\r\n    and g.date < NOW()\r\n    group by gr2.player_id\r\n    having count(distinct g.id) between 3 and 4\r\n  ) as almost;\r\n\r\n  -- Get total players played with and max games\r\n  with player_games as (\r\n    select distinct \r\n      g.id as game_id,\r\n      p.id as player_id,\r\n      p.friendly_name as player_name\r\n    from games g\r\n    join game_registrations gr1 on g.id = gr1.game_id\r\n    join game_registrations gr2 on g.id = gr2.game_id\r\n    join players p on gr2.player_id = p.id\r\n    where gr1.player_id = current_player_id\r\n    and g.status = 'open'\r\n    and g.date < NOW()\r\n    and gr2.player_id != current_player_id\r\n  ),\r\n  games_count as (\r\n    select \r\n      player_id,\r\n      player_name,\r\n      count(*) as games_count\r\n    from player_games\r\n    group by player_id, player_name\r\n  )\r\n  select \r\n    count(distinct player_id),\r\n    coalesce(max(games_count), 0)\r\n  into\r\n    total_played,\r\n    max_games\r\n  from games_count;\r\n\r\n  -- Get total players rated\r\n  select count(distinct rated_player_id)\r\n  into total_rated\r\n  from player_ratings\r\n  where rater_id = current_player_id;\r\n\r\n  -- Get player to rate if available\r\n  return query\r\n  with games_together as (\r\n    select \r\n      p.id as player_id,\r\n      p.friendly_name as player_name,\r\n      count(distinct g.id) as games_count\r\n    from games g\r\n    join game_registrations gr1 on g.id = gr1.game_id\r\n    join game_registrations gr2 on g.id = gr2.game_id\r\n    join players p on gr2.player_id = p.id\r\n    where gr1.player_id = current_player_id\r\n    and gr2.player_id != current_player_id\r\n    and g.status = 'open'\r\n    and g.date < NOW()\r\n    group by p.id, p.friendly_name\r\n    having count(distinct g.id) >= min_games_together\r\n  ),\r\n  existing_ratings as (\r\n    select distinct rated_player_id\r\n    from player_ratings\r\n    where rater_id = current_player_id\r\n  ),\r\n  player_to_rate as (\r\n    select \r\n      gt.player_id as id,\r\n      gt.player_name as friendly_name,\r\n      gt.games_count as games_together\r\n    from games_together gt\r\n    left join existing_ratings er on gt.player_id = er.rated_player_id\r\n    where er.rated_player_id is null\r\n    order by gt.games_count desc\r\n    limit 1\r\n  )\r\n  select \r\n    ptr.id,\r\n    ptr.friendly_name,\r\n    ptr.games_together,\r\n    total_played,\r\n    total_rated,\r\n    max_games,\r\n    case\r\n      when total_played = 0 then 'No past games found'\r\n      when max_games < min_games_together then \r\n        format('Need to play at least %s games with a player (current max: %s games)', min_games_together, max_games)\r\n      when total_rated >= total_played then \r\n        format('You''ve rated all %s eligible players! (%s/%s players have played %s+ games with you)', \r\n          total_rated, total_rated, total_played, min_games_together)\r\n      else 'Player available to rate'\r\n    end as status,\r\n    almost_eligible as next_eligible_count\r\n  from player_to_rate ptr\r\n  union all\r\n  select \r\n    null::uuid,\r\n    null::text,\r\n    0::bigint,\r\n    total_played,\r\n    total_rated,\r\n    max_games,\r\n    case\r\n      when total_played = 0 then 'No past games found'\r\n      when max_games < min_games_together then \r\n        format('Need to play at least %s games with a player (current max: %s games)', min_games_together, max_games)\r\n      when total_rated >= total_played then \r\n        format('You''ve rated all %s eligible players! (%s/%s players have played %s+ games with you)%s', \r\n          total_rated, total_rated, total_played, min_games_together,\r\n          case when almost_eligible > 0 \r\n            then format(E'\\n%s players are close to being eligible (3-4 games played)', almost_eligible)\r\n            else ''\r\n          end)\r\n      else 'No players to rate'\r\n    end as status,\r\n    almost_eligible as next_eligible_count\r\n  where not exists (select 1 from player_to_rate)\r\n  limit 1;\r\nend;\r\n",
    "volatility": "v",
    "security_definer": true
  },
  {
    "function_name": "get_team_color_stats",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_team_color_stats(target_year integer DEFAULT NULL::integer)\n RETURNS TABLE(winning_color text, win_rate numeric)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n  RETURN QUERY\r\n  WITH game_results AS (\r\n    SELECT\r\n      gr.team,\r\n      g.outcome,\r\n      COUNT(*) as total_games,\r\n      SUM(CASE \r\n        WHEN (gr.team = 'blue' AND g.outcome = 'blue_win') OR \r\n             (gr.team = 'orange' AND g.outcome = 'orange_win') \r\n        THEN 1 \r\n        ELSE 0 \r\n      END) as wins\r\n    FROM game_registrations gr\r\n    JOIN games g ON gr.game_id = g.id\r\n    WHERE g.outcome IS NOT NULL\r\n    AND gr.status = 'selected'\r\n    AND (target_year IS NULL OR EXTRACT(YEAR FROM g.created_at) = target_year)\r\n    GROUP BY gr.team, g.outcome\r\n  )\r\n  SELECT\r\n    team as winning_color,\r\n    ROUND(CAST(SUM(wins) AS numeric) / NULLIF(SUM(total_games), 0), 3) as win_rate\r\n  FROM game_results\r\n  GROUP BY team\r\n  ORDER BY win_rate DESC\r\n  LIMIT 1;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "record",
    "source_code": "\r\nBEGIN\r\n  RETURN QUERY\r\n  WITH game_results AS (\r\n    SELECT\r\n      gr.team,\r\n      g.outcome,\r\n      COUNT(*) as total_games,\r\n      SUM(CASE \r\n        WHEN (gr.team = 'blue' AND g.outcome = 'blue_win') OR \r\n             (gr.team = 'orange' AND g.outcome = 'orange_win') \r\n        THEN 1 \r\n        ELSE 0 \r\n      END) as wins\r\n    FROM game_registrations gr\r\n    JOIN games g ON gr.game_id = g.id\r\n    WHERE g.outcome IS NOT NULL\r\n    AND gr.status = 'selected'\r\n    AND (target_year IS NULL OR EXTRACT(YEAR FROM g.created_at) = target_year)\r\n    GROUP BY gr.team, g.outcome\r\n  )\r\n  SELECT\r\n    team as winning_color,\r\n    ROUND(CAST(SUM(wins) AS numeric) / NULLIF(SUM(total_games), 0), 3) as win_rate\r\n  FROM game_results\r\n  GROUP BY team\r\n  ORDER BY win_rate DESC\r\n  LIMIT 1;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": true
  },
  {
    "function_name": "grant_admin_role",
    "function_definition": "CREATE OR REPLACE FUNCTION public.grant_admin_role(target_player_id uuid, make_super_admin boolean DEFAULT false, permissions admin_permission[] DEFAULT NULL::admin_permission[])\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n  new_role_id UUID;\r\n  permission admin_permission;\r\nBEGIN\r\n  -- Check if executor is super admin\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM admin_roles \r\n    WHERE player_id = (SELECT id FROM players WHERE user_id = auth.uid())\r\n    AND is_super_admin = true\r\n  ) THEN\r\n    RAISE EXCEPTION 'Only super admins can grant admin roles';\r\n  END IF;\r\n\r\n  -- Create new admin role\r\n  INSERT INTO admin_roles (player_id, is_super_admin)\r\n  VALUES (target_player_id, make_super_admin)\r\n  RETURNING id INTO new_role_id;\r\n\r\n  -- Grant permissions if provided\r\n  IF permissions IS NOT NULL THEN\r\n    FOREACH permission IN ARRAY permissions\r\n    LOOP\r\n      INSERT INTO admin_permissions (admin_role_id, permission)\r\n      VALUES (new_role_id, permission);\r\n    END LOOP;\r\n  END IF;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "void",
    "source_code": "\r\nDECLARE\r\n  new_role_id UUID;\r\n  permission admin_permission;\r\nBEGIN\r\n  -- Check if executor is super admin\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM admin_roles \r\n    WHERE player_id = (SELECT id FROM players WHERE user_id = auth.uid())\r\n    AND is_super_admin = true\r\n  ) THEN\r\n    RAISE EXCEPTION 'Only super admins can grant admin roles';\r\n  END IF;\r\n\r\n  -- Create new admin role\r\n  INSERT INTO admin_roles (player_id, is_super_admin)\r\n  VALUES (target_player_id, make_super_admin)\r\n  RETURNING id INTO new_role_id;\r\n\r\n  -- Grant permissions if provided\r\n  IF permissions IS NOT NULL THEN\r\n    FOREACH permission IN ARRAY permissions\r\n    LOOP\r\n      INSERT INTO admin_permissions (admin_role_id, permission)\r\n      VALUES (new_role_id, permission);\r\n    END LOOP;\r\n  END IF;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": true
  },
  {
    "function_name": "handle_admin_slot_offer_action",
    "function_definition": "CREATE OR REPLACE FUNCTION public.handle_admin_slot_offer_action(p_slot_offer_id uuid, p_action text, p_admin_id uuid DEFAULT NULL::uuid)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_slot_offer record;\r\n    v_game record;\r\n    v_current_players jsonb;\r\n    v_next_players UUID[];\r\n    v_hours_until_game NUMERIC;\r\n    v_game_selection_id uuid;\r\nBEGIN\r\n    -- Get slot offer details\r\n    SELECT * INTO v_slot_offer\r\n    FROM slot_offers\r\n    WHERE id = p_slot_offer_id;\r\n\r\n    IF NOT FOUND THEN\r\n        RAISE EXCEPTION 'Slot offer not found';\r\n    END IF;\r\n\r\n    -- Get game details including current selected players\r\n    SELECT g.*, gs.id as game_selection_id, gs.selected_players, \r\n           EXTRACT(EPOCH FROM (g.date - NOW())) / 3600 as hours_until_game\r\n    INTO v_game\r\n    FROM games g\r\n    LEFT JOIN game_selections gs ON gs.game_id = g.id\r\n    WHERE g.id = v_slot_offer.game_id;\r\n\r\n    IF p_action = 'accept' THEN\r\n        IF v_game.game_selection_id IS NULL THEN\r\n            -- Create new game_selections record if it doesn't exist\r\n            INSERT INTO game_selections (\r\n                game_id,\r\n                selected_players,\r\n                reserve_players,\r\n                selection_metadata\r\n            )\r\n            VALUES (\r\n                v_slot_offer.game_id,\r\n                jsonb_build_array(v_slot_offer.player_id::text),\r\n                '[]'::jsonb,\r\n                '{}'::jsonb\r\n            );\r\n        ELSE\r\n            -- Update existing game_selections record\r\n            UPDATE game_selections\r\n            SET selected_players = (\r\n                CASE \r\n                    WHEN selected_players IS NULL THEN jsonb_build_array(v_slot_offer.player_id::text)\r\n                    ELSE selected_players || jsonb_build_array(v_slot_offer.player_id::text)\r\n                END\r\n            )\r\n            WHERE id = v_game.game_selection_id;\r\n        END IF;\r\n\r\n        -- Update game registration status\r\n        UPDATE game_registrations\r\n        SET status = 'selected'\r\n        WHERE game_id = v_slot_offer.game_id\r\n        AND player_id = v_slot_offer.player_id;\r\n\r\n        -- Update slot offer status\r\n        UPDATE slot_offers\r\n        SET \r\n            status = 'accepted',\r\n            responded_at = CURRENT_TIMESTAMP,\r\n            accepted_at = CURRENT_TIMESTAMP\r\n        WHERE id = p_slot_offer_id;\r\n\r\n        -- Void other pending offers for this game\r\n        UPDATE slot_offers\r\n        SET \r\n            status = 'voided',\r\n            responded_at = CURRENT_TIMESTAMP\r\n        WHERE \r\n            game_id = v_slot_offer.game_id \r\n            AND id != p_slot_offer_id \r\n            AND status = 'pending';\r\n\r\n    ELSIF p_action = 'decline' THEN\r\n        -- Update slot offer status\r\n        UPDATE slot_offers\r\n        SET \r\n            status = 'declined',\r\n            responded_at = CURRENT_TIMESTAMP,\r\n            declined_at = CURRENT_TIMESTAMP\r\n        WHERE id = p_slot_offer_id;\r\n\r\n        -- Get next eligible players based on XP\r\n        SELECT ARRAY(\r\n            SELECT player_id \r\n            FROM get_next_slot_offer_players(v_slot_offer.game_id, v_game.hours_until_game)\r\n            LIMIT 1\r\n        ) INTO v_next_players;\r\n\r\n        -- Create new offers for next eligible players\r\n        IF array_length(v_next_players, 1) > 0 THEN\r\n            INSERT INTO slot_offers (\r\n                game_id,\r\n                player_id,\r\n                status,\r\n                offered_at,\r\n                expires_at,\r\n                available_at,\r\n                rank\r\n            )\r\n            SELECT \r\n                v_slot_offer.game_id,\r\n                player_id,\r\n                'pending'::slot_offer_status,\r\n                NOW(),\r\n                NOW() + INTERVAL '1 hour',\r\n                NOW(),\r\n                COALESCE(v_slot_offer.rank, 1) + ROW_NUMBER() OVER ()\r\n            FROM unnest(v_next_players) AS player_id;\r\n\r\n            -- Create notifications for new offers\r\n            INSERT INTO notifications (\r\n                player_id,\r\n                type,\r\n                message,\r\n                metadata\r\n            )\r\n            SELECT \r\n                player_id,\r\n                'slot_offer',\r\n                'A spot has opened up in game #' || v_game.game_number || '. Would you like to play?',\r\n                jsonb_build_object(\r\n                    'game_id', v_slot_offer.game_id,\r\n                    'action', 'new_slot_offer'\r\n                )\r\n            FROM unnest(v_next_players) AS player_id;\r\n        END IF;\r\n    END IF;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "void",
    "source_code": "\r\nDECLARE\r\n    v_slot_offer record;\r\n    v_game record;\r\n    v_current_players jsonb;\r\n    v_next_players UUID[];\r\n    v_hours_until_game NUMERIC;\r\n    v_game_selection_id uuid;\r\nBEGIN\r\n    -- Get slot offer details\r\n    SELECT * INTO v_slot_offer\r\n    FROM slot_offers\r\n    WHERE id = p_slot_offer_id;\r\n\r\n    IF NOT FOUND THEN\r\n        RAISE EXCEPTION 'Slot offer not found';\r\n    END IF;\r\n\r\n    -- Get game details including current selected players\r\n    SELECT g.*, gs.id as game_selection_id, gs.selected_players, \r\n           EXTRACT(EPOCH FROM (g.date - NOW())) / 3600 as hours_until_game\r\n    INTO v_game\r\n    FROM games g\r\n    LEFT JOIN game_selections gs ON gs.game_id = g.id\r\n    WHERE g.id = v_slot_offer.game_id;\r\n\r\n    IF p_action = 'accept' THEN\r\n        IF v_game.game_selection_id IS NULL THEN\r\n            -- Create new game_selections record if it doesn't exist\r\n            INSERT INTO game_selections (\r\n                game_id,\r\n                selected_players,\r\n                reserve_players,\r\n                selection_metadata\r\n            )\r\n            VALUES (\r\n                v_slot_offer.game_id,\r\n                jsonb_build_array(v_slot_offer.player_id::text),\r\n                '[]'::jsonb,\r\n                '{}'::jsonb\r\n            );\r\n        ELSE\r\n            -- Update existing game_selections record\r\n            UPDATE game_selections\r\n            SET selected_players = (\r\n                CASE \r\n                    WHEN selected_players IS NULL THEN jsonb_build_array(v_slot_offer.player_id::text)\r\n                    ELSE selected_players || jsonb_build_array(v_slot_offer.player_id::text)\r\n                END\r\n            )\r\n            WHERE id = v_game.game_selection_id;\r\n        END IF;\r\n\r\n        -- Update game registration status\r\n        UPDATE game_registrations\r\n        SET status = 'selected'\r\n        WHERE game_id = v_slot_offer.game_id\r\n        AND player_id = v_slot_offer.player_id;\r\n\r\n        -- Update slot offer status\r\n        UPDATE slot_offers\r\n        SET \r\n            status = 'accepted',\r\n            responded_at = CURRENT_TIMESTAMP,\r\n            accepted_at = CURRENT_TIMESTAMP\r\n        WHERE id = p_slot_offer_id;\r\n\r\n        -- Void other pending offers for this game\r\n        UPDATE slot_offers\r\n        SET \r\n            status = 'voided',\r\n            responded_at = CURRENT_TIMESTAMP\r\n        WHERE \r\n            game_id = v_slot_offer.game_id \r\n            AND id != p_slot_offer_id \r\n            AND status = 'pending';\r\n\r\n    ELSIF p_action = 'decline' THEN\r\n        -- Update slot offer status\r\n        UPDATE slot_offers\r\n        SET \r\n            status = 'declined',\r\n            responded_at = CURRENT_TIMESTAMP,\r\n            declined_at = CURRENT_TIMESTAMP\r\n        WHERE id = p_slot_offer_id;\r\n\r\n        -- Get next eligible players based on XP\r\n        SELECT ARRAY(\r\n            SELECT player_id \r\n            FROM get_next_slot_offer_players(v_slot_offer.game_id, v_game.hours_until_game)\r\n            LIMIT 1\r\n        ) INTO v_next_players;\r\n\r\n        -- Create new offers for next eligible players\r\n        IF array_length(v_next_players, 1) > 0 THEN\r\n            INSERT INTO slot_offers (\r\n                game_id,\r\n                player_id,\r\n                status,\r\n                offered_at,\r\n                expires_at,\r\n                available_at,\r\n                rank\r\n            )\r\n            SELECT \r\n                v_slot_offer.game_id,\r\n                player_id,\r\n                'pending'::slot_offer_status,\r\n                NOW(),\r\n                NOW() + INTERVAL '1 hour',\r\n                NOW(),\r\n                COALESCE(v_slot_offer.rank, 1) + ROW_NUMBER() OVER ()\r\n            FROM unnest(v_next_players) AS player_id;\r\n\r\n            -- Create notifications for new offers\r\n            INSERT INTO notifications (\r\n                player_id,\r\n                type,\r\n                message,\r\n                metadata\r\n            )\r\n            SELECT \r\n                player_id,\r\n                'slot_offer',\r\n                'A spot has opened up in game #' || v_game.game_number || '. Would you like to play?',\r\n                jsonb_build_object(\r\n                    'game_id', v_slot_offer.game_id,\r\n                    'action', 'new_slot_offer'\r\n                )\r\n            FROM unnest(v_next_players) AS player_id;\r\n        END IF;\r\n    END IF;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": true
  },
  {
    "function_name": "handle_game_completion_reserve_xp",
    "function_definition": "CREATE OR REPLACE FUNCTION public.handle_game_completion_reserve_xp()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- Only process if the game is being marked as completed\r\n    IF NEW.completed = true AND (OLD.completed = false OR OLD.completed IS NULL) THEN\r\n        -- Insert reserve rewards for eligible players\r\n        INSERT INTO reserve_xp_transactions (\r\n            player_id,\r\n            game_id,\r\n            xp_amount,\r\n            transaction_type\r\n        )\r\n        SELECT \r\n            (rp->>'id')::uuid as player_id,\r\n            NEW.id as game_id,\r\n            5 as xp_amount,\r\n            'RESERVE_REWARD' as transaction_type  -- Changed from RESERVE_BONUS to RESERVE_REWARD\r\n        FROM game_selections gs\r\n        CROSS JOIN jsonb_array_elements(gs.reserve_players) as rp\r\n        JOIN game_registrations gr ON gr.game_id = NEW.id AND gr.player_id = (rp->>'id')::uuid\r\n        WHERE gs.game_id = NEW.id\r\n        AND gr.status = 'reserve'\r\n        AND NOT EXISTS (\r\n            SELECT 1 \r\n            FROM reserve_xp_transactions rt \r\n            WHERE rt.player_id = (rp->>'id')::uuid\r\n            AND rt.game_id = NEW.id\r\n        );\r\n\r\n        -- Update player XP for all affected players\r\n        UPDATE player_xp px\r\n        SET \r\n            xp = calculate_player_xp(px.player_id),\r\n            last_calculated = CURRENT_TIMESTAMP\r\n        FROM game_selections gs\r\n        CROSS JOIN jsonb_array_elements(gs.reserve_players) as rp\r\n        WHERE gs.game_id = NEW.id\r\n        AND (rp->>'id')::uuid = px.player_id;\r\n    END IF;\r\n\r\n    RETURN NEW;\r\nEND;\r\n$function$\n",
    "function_description": "Trigger function that awards +5 XP to reserve players when a game is completed.",
    "return_type": "trigger",
    "source_code": "\r\nBEGIN\r\n    -- Only process if the game is being marked as completed\r\n    IF NEW.completed = true AND (OLD.completed = false OR OLD.completed IS NULL) THEN\r\n        -- Insert reserve rewards for eligible players\r\n        INSERT INTO reserve_xp_transactions (\r\n            player_id,\r\n            game_id,\r\n            xp_amount,\r\n            transaction_type\r\n        )\r\n        SELECT \r\n            (rp->>'id')::uuid as player_id,\r\n            NEW.id as game_id,\r\n            5 as xp_amount,\r\n            'RESERVE_REWARD' as transaction_type  -- Changed from RESERVE_BONUS to RESERVE_REWARD\r\n        FROM game_selections gs\r\n        CROSS JOIN jsonb_array_elements(gs.reserve_players) as rp\r\n        JOIN game_registrations gr ON gr.game_id = NEW.id AND gr.player_id = (rp->>'id')::uuid\r\n        WHERE gs.game_id = NEW.id\r\n        AND gr.status = 'reserve'\r\n        AND NOT EXISTS (\r\n            SELECT 1 \r\n            FROM reserve_xp_transactions rt \r\n            WHERE rt.player_id = (rp->>'id')::uuid\r\n            AND rt.game_id = NEW.id\r\n        );\r\n\r\n        -- Update player XP for all affected players\r\n        UPDATE player_xp px\r\n        SET \r\n            xp = calculate_player_xp(px.player_id),\r\n            last_calculated = CURRENT_TIMESTAMP\r\n        FROM game_selections gs\r\n        CROSS JOIN jsonb_array_elements(gs.reserve_players) as rp\r\n        WHERE gs.game_id = NEW.id\r\n        AND (rp->>'id')::uuid = px.player_id;\r\n    END IF;\r\n\r\n    RETURN NEW;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "handle_game_deletion",
    "function_definition": "CREATE OR REPLACE FUNCTION public.handle_game_deletion()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- Recalculate attendance streaks\r\n    WITH player_streaks AS (\r\n        SELECT \r\n            p.id as player_id,\r\n            COALESCE(\r\n                (\r\n                    SELECT COUNT(*)\r\n                    FROM game_registrations gr\r\n                    JOIN games g ON g.id = gr.game_id\r\n                    WHERE gr.player_id = p.id\r\n                    AND gr.status = 'selected'\r\n                    AND g.completed = true\r\n                    AND g.date >= (\r\n                        SELECT MAX(g2.date)\r\n                        FROM game_registrations gr2\r\n                        JOIN games g2 ON g2.id = gr2.game_id\r\n                        WHERE gr2.player_id = p.id\r\n                        AND (gr2.status != 'selected' OR NOT g2.completed)\r\n                        AND g2.date < NOW()\r\n                    )\r\n                ), 0\r\n            ) as streak\r\n        FROM players p\r\n    )\r\n    UPDATE players p\r\n    SET current_streak = ps.streak\r\n    FROM player_streaks ps\r\n    WHERE p.id = ps.player_id;\r\n\r\n    -- Recalculate bench warmer streaks\r\n    WITH bench_streaks AS (\r\n        SELECT \r\n            p.id as player_id,\r\n            COALESCE(\r\n                (\r\n                    SELECT COUNT(*)\r\n                    FROM game_registrations gr\r\n                    JOIN games g ON g.id = gr.game_id\r\n                    WHERE gr.player_id = p.id\r\n                    AND gr.status = 'reserve'\r\n                    AND g.completed = true\r\n                    AND g.date >= (\r\n                        SELECT MAX(g2.date)\r\n                        FROM game_registrations gr2\r\n                        JOIN games g2 ON g2.id = gr2.game_id\r\n                        WHERE gr2.player_id = p.id\r\n                        AND (gr2.status != 'reserve' OR NOT g2.completed)\r\n                        AND g2.date < NOW()\r\n                    )\r\n                ), 0\r\n            ) as streak\r\n        FROM players p\r\n    )\r\n    UPDATE players p\r\n    SET bench_warmer_streak = bs.streak\r\n    FROM bench_streaks bs\r\n    WHERE p.id = bs.player_id;\r\n\r\n    RETURN OLD;\r\nEND;\r\n$function$\n",
    "function_description": "Handles cleanup when a game is deleted:\r\n1. Deletes all reserve XP transactions for the game\r\n2. Recalculates XP for all affected players (both those with reserve XP and those who were registered)",
    "return_type": "trigger",
    "source_code": "\r\nBEGIN\r\n    -- Recalculate attendance streaks\r\n    WITH player_streaks AS (\r\n        SELECT \r\n            p.id as player_id,\r\n            COALESCE(\r\n                (\r\n                    SELECT COUNT(*)\r\n                    FROM game_registrations gr\r\n                    JOIN games g ON g.id = gr.game_id\r\n                    WHERE gr.player_id = p.id\r\n                    AND gr.status = 'selected'\r\n                    AND g.completed = true\r\n                    AND g.date >= (\r\n                        SELECT MAX(g2.date)\r\n                        FROM game_registrations gr2\r\n                        JOIN games g2 ON g2.id = gr2.game_id\r\n                        WHERE gr2.player_id = p.id\r\n                        AND (gr2.status != 'selected' OR NOT g2.completed)\r\n                        AND g2.date < NOW()\r\n                    )\r\n                ), 0\r\n            ) as streak\r\n        FROM players p\r\n    )\r\n    UPDATE players p\r\n    SET current_streak = ps.streak\r\n    FROM player_streaks ps\r\n    WHERE p.id = ps.player_id;\r\n\r\n    -- Recalculate bench warmer streaks\r\n    WITH bench_streaks AS (\r\n        SELECT \r\n            p.id as player_id,\r\n            COALESCE(\r\n                (\r\n                    SELECT COUNT(*)\r\n                    FROM game_registrations gr\r\n                    JOIN games g ON g.id = gr.game_id\r\n                    WHERE gr.player_id = p.id\r\n                    AND gr.status = 'reserve'\r\n                    AND g.completed = true\r\n                    AND g.date >= (\r\n                        SELECT MAX(g2.date)\r\n                        FROM game_registrations gr2\r\n                        JOIN games g2 ON g2.id = gr2.game_id\r\n                        WHERE gr2.player_id = p.id\r\n                        AND (gr2.status != 'reserve' OR NOT g2.completed)\r\n                        AND g2.date < NOW()\r\n                    )\r\n                ), 0\r\n            ) as streak\r\n        FROM players p\r\n    )\r\n    UPDATE players p\r\n    SET bench_warmer_streak = bs.streak\r\n    FROM bench_streaks bs\r\n    WHERE p.id = bs.player_id;\r\n\r\n    RETURN OLD;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "handle_game_deletion_xp",
    "function_definition": "CREATE OR REPLACE FUNCTION public.handle_game_deletion_xp()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    affected_player_id uuid;\r\nBEGIN\r\n    -- Store the affected player IDs before the game is deleted\r\n    FOR affected_player_id IN \r\n        SELECT DISTINCT player_id \r\n        FROM game_registrations \r\n        WHERE game_id = OLD.id\r\n    LOOP\r\n        -- Update player_xp table using the same pattern as other triggers\r\n        INSERT INTO player_xp (player_id, xp, last_calculated)\r\n        VALUES (\r\n            affected_player_id,\r\n            calculate_player_xp(affected_player_id),\r\n            CURRENT_TIMESTAMP\r\n        )\r\n        ON CONFLICT (player_id) \r\n        DO UPDATE SET \r\n            xp = EXCLUDED.xp,\r\n            last_calculated = EXCLUDED.last_calculated;\r\n    END LOOP;\r\n    \r\n    RETURN OLD;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "trigger",
    "source_code": "\r\nDECLARE\r\n    affected_player_id uuid;\r\nBEGIN\r\n    -- Store the affected player IDs before the game is deleted\r\n    FOR affected_player_id IN \r\n        SELECT DISTINCT player_id \r\n        FROM game_registrations \r\n        WHERE game_id = OLD.id\r\n    LOOP\r\n        -- Update player_xp table using the same pattern as other triggers\r\n        INSERT INTO player_xp (player_id, xp, last_calculated)\r\n        VALUES (\r\n            affected_player_id,\r\n            calculate_player_xp(affected_player_id),\r\n            CURRENT_TIMESTAMP\r\n        )\r\n        ON CONFLICT (player_id) \r\n        DO UPDATE SET \r\n            xp = EXCLUDED.xp,\r\n            last_calculated = EXCLUDED.last_calculated;\r\n    END LOOP;\r\n    \r\n    RETURN OLD;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "handle_game_registration_xp",
    "function_definition": "CREATE OR REPLACE FUNCTION public.handle_game_registration_xp()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- Update player XP using the calculate_player_xp function\r\n    INSERT INTO player_xp (player_id, xp, last_calculated)\r\n    VALUES (\r\n        NEW.player_id, \r\n        calculate_player_xp(NEW.player_id), \r\n        CURRENT_TIMESTAMP\r\n    )\r\n    ON CONFLICT (player_id) \r\n    DO UPDATE SET \r\n        xp = EXCLUDED.xp,\r\n        last_calculated = EXCLUDED.last_calculated;\r\n\r\n    RETURN NEW;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "trigger",
    "source_code": "\r\nBEGIN\r\n    -- Update player XP using the calculate_player_xp function\r\n    INSERT INTO player_xp (player_id, xp, last_calculated)\r\n    VALUES (\r\n        NEW.player_id, \r\n        calculate_player_xp(NEW.player_id), \r\n        CURRENT_TIMESTAMP\r\n    )\r\n    ON CONFLICT (player_id) \r\n    DO UPDATE SET \r\n        xp = EXCLUDED.xp,\r\n        last_calculated = EXCLUDED.last_calculated;\r\n\r\n    RETURN NEW;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "handle_registration_close",
    "function_definition": "CREATE OR REPLACE FUNCTION public.handle_registration_close(input_game_id uuid)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    total_slots INTEGER;\r\n    random_slots INTEGER;\r\n    xp_slots INTEGER;\r\nBEGIN\r\n    -- Get game details\r\n    SELECT max_players, random_slots INTO total_slots, random_slots\r\n    FROM games\r\n    WHERE id = input_game_id;\r\n    \r\n    -- Calculate XP-based slots\r\n    xp_slots := total_slots - random_slots;\r\n    \r\n    -- Update game status\r\n    UPDATE games \r\n    SET status = 'registration_closed'\r\n    WHERE id = input_game_id;\r\n    \r\n    -- Select players by XP (for xp_slots)\r\n    WITH xp_selections AS (\r\n        SELECT gr.id\r\n        FROM game_registrations gr\r\n        JOIN players p ON gr.player_id = p.id\r\n        WHERE gr.game_id = input_game_id\r\n        ORDER BY p.xp DESC\r\n        LIMIT xp_slots\r\n    ),\r\n    -- Select remaining players randomly (for random_slots)\r\n    random_selections AS (\r\n        SELECT gr.id\r\n        FROM game_registrations gr\r\n        WHERE gr.game_id = input_game_id\r\n        AND gr.id NOT IN (SELECT id FROM xp_selections)\r\n        ORDER BY random()\r\n        LIMIT random_slots\r\n    )\r\n    -- Update selected players' status\r\n    UPDATE game_registrations\r\n    SET status = \r\n        CASE \r\n            WHEN id IN (SELECT id FROM xp_selections) OR \r\n                 id IN (SELECT id FROM random_selections)\r\n            THEN 'selected'\r\n            ELSE 'reserve'\r\n        END\r\n    WHERE game_id = input_game_id;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "void",
    "source_code": "\r\nDECLARE\r\n    total_slots INTEGER;\r\n    random_slots INTEGER;\r\n    xp_slots INTEGER;\r\nBEGIN\r\n    -- Get game details\r\n    SELECT max_players, random_slots INTO total_slots, random_slots\r\n    FROM games\r\n    WHERE id = input_game_id;\r\n    \r\n    -- Calculate XP-based slots\r\n    xp_slots := total_slots - random_slots;\r\n    \r\n    -- Update game status\r\n    UPDATE games \r\n    SET status = 'registration_closed'\r\n    WHERE id = input_game_id;\r\n    \r\n    -- Select players by XP (for xp_slots)\r\n    WITH xp_selections AS (\r\n        SELECT gr.id\r\n        FROM game_registrations gr\r\n        JOIN players p ON gr.player_id = p.id\r\n        WHERE gr.game_id = input_game_id\r\n        ORDER BY p.xp DESC\r\n        LIMIT xp_slots\r\n    ),\r\n    -- Select remaining players randomly (for random_slots)\r\n    random_selections AS (\r\n        SELECT gr.id\r\n        FROM game_registrations gr\r\n        WHERE gr.game_id = input_game_id\r\n        AND gr.id NOT IN (SELECT id FROM xp_selections)\r\n        ORDER BY random()\r\n        LIMIT random_slots\r\n    )\r\n    -- Update selected players' status\r\n    UPDATE game_registrations\r\n    SET status = \r\n        CASE \r\n            WHEN id IN (SELECT id FROM xp_selections) OR \r\n                 id IN (SELECT id FROM random_selections)\r\n            THEN 'selected'\r\n            ELSE 'reserve'\r\n        END\r\n    WHERE game_id = input_game_id;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "handle_reserve_xp_transaction",
    "function_definition": "CREATE OR REPLACE FUNCTION public.handle_reserve_xp_transaction()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- Update player XP using the calculate_player_xp function\r\n    UPDATE player_xp\r\n    SET \r\n        xp = calculate_player_xp(NEW.player_id),\r\n        last_calculated = CURRENT_TIMESTAMP\r\n    WHERE player_id = NEW.player_id;\r\n    \r\n    RETURN NEW;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "trigger",
    "source_code": "\r\nBEGIN\r\n    -- Update player XP using the calculate_player_xp function\r\n    UPDATE player_xp\r\n    SET \r\n        xp = calculate_player_xp(NEW.player_id),\r\n        last_calculated = CURRENT_TIMESTAMP\r\n    WHERE player_id = NEW.player_id;\r\n    \r\n    RETURN NEW;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "handle_slot_decline_penalty",
    "function_definition": "CREATE OR REPLACE FUNCTION public.handle_slot_decline_penalty()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- Only process if the slot offer is being declined\r\n    IF NEW.status = 'declined' AND OLD.status != 'declined' THEN\r\n        -- Check if the offer was made on the same day as the game\r\n        IF NOT EXISTS (\r\n            SELECT 1 \r\n            FROM games g \r\n            WHERE g.id = NEW.game_id \r\n            AND DATE(g.date) = DATE(NEW.created_at)\r\n        ) THEN\r\n            -- Insert penalty transaction\r\n            INSERT INTO reserve_xp_transactions (\r\n                player_id,\r\n                game_id,\r\n                xp_amount,\r\n                transaction_type\r\n            )\r\n            VALUES (\r\n                NEW.player_id,\r\n                NEW.game_id,\r\n                -10,\r\n                'SLOT_DECLINE_PENALTY'\r\n            );\r\n\r\n            -- Update player XP\r\n            UPDATE player_xp\r\n            SET \r\n                xp = calculate_player_xp(player_id),\r\n                last_calculated = CURRENT_TIMESTAMP\r\n            WHERE player_id = NEW.player_id;\r\n        END IF;\r\n    END IF;\r\n\r\n    RETURN NEW;\r\nEND;\r\n$function$\n",
    "function_description": "Trigger function that applies -10 XP penalty when a player declines a slot offer, \r\nunless the offer was made on the same day as the game.",
    "return_type": "trigger",
    "source_code": "\r\nBEGIN\r\n    -- Only process if the slot offer is being declined\r\n    IF NEW.status = 'declined' AND OLD.status != 'declined' THEN\r\n        -- Check if the offer was made on the same day as the game\r\n        IF NOT EXISTS (\r\n            SELECT 1 \r\n            FROM games g \r\n            WHERE g.id = NEW.game_id \r\n            AND DATE(g.date) = DATE(NEW.created_at)\r\n        ) THEN\r\n            -- Insert penalty transaction\r\n            INSERT INTO reserve_xp_transactions (\r\n                player_id,\r\n                game_id,\r\n                xp_amount,\r\n                transaction_type\r\n            )\r\n            VALUES (\r\n                NEW.player_id,\r\n                NEW.game_id,\r\n                -10,\r\n                'SLOT_DECLINE_PENALTY'\r\n            );\r\n\r\n            -- Update player XP\r\n            UPDATE player_xp\r\n            SET \r\n                xp = calculate_player_xp(player_id),\r\n                last_calculated = CURRENT_TIMESTAMP\r\n            WHERE player_id = NEW.player_id;\r\n        END IF;\r\n    END IF;\r\n\r\n    RETURN NEW;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "handle_slot_offer_acceptance",
    "function_definition": "CREATE OR REPLACE FUNCTION public.handle_slot_offer_acceptance()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    IF NEW.status = 'accepted' AND OLD.status != 'accepted' THEN\r\n        -- Update the game registration status\r\n        UPDATE game_registrations\r\n        SET \r\n            status = 'selected',\r\n            selection_method = 'slot_offer'  -- Using the correct allowed value\r\n        WHERE game_id = NEW.game_id\r\n        AND player_id = NEW.player_id;\r\n    END IF;\r\n    RETURN NEW;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "trigger",
    "source_code": "\r\nBEGIN\r\n    IF NEW.status = 'accepted' AND OLD.status != 'accepted' THEN\r\n        -- Update the game registration status\r\n        UPDATE game_registrations\r\n        SET \r\n            status = 'selected',\r\n            selection_method = 'slot_offer'  -- Using the correct allowed value\r\n        WHERE game_id = NEW.game_id\r\n        AND player_id = NEW.player_id;\r\n    END IF;\r\n    RETURN NEW;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "handle_slot_offer_response",
    "function_definition": "CREATE OR REPLACE FUNCTION public.handle_slot_offer_response(p_slot_offer_id uuid, p_action text, p_admin_id uuid DEFAULT NULL::uuid)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_slot_offer record;\r\n    v_game record;\r\n    v_current_players jsonb;\r\n    v_next_players UUID[];\r\n    v_hours_until_game NUMERIC;\r\nBEGIN\r\n    -- Get slot offer details\r\n    SELECT * INTO v_slot_offer\r\n    FROM slot_offers\r\n    WHERE id = p_slot_offer_id;\r\n\r\n    IF NOT FOUND THEN\r\n        RAISE EXCEPTION 'Slot offer not found';\r\n    END IF;\r\n\r\n    -- Get game details including current selected players\r\n    SELECT g.*, gs.selected_players, \r\n           EXTRACT(EPOCH FROM (g.date - NOW())) / 3600 as hours_until_game\r\n    INTO v_game\r\n    FROM games g\r\n    LEFT JOIN game_selections gs ON gs.game_id = g.id\r\n    WHERE g.id = v_slot_offer.game_id;\r\n\r\n    IF p_action = 'accept' THEN\r\n        -- Update or insert game_selections with the new player\r\n        INSERT INTO game_selections (\r\n            game_id,\r\n            selected_players,\r\n            reserve_players\r\n        )\r\n        VALUES (\r\n            v_slot_offer.game_id,\r\n            COALESCE(v_game.selected_players, '[]'::jsonb) || jsonb_build_array(v_slot_offer.player_id::text),\r\n            '[]'::jsonb\r\n        )\r\n        ON CONFLICT (game_id) DO UPDATE\r\n        SET selected_players = COALESCE(game_selections.selected_players, '[]'::jsonb) || jsonb_build_array(v_slot_offer.player_id::text);\r\n\r\n        -- Update game registration status\r\n        UPDATE game_registrations\r\n        SET status = 'selected'\r\n        WHERE game_id = v_slot_offer.game_id\r\n        AND player_id = v_slot_offer.player_id;\r\n\r\n        -- Update slot offer status\r\n        UPDATE slot_offers\r\n        SET \r\n            status = 'accepted',\r\n            responded_at = CURRENT_TIMESTAMP,\r\n            accepted_at = CURRENT_TIMESTAMP\r\n        WHERE id = p_slot_offer_id;\r\n\r\n    ELSIF p_action = 'decline' THEN\r\n        -- Rest of the decline logic remains the same...\r\n        -- [Previous decline logic here]\r\n    END IF;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "void",
    "source_code": "\r\nDECLARE\r\n    v_slot_offer record;\r\n    v_game record;\r\n    v_current_players jsonb;\r\n    v_next_players UUID[];\r\n    v_hours_until_game NUMERIC;\r\nBEGIN\r\n    -- Get slot offer details\r\n    SELECT * INTO v_slot_offer\r\n    FROM slot_offers\r\n    WHERE id = p_slot_offer_id;\r\n\r\n    IF NOT FOUND THEN\r\n        RAISE EXCEPTION 'Slot offer not found';\r\n    END IF;\r\n\r\n    -- Get game details including current selected players\r\n    SELECT g.*, gs.selected_players, \r\n           EXTRACT(EPOCH FROM (g.date - NOW())) / 3600 as hours_until_game\r\n    INTO v_game\r\n    FROM games g\r\n    LEFT JOIN game_selections gs ON gs.game_id = g.id\r\n    WHERE g.id = v_slot_offer.game_id;\r\n\r\n    IF p_action = 'accept' THEN\r\n        -- Update or insert game_selections with the new player\r\n        INSERT INTO game_selections (\r\n            game_id,\r\n            selected_players,\r\n            reserve_players\r\n        )\r\n        VALUES (\r\n            v_slot_offer.game_id,\r\n            COALESCE(v_game.selected_players, '[]'::jsonb) || jsonb_build_array(v_slot_offer.player_id::text),\r\n            '[]'::jsonb\r\n        )\r\n        ON CONFLICT (game_id) DO UPDATE\r\n        SET selected_players = COALESCE(game_selections.selected_players, '[]'::jsonb) || jsonb_build_array(v_slot_offer.player_id::text);\r\n\r\n        -- Update game registration status\r\n        UPDATE game_registrations\r\n        SET status = 'selected'\r\n        WHERE game_id = v_slot_offer.game_id\r\n        AND player_id = v_slot_offer.player_id;\r\n\r\n        -- Update slot offer status\r\n        UPDATE slot_offers\r\n        SET \r\n            status = 'accepted',\r\n            responded_at = CURRENT_TIMESTAMP,\r\n            accepted_at = CURRENT_TIMESTAMP\r\n        WHERE id = p_slot_offer_id;\r\n\r\n    ELSIF p_action = 'decline' THEN\r\n        -- Rest of the decline logic remains the same...\r\n        -- [Previous decline logic here]\r\n    END IF;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "handle_slot_offer_response",
    "function_definition": "CREATE OR REPLACE FUNCTION public.handle_slot_offer_response()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_game record;\r\n    v_selected_count integer;\r\n    v_dropped_count integer;\r\n    v_active_selected integer;\r\n    v_current_selected_players jsonb;\r\nBEGIN\r\n    -- Only handle status changes\r\n    IF NEW.status = OLD.status THEN\r\n        RETURN NEW;\r\n    END IF;\r\n\r\n    -- Log the start of processing\r\n    INSERT INTO debug_logs (event_type, message, details)\r\n    VALUES (\r\n        'slot_offer_response',\r\n        'Processing slot offer response',\r\n        jsonb_build_object(\r\n            'old_status', OLD.status,\r\n            'new_status', NEW.status,\r\n            'game_id', NEW.game_id,\r\n            'player_id', NEW.player_id\r\n        )\r\n    );\r\n\r\n    -- Get current counts and game date\r\n    SELECT \r\n        g.*,\r\n        COUNT(*) FILTER (WHERE gr.status = 'selected') as selected_count,\r\n        COUNT(*) FILTER (WHERE gr.status = 'dropped_out') as dropped_count\r\n    INTO v_game\r\n    FROM games g\r\n    LEFT JOIN game_registrations gr ON gr.game_id = g.id\r\n    WHERE g.id = NEW.game_id\r\n    GROUP BY g.id;\r\n\r\n    -- Calculate active selected players\r\n    v_active_selected := v_game.selected_count - v_game.dropped_count;\r\n\r\n    -- Handle accepted status\r\n    IF NEW.status = 'accepted' THEN\r\n        -- First check if game_selections record exists\r\n        IF NOT EXISTS (SELECT 1 FROM game_selections WHERE game_id = NEW.game_id) THEN\r\n            -- Create new record if it doesn't exist\r\n            INSERT INTO game_selections (\r\n                game_id,\r\n                selected_players,\r\n                reserve_players,\r\n                selection_metadata\r\n            )\r\n            VALUES (\r\n                NEW.game_id,\r\n                jsonb_build_array(NEW.player_id::text),\r\n                '[]'::jsonb,\r\n                '{}'::jsonb\r\n            );\r\n        ELSE\r\n            -- Update existing record\r\n            UPDATE game_selections\r\n            SET selected_players = (\r\n                CASE \r\n                    WHEN selected_players IS NULL THEN jsonb_build_array(NEW.player_id::text)\r\n                    ELSE selected_players || jsonb_build_array(NEW.player_id::text)\r\n                END\r\n            )\r\n            WHERE game_id = NEW.game_id;\r\n        END IF;\r\n\r\n        -- Update game registration\r\n        UPDATE game_registrations\r\n        SET status = 'selected'\r\n        WHERE game_id = NEW.game_id\r\n        AND player_id = NEW.player_id;\r\n\r\n        NEW.responded_at := NOW();\r\n        NEW.accepted_at := NOW();\r\n    ELSIF NEW.status IN ('declined', 'expired', 'voided') THEN\r\n        NEW.responded_at := NOW();\r\n        NEW.declined_at := CASE WHEN NEW.status = 'declined' THEN NOW() ELSE NULL END;\r\n    END IF;\r\n\r\n    -- Log game stats\r\n    INSERT INTO debug_logs (event_type, message, details)\r\n    VALUES (\r\n        'game_stats',\r\n        'Game statistics',\r\n        jsonb_build_object(\r\n            'game_id', NEW.game_id,\r\n            'max_players', v_game.max_players,\r\n            'selected_count', v_game.selected_count,\r\n            'dropped_count', v_game.dropped_count,\r\n            'active_selected', v_active_selected\r\n        )\r\n    );\r\n\r\n    RETURN NEW;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "trigger",
    "source_code": "\r\nDECLARE\r\n    v_game record;\r\n    v_selected_count integer;\r\n    v_dropped_count integer;\r\n    v_active_selected integer;\r\n    v_current_selected_players jsonb;\r\nBEGIN\r\n    -- Only handle status changes\r\n    IF NEW.status = OLD.status THEN\r\n        RETURN NEW;\r\n    END IF;\r\n\r\n    -- Log the start of processing\r\n    INSERT INTO debug_logs (event_type, message, details)\r\n    VALUES (\r\n        'slot_offer_response',\r\n        'Processing slot offer response',\r\n        jsonb_build_object(\r\n            'old_status', OLD.status,\r\n            'new_status', NEW.status,\r\n            'game_id', NEW.game_id,\r\n            'player_id', NEW.player_id\r\n        )\r\n    );\r\n\r\n    -- Get current counts and game date\r\n    SELECT \r\n        g.*,\r\n        COUNT(*) FILTER (WHERE gr.status = 'selected') as selected_count,\r\n        COUNT(*) FILTER (WHERE gr.status = 'dropped_out') as dropped_count\r\n    INTO v_game\r\n    FROM games g\r\n    LEFT JOIN game_registrations gr ON gr.game_id = g.id\r\n    WHERE g.id = NEW.game_id\r\n    GROUP BY g.id;\r\n\r\n    -- Calculate active selected players\r\n    v_active_selected := v_game.selected_count - v_game.dropped_count;\r\n\r\n    -- Handle accepted status\r\n    IF NEW.status = 'accepted' THEN\r\n        -- First check if game_selections record exists\r\n        IF NOT EXISTS (SELECT 1 FROM game_selections WHERE game_id = NEW.game_id) THEN\r\n            -- Create new record if it doesn't exist\r\n            INSERT INTO game_selections (\r\n                game_id,\r\n                selected_players,\r\n                reserve_players,\r\n                selection_metadata\r\n            )\r\n            VALUES (\r\n                NEW.game_id,\r\n                jsonb_build_array(NEW.player_id::text),\r\n                '[]'::jsonb,\r\n                '{}'::jsonb\r\n            );\r\n        ELSE\r\n            -- Update existing record\r\n            UPDATE game_selections\r\n            SET selected_players = (\r\n                CASE \r\n                    WHEN selected_players IS NULL THEN jsonb_build_array(NEW.player_id::text)\r\n                    ELSE selected_players || jsonb_build_array(NEW.player_id::text)\r\n                END\r\n            )\r\n            WHERE game_id = NEW.game_id;\r\n        END IF;\r\n\r\n        -- Update game registration\r\n        UPDATE game_registrations\r\n        SET status = 'selected'\r\n        WHERE game_id = NEW.game_id\r\n        AND player_id = NEW.player_id;\r\n\r\n        NEW.responded_at := NOW();\r\n        NEW.accepted_at := NOW();\r\n    ELSIF NEW.status IN ('declined', 'expired', 'voided') THEN\r\n        NEW.responded_at := NOW();\r\n        NEW.declined_at := CASE WHEN NEW.status = 'declined' THEN NOW() ELSE NULL END;\r\n    END IF;\r\n\r\n    -- Log game stats\r\n    INSERT INTO debug_logs (event_type, message, details)\r\n    VALUES (\r\n        'game_stats',\r\n        'Game statistics',\r\n        jsonb_build_object(\r\n            'game_id', NEW.game_id,\r\n            'max_players', v_game.max_players,\r\n            'selected_count', v_game.selected_count,\r\n            'dropped_count', v_game.dropped_count,\r\n            'active_selected', v_active_selected\r\n        )\r\n    );\r\n\r\n    RETURN NEW;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "handle_slot_offer_response",
    "function_definition": "CREATE OR REPLACE FUNCTION public.handle_slot_offer_response(p_offer_id uuid, p_status slot_offer_status)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n  v_game_id UUID;\r\n  v_player_id UUID;\r\n  v_game_date TIMESTAMP WITH TIME ZONE;\r\n  v_game_number INTEGER;\r\n  v_hours_until_game NUMERIC;\r\n  v_next_players UUID[];\r\n  v_current_selected_players JSONB;\r\nBEGIN\r\n  -- Get the offer details\r\n  SELECT \r\n    game_id,\r\n    player_id,\r\n    g.date,\r\n    COUNT(g2.*) + 1,\r\n    EXTRACT(EPOCH FROM (g.date - NOW())) / 3600 \r\n    INTO v_game_id, v_player_id, v_game_date, v_game_number, v_hours_until_game\r\n  FROM slot_offers so\r\n  JOIN games g ON g.id = so.game_id\r\n  LEFT JOIN games g2 ON g2.date < g.date OR (g2.date = g.date AND g2.id < g.id)\r\n  WHERE so.id = p_offer_id\r\n  GROUP BY so.game_id, so.player_id, g.date;\r\n\r\n  IF p_status = 'accepted' THEN\r\n    -- Get current selected players from game_selections\r\n    SELECT COALESCE(selected_players, '[]'::jsonb)\r\n    INTO v_current_selected_players\r\n    FROM game_selections\r\n    WHERE game_id = v_game_id;\r\n\r\n    -- If no game_selections entry exists, create one\r\n    IF NOT FOUND THEN\r\n      INSERT INTO game_selections (game_id, selected_players)\r\n      VALUES (v_game_id, '[]'::jsonb)\r\n      RETURNING selected_players INTO v_current_selected_players;\r\n    END IF;\r\n\r\n    -- Add the new player to selected_players if not already present\r\n    IF NOT v_current_selected_players ? v_player_id::text THEN\r\n      UPDATE game_selections\r\n      SET selected_players = (\r\n        SELECT jsonb_agg(value)\r\n        FROM (\r\n          SELECT * FROM jsonb_array_elements(v_current_selected_players)\r\n          UNION ALL\r\n          SELECT to_jsonb(v_player_id::text)\r\n        ) t\r\n      )\r\n      WHERE game_id = v_game_id;\r\n    END IF;\r\n\r\n    -- Update game registration status\r\n    UPDATE game_registrations\r\n    SET status = 'selected'\r\n    WHERE game_id = v_game_id AND player_id = v_player_id;\r\n\r\n    -- Update other pending offers to voided\r\n    UPDATE slot_offers\r\n    SET \r\n      status = 'voided',\r\n      responded_at = NOW()\r\n    WHERE \r\n      game_id = v_game_id \r\n      AND id != p_offer_id \r\n      AND status = 'pending';\r\n\r\n  ELSIF p_status = 'declined' THEN\r\n    -- Get next eligible players\r\n    SELECT ARRAY(\r\n      SELECT player_id \r\n      FROM get_next_slot_offer_players(v_game_id, v_hours_until_game)\r\n      LIMIT 1\r\n    ) INTO v_next_players;\r\n\r\n    -- Create new offers for next eligible players\r\n    IF array_length(v_next_players, 1) > 0 THEN\r\n      INSERT INTO slot_offers (\r\n        game_id,\r\n        player_id,\r\n        status,\r\n        offered_at,\r\n        expires_at,\r\n        available_at\r\n      )\r\n      SELECT \r\n        v_game_id,\r\n        player_id,\r\n        'pending'::slot_offer_status,\r\n        NOW(),\r\n        NOW() + INTERVAL '1 hour',\r\n        NOW()\r\n      FROM unnest(v_next_players) AS player_id;\r\n    END IF;\r\n  END IF;\r\n\r\n  -- Update the slot offer status\r\n  UPDATE slot_offers\r\n  SET \r\n    status = p_status,\r\n    responded_at = NOW(),\r\n    accepted_at = CASE WHEN p_status = 'accepted' THEN NOW() ELSE NULL END,\r\n    declined_at = CASE WHEN p_status = 'declined' THEN NOW() ELSE NULL END\r\n  WHERE id = p_offer_id;\r\n\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "void",
    "source_code": "\r\nDECLARE\r\n  v_game_id UUID;\r\n  v_player_id UUID;\r\n  v_game_date TIMESTAMP WITH TIME ZONE;\r\n  v_game_number INTEGER;\r\n  v_hours_until_game NUMERIC;\r\n  v_next_players UUID[];\r\n  v_current_selected_players JSONB;\r\nBEGIN\r\n  -- Get the offer details\r\n  SELECT \r\n    game_id,\r\n    player_id,\r\n    g.date,\r\n    COUNT(g2.*) + 1,\r\n    EXTRACT(EPOCH FROM (g.date - NOW())) / 3600 \r\n    INTO v_game_id, v_player_id, v_game_date, v_game_number, v_hours_until_game\r\n  FROM slot_offers so\r\n  JOIN games g ON g.id = so.game_id\r\n  LEFT JOIN games g2 ON g2.date < g.date OR (g2.date = g.date AND g2.id < g.id)\r\n  WHERE so.id = p_offer_id\r\n  GROUP BY so.game_id, so.player_id, g.date;\r\n\r\n  IF p_status = 'accepted' THEN\r\n    -- Get current selected players from game_selections\r\n    SELECT COALESCE(selected_players, '[]'::jsonb)\r\n    INTO v_current_selected_players\r\n    FROM game_selections\r\n    WHERE game_id = v_game_id;\r\n\r\n    -- If no game_selections entry exists, create one\r\n    IF NOT FOUND THEN\r\n      INSERT INTO game_selections (game_id, selected_players)\r\n      VALUES (v_game_id, '[]'::jsonb)\r\n      RETURNING selected_players INTO v_current_selected_players;\r\n    END IF;\r\n\r\n    -- Add the new player to selected_players if not already present\r\n    IF NOT v_current_selected_players ? v_player_id::text THEN\r\n      UPDATE game_selections\r\n      SET selected_players = (\r\n        SELECT jsonb_agg(value)\r\n        FROM (\r\n          SELECT * FROM jsonb_array_elements(v_current_selected_players)\r\n          UNION ALL\r\n          SELECT to_jsonb(v_player_id::text)\r\n        ) t\r\n      )\r\n      WHERE game_id = v_game_id;\r\n    END IF;\r\n\r\n    -- Update game registration status\r\n    UPDATE game_registrations\r\n    SET status = 'selected'\r\n    WHERE game_id = v_game_id AND player_id = v_player_id;\r\n\r\n    -- Update other pending offers to voided\r\n    UPDATE slot_offers\r\n    SET \r\n      status = 'voided',\r\n      responded_at = NOW()\r\n    WHERE \r\n      game_id = v_game_id \r\n      AND id != p_offer_id \r\n      AND status = 'pending';\r\n\r\n  ELSIF p_status = 'declined' THEN\r\n    -- Get next eligible players\r\n    SELECT ARRAY(\r\n      SELECT player_id \r\n      FROM get_next_slot_offer_players(v_game_id, v_hours_until_game)\r\n      LIMIT 1\r\n    ) INTO v_next_players;\r\n\r\n    -- Create new offers for next eligible players\r\n    IF array_length(v_next_players, 1) > 0 THEN\r\n      INSERT INTO slot_offers (\r\n        game_id,\r\n        player_id,\r\n        status,\r\n        offered_at,\r\n        expires_at,\r\n        available_at\r\n      )\r\n      SELECT \r\n        v_game_id,\r\n        player_id,\r\n        'pending'::slot_offer_status,\r\n        NOW(),\r\n        NOW() + INTERVAL '1 hour',\r\n        NOW()\r\n      FROM unnest(v_next_players) AS player_id;\r\n    END IF;\r\n  END IF;\r\n\r\n  -- Update the slot offer status\r\n  UPDATE slot_offers\r\n  SET \r\n    status = p_status,\r\n    responded_at = NOW(),\r\n    accepted_at = CASE WHEN p_status = 'accepted' THEN NOW() ELSE NULL END,\r\n    declined_at = CASE WHEN p_status = 'declined' THEN NOW() ELSE NULL END\r\n  WHERE id = p_offer_id;\r\n\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": true
  },
  {
    "function_name": "handle_slot_offer_response",
    "function_definition": "CREATE OR REPLACE FUNCTION public.handle_slot_offer_response(p_offer_id uuid, p_status text)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n  v_game_id UUID;\r\n  v_player_id UUID;\r\nBEGIN\r\n  -- Get the offer details\r\n  SELECT game_id, player_id INTO v_game_id, v_player_id\r\n  FROM slot_offers\r\n  WHERE id = p_offer_id;\r\n\r\n  IF NOT FOUND THEN\r\n    RAISE EXCEPTION 'Slot offer not found';\r\n  END IF;\r\n\r\n  -- If accepting the offer\r\n  IF p_status = 'accepted' THEN\r\n    -- Update game registration to selected\r\n    UPDATE game_registrations\r\n    SET status = 'selected'\r\n    WHERE game_id = v_game_id\r\n    AND player_id = v_player_id;\r\n\r\n    -- Mark all other offers for this game as void\r\n    UPDATE slot_offers\r\n    SET status = 'void'\r\n    WHERE game_id = v_game_id\r\n    AND id != p_offer_id;\r\n\r\n    -- Create notifications for other players\r\n    INSERT INTO notifications (\r\n      player_id,\r\n      type,\r\n      message,\r\n      metadata,\r\n      created_at\r\n    )\r\n    SELECT \r\n      so.player_id,\r\n      'system_message',\r\n      'The slot you were offered has been filled by another player.',\r\n      jsonb_build_object(\r\n        'game_id', v_game_id,\r\n        'action', 'slot_filled'\r\n      ),\r\n      NOW()\r\n    FROM slot_offers so\r\n    WHERE so.game_id = v_game_id\r\n    AND so.id != p_offer_id\r\n    AND so.status = 'pending';\r\n  END IF;\r\n\r\n  -- Update the offer status\r\n  UPDATE slot_offers\r\n  SET \r\n    status = p_status,\r\n    responded_at = NOW()\r\n  WHERE id = p_offer_id;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "void",
    "source_code": "\r\nDECLARE\r\n  v_game_id UUID;\r\n  v_player_id UUID;\r\nBEGIN\r\n  -- Get the offer details\r\n  SELECT game_id, player_id INTO v_game_id, v_player_id\r\n  FROM slot_offers\r\n  WHERE id = p_offer_id;\r\n\r\n  IF NOT FOUND THEN\r\n    RAISE EXCEPTION 'Slot offer not found';\r\n  END IF;\r\n\r\n  -- If accepting the offer\r\n  IF p_status = 'accepted' THEN\r\n    -- Update game registration to selected\r\n    UPDATE game_registrations\r\n    SET status = 'selected'\r\n    WHERE game_id = v_game_id\r\n    AND player_id = v_player_id;\r\n\r\n    -- Mark all other offers for this game as void\r\n    UPDATE slot_offers\r\n    SET status = 'void'\r\n    WHERE game_id = v_game_id\r\n    AND id != p_offer_id;\r\n\r\n    -- Create notifications for other players\r\n    INSERT INTO notifications (\r\n      player_id,\r\n      type,\r\n      message,\r\n      metadata,\r\n      created_at\r\n    )\r\n    SELECT \r\n      so.player_id,\r\n      'system_message',\r\n      'The slot you were offered has been filled by another player.',\r\n      jsonb_build_object(\r\n        'game_id', v_game_id,\r\n        'action', 'slot_filled'\r\n      ),\r\n      NOW()\r\n    FROM slot_offers so\r\n    WHERE so.game_id = v_game_id\r\n    AND so.id != p_offer_id\r\n    AND so.status = 'pending';\r\n  END IF;\r\n\r\n  -- Update the offer status\r\n  UPDATE slot_offers\r\n  SET \r\n    status = p_status,\r\n    responded_at = NOW()\r\n  WHERE id = p_offer_id;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": true
  },
  {
    "function_name": "handle_slot_offer_response_text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.handle_slot_offer_response_text(p_offer_id uuid, p_status text)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n  RAISE NOTICE 'Text version called with status: %', p_status;\r\n  -- Call the main function with the converted enum\r\n  PERFORM handle_slot_offer_response(p_offer_id, p_status::slot_offer_status);\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "void",
    "source_code": "\r\nBEGIN\r\n  RAISE NOTICE 'Text version called with status: %', p_status;\r\n  -- Call the main function with the converted enum\r\n  PERFORM handle_slot_offer_response(p_offer_id, p_status::slot_offer_status);\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": true
  },
  {
    "function_name": "handle_slot_offer_response_text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.handle_slot_offer_response_text(p_game_id uuid, p_player_id uuid, p_response text)\n RETURNS text\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n  v_current_offer_id UUID;\r\n  v_current_offer_status TEXT;\r\n  v_message TEXT;\r\nBEGIN\r\n  -- Get the current offer status\r\n  SELECT id, status INTO v_current_offer_id, v_current_offer_status\r\n  FROM slot_offers\r\n  WHERE game_id = p_game_id \r\n  AND player_id = p_player_id \r\n  AND status = 'pending'\r\n  ORDER BY created_at DESC\r\n  LIMIT 1;\r\n\r\n  -- If no pending offer exists, return error\r\n  IF v_current_offer_id IS NULL THEN\r\n    RETURN 'No pending offer found';\r\n  END IF;\r\n\r\n  -- Update the current offer based on response\r\n  UPDATE slot_offers\r\n  SET \r\n    status = CASE \r\n      WHEN p_response = 'accept' THEN 'accepted'\r\n      WHEN p_response = 'decline' THEN 'declined'\r\n      ELSE status\r\n    END,\r\n    responded_at = NOW()\r\n  WHERE id = v_current_offer_id;\r\n\r\n  -- If offer was declined, create offers for next eligible players\r\n  IF p_response = 'decline' THEN\r\n    -- Update game registration to mark as declined\r\n    UPDATE game_registrations\r\n    SET has_declined = true\r\n    WHERE game_id = p_game_id AND player_id = p_player_id;\r\n\r\n    -- Call create_slot_offers to generate new offers\r\n    PERFORM create_slot_offers(p_game_id);\r\n    \r\n    v_message := 'Offer declined. New offers will be created for eligible players.';\r\n  ELSIF p_response = 'accept' THEN\r\n    -- Update game registration status\r\n    UPDATE game_registrations \r\n    SET status = 'confirmed'\r\n    WHERE game_id = p_game_id AND player_id = p_player_id;\r\n\r\n    -- Update any other pending offers to expired\r\n    UPDATE slot_offers\r\n    SET status = 'expired'\r\n    WHERE game_id = p_game_id \r\n    AND status = 'pending'\r\n    AND player_id != p_player_id;\r\n\r\n    v_message := 'Offer accepted. Your spot has been confirmed.';\r\n  END IF;\r\n\r\n  -- Send notification to admins about the response\r\n  INSERT INTO notifications (\r\n    player_id,\r\n    type,\r\n    message,\r\n    metadata\r\n  )\r\n  SELECT DISTINCT\r\n    ar.player_id,\r\n    'system_message',\r\n    CASE \r\n      WHEN p_response = 'accept' THEN \r\n        (SELECT username FROM players WHERE id = p_player_id) || ' has accepted a slot offer for WNF #' || \r\n        (SELECT COUNT(*) + 1 \r\n         FROM games g2 \r\n         WHERE g2.date < (SELECT date FROM games WHERE id = p_game_id) \r\n         OR (g2.date = (SELECT date FROM games WHERE id = p_game_id) AND g2.id < p_game_id))\r\n      WHEN p_response = 'decline' THEN \r\n        (SELECT username FROM players WHERE id = p_player_id) || ' has declined a slot offer for WNF #' ||\r\n        (SELECT COUNT(*) + 1 \r\n         FROM games g2 \r\n         WHERE g2.date < (SELECT date FROM games WHERE id = p_game_id) \r\n         OR (g2.date = (SELECT date FROM games WHERE id = p_game_id) AND g2.id < p_game_id))\r\n    END,\r\n    jsonb_build_object(\r\n      'game_id', p_game_id,\r\n      'action', CASE \r\n        WHEN p_response = 'accept' THEN 'slot_offer_accepted'\r\n        WHEN p_response = 'decline' THEN 'slot_offer_declined'\r\n      END,\r\n      'player_id', p_player_id,\r\n      'game_number', (\r\n        SELECT COUNT(*) + 1 \r\n        FROM games g2 \r\n        WHERE g2.date < (SELECT date FROM games WHERE id = p_game_id) \r\n        OR (g2.date = (SELECT date FROM games WHERE id = p_game_id) AND g2.id < p_game_id)\r\n      )\r\n    )\r\n  FROM admin_roles ar\r\n  JOIN admin_permissions ap ON ap.admin_role_id = ar.id\r\n  WHERE ap.permission = 'manage_games';\r\n\r\n  -- Also notify admins about new offers being created if this was a decline\r\n  IF p_response = 'decline' THEN\r\n    INSERT INTO notifications (\r\n      player_id,\r\n      type,\r\n      message,\r\n      metadata\r\n    )\r\n    SELECT DISTINCT\r\n      ar.player_id,\r\n      'system_message',\r\n      'Creating new slot offers after ' || (SELECT username FROM players WHERE id = p_player_id) || ' declined',\r\n      jsonb_build_object(\r\n        'game_id', p_game_id,\r\n        'action', 'creating_new_offers',\r\n        'declined_player_id', p_player_id\r\n      )\r\n    FROM admin_roles ar\r\n    JOIN admin_permissions ap ON ap.admin_role_id = ar.id\r\n    WHERE ap.permission = 'manage_games';\r\n  END IF;\r\n\r\n  RETURN v_message;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "text",
    "source_code": "\r\nDECLARE\r\n  v_current_offer_id UUID;\r\n  v_current_offer_status TEXT;\r\n  v_message TEXT;\r\nBEGIN\r\n  -- Get the current offer status\r\n  SELECT id, status INTO v_current_offer_id, v_current_offer_status\r\n  FROM slot_offers\r\n  WHERE game_id = p_game_id \r\n  AND player_id = p_player_id \r\n  AND status = 'pending'\r\n  ORDER BY created_at DESC\r\n  LIMIT 1;\r\n\r\n  -- If no pending offer exists, return error\r\n  IF v_current_offer_id IS NULL THEN\r\n    RETURN 'No pending offer found';\r\n  END IF;\r\n\r\n  -- Update the current offer based on response\r\n  UPDATE slot_offers\r\n  SET \r\n    status = CASE \r\n      WHEN p_response = 'accept' THEN 'accepted'\r\n      WHEN p_response = 'decline' THEN 'declined'\r\n      ELSE status\r\n    END,\r\n    responded_at = NOW()\r\n  WHERE id = v_current_offer_id;\r\n\r\n  -- If offer was declined, create offers for next eligible players\r\n  IF p_response = 'decline' THEN\r\n    -- Update game registration to mark as declined\r\n    UPDATE game_registrations\r\n    SET has_declined = true\r\n    WHERE game_id = p_game_id AND player_id = p_player_id;\r\n\r\n    -- Call create_slot_offers to generate new offers\r\n    PERFORM create_slot_offers(p_game_id);\r\n    \r\n    v_message := 'Offer declined. New offers will be created for eligible players.';\r\n  ELSIF p_response = 'accept' THEN\r\n    -- Update game registration status\r\n    UPDATE game_registrations \r\n    SET status = 'confirmed'\r\n    WHERE game_id = p_game_id AND player_id = p_player_id;\r\n\r\n    -- Update any other pending offers to expired\r\n    UPDATE slot_offers\r\n    SET status = 'expired'\r\n    WHERE game_id = p_game_id \r\n    AND status = 'pending'\r\n    AND player_id != p_player_id;\r\n\r\n    v_message := 'Offer accepted. Your spot has been confirmed.';\r\n  END IF;\r\n\r\n  -- Send notification to admins about the response\r\n  INSERT INTO notifications (\r\n    player_id,\r\n    type,\r\n    message,\r\n    metadata\r\n  )\r\n  SELECT DISTINCT\r\n    ar.player_id,\r\n    'system_message',\r\n    CASE \r\n      WHEN p_response = 'accept' THEN \r\n        (SELECT username FROM players WHERE id = p_player_id) || ' has accepted a slot offer for WNF #' || \r\n        (SELECT COUNT(*) + 1 \r\n         FROM games g2 \r\n         WHERE g2.date < (SELECT date FROM games WHERE id = p_game_id) \r\n         OR (g2.date = (SELECT date FROM games WHERE id = p_game_id) AND g2.id < p_game_id))\r\n      WHEN p_response = 'decline' THEN \r\n        (SELECT username FROM players WHERE id = p_player_id) || ' has declined a slot offer for WNF #' ||\r\n        (SELECT COUNT(*) + 1 \r\n         FROM games g2 \r\n         WHERE g2.date < (SELECT date FROM games WHERE id = p_game_id) \r\n         OR (g2.date = (SELECT date FROM games WHERE id = p_game_id) AND g2.id < p_game_id))\r\n    END,\r\n    jsonb_build_object(\r\n      'game_id', p_game_id,\r\n      'action', CASE \r\n        WHEN p_response = 'accept' THEN 'slot_offer_accepted'\r\n        WHEN p_response = 'decline' THEN 'slot_offer_declined'\r\n      END,\r\n      'player_id', p_player_id,\r\n      'game_number', (\r\n        SELECT COUNT(*) + 1 \r\n        FROM games g2 \r\n        WHERE g2.date < (SELECT date FROM games WHERE id = p_game_id) \r\n        OR (g2.date = (SELECT date FROM games WHERE id = p_game_id) AND g2.id < p_game_id)\r\n      )\r\n    )\r\n  FROM admin_roles ar\r\n  JOIN admin_permissions ap ON ap.admin_role_id = ar.id\r\n  WHERE ap.permission = 'manage_games';\r\n\r\n  -- Also notify admins about new offers being created if this was a decline\r\n  IF p_response = 'decline' THEN\r\n    INSERT INTO notifications (\r\n      player_id,\r\n      type,\r\n      message,\r\n      metadata\r\n    )\r\n    SELECT DISTINCT\r\n      ar.player_id,\r\n      'system_message',\r\n      'Creating new slot offers after ' || (SELECT username FROM players WHERE id = p_player_id) || ' declined',\r\n      jsonb_build_object(\r\n        'game_id', p_game_id,\r\n        'action', 'creating_new_offers',\r\n        'declined_player_id', p_player_id\r\n      )\r\n    FROM admin_roles ar\r\n    JOIN admin_permissions ap ON ap.admin_role_id = ar.id\r\n    WHERE ap.permission = 'manage_games';\r\n  END IF;\r\n\r\n  RETURN v_message;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": true
  },
  {
    "function_name": "has_permission",
    "function_definition": "CREATE OR REPLACE FUNCTION public.has_permission(permission_type admin_permission)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n  RETURN EXISTS (\r\n    SELECT 1 \r\n    FROM admin_roles ar\r\n    LEFT JOIN admin_permissions ap ON ar.id = ap.admin_role_id\r\n    WHERE ar.player_id = (\r\n      SELECT id FROM players WHERE user_id = auth.uid()\r\n    )\r\n    AND (\r\n      ar.is_super_admin = true \r\n      OR ap.permission = permission_type\r\n    )\r\n  );\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "boolean",
    "source_code": "\r\nBEGIN\r\n  RETURN EXISTS (\r\n    SELECT 1 \r\n    FROM admin_roles ar\r\n    LEFT JOIN admin_permissions ap ON ar.id = ap.admin_role_id\r\n    WHERE ar.player_id = (\r\n      SELECT id FROM players WHERE user_id = auth.uid()\r\n    )\r\n    AND (\r\n      ar.is_super_admin = true \r\n      OR ap.permission = permission_type\r\n    )\r\n  );\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": true
  },
  {
    "function_name": "log_debug",
    "function_definition": "CREATE OR REPLACE FUNCTION public.log_debug(message text)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  RAISE NOTICE '%', message;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "void",
    "source_code": "\r\nBEGIN\r\n  RAISE NOTICE '%', message;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "maintenance_cleanup_debug_logs",
    "function_definition": "CREATE OR REPLACE FUNCTION public.maintenance_cleanup_debug_logs(p_hours_to_retain integer DEFAULT 24)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_deleted_count integer;\r\n    v_result jsonb;\r\nBEGIN\r\n    -- Delete logs older than specified hours and get count of deleted rows\r\n    WITH deleted AS (\r\n        DELETE FROM debug_logs \r\n        WHERE timestamp < NOW() - (p_hours_to_retain || ' hours')::interval\r\n        RETURNING *\r\n    )\r\n    SELECT COUNT(*) INTO v_deleted_count FROM deleted;\r\n\r\n    -- Create result object\r\n    v_result := jsonb_build_object(\r\n        'deleted_count', v_deleted_count,\r\n        'cleanup_time', NOW()::text,\r\n        'retention_hours', p_hours_to_retain,\r\n        'remaining_logs', (SELECT COUNT(*) FROM debug_logs)\r\n    );\r\n\r\n    -- Log the cleanup operation itself\r\n    INSERT INTO debug_logs (\r\n        event_type,\r\n        message,\r\n        details\r\n    ) VALUES (\r\n        'maintenance',\r\n        'Cleaned up old debug logs',\r\n        v_result\r\n    );\r\n\r\n    RETURN v_result;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "jsonb",
    "source_code": "\r\nDECLARE\r\n    v_deleted_count integer;\r\n    v_result jsonb;\r\nBEGIN\r\n    -- Delete logs older than specified hours and get count of deleted rows\r\n    WITH deleted AS (\r\n        DELETE FROM debug_logs \r\n        WHERE timestamp < NOW() - (p_hours_to_retain || ' hours')::interval\r\n        RETURNING *\r\n    )\r\n    SELECT COUNT(*) INTO v_deleted_count FROM deleted;\r\n\r\n    -- Create result object\r\n    v_result := jsonb_build_object(\r\n        'deleted_count', v_deleted_count,\r\n        'cleanup_time', NOW()::text,\r\n        'retention_hours', p_hours_to_retain,\r\n        'remaining_logs', (SELECT COUNT(*) FROM debug_logs)\r\n    );\r\n\r\n    -- Log the cleanup operation itself\r\n    INSERT INTO debug_logs (\r\n        event_type,\r\n        message,\r\n        details\r\n    ) VALUES (\r\n        'maintenance',\r\n        'Cleaned up old debug logs',\r\n        v_result\r\n    );\r\n\r\n    RETURN v_result;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": true
  },
  {
    "function_name": "process_game_completion",
    "function_definition": "CREATE OR REPLACE FUNCTION public.process_game_completion()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- Only process if the game is being marked as completed\r\n    IF NEW.status = 'completed' AND OLD.status != 'completed' THEN\r\n        -- Get the latest game number for calculating games_ago\r\n        WITH latest_game AS (\r\n            SELECT MAX(sequence_number) as max_seq\r\n            FROM games \r\n            WHERE completed = true\r\n        )\r\n        -- Insert reserve rewards for eligible players with tapering\r\n        INSERT INTO reserve_xp_transactions (\r\n            player_id,\r\n            game_id,\r\n            xp_amount,\r\n            transaction_type\r\n        )\r\n        SELECT \r\n            gr.player_id,\r\n            gr.game_id,\r\n            CASE\r\n                WHEN (latest.max_seq - NEW.sequence_number) BETWEEN 0 AND 39 THEN \r\n                    5 * (40 - (latest.max_seq - NEW.sequence_number)) / 40  -- Linear taper from 5 to 0 over 40 games\r\n                ELSE 0  -- No XP for games older than 40 games ago\r\n            END as xp_amount,\r\n            'RESERVE_REWARD' as transaction_type\r\n        FROM game_registrations gr\r\n        CROSS JOIN latest_game latest\r\n        WHERE gr.game_id = NEW.id\r\n        AND gr.status = 'reserve'\r\n        AND NOT EXISTS (\r\n            SELECT 1 \r\n            FROM reserve_xp_transactions rt \r\n            WHERE rt.player_id = gr.player_id \r\n            AND rt.game_id = gr.game_id\r\n        );\r\n\r\n        -- Update player XP for all affected players\r\n        UPDATE player_xp px\r\n        SET \r\n            xp = calculate_player_xp(px.player_id),\r\n            last_calculated = CURRENT_TIMESTAMP\r\n        FROM game_registrations gr\r\n        WHERE gr.game_id = NEW.id\r\n        AND gr.player_id = px.player_id;\r\n    END IF;\r\n\r\n    RETURN NEW;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "trigger",
    "source_code": "\r\nBEGIN\r\n    -- Only process if the game is being marked as completed\r\n    IF NEW.status = 'completed' AND OLD.status != 'completed' THEN\r\n        -- Get the latest game number for calculating games_ago\r\n        WITH latest_game AS (\r\n            SELECT MAX(sequence_number) as max_seq\r\n            FROM games \r\n            WHERE completed = true\r\n        )\r\n        -- Insert reserve rewards for eligible players with tapering\r\n        INSERT INTO reserve_xp_transactions (\r\n            player_id,\r\n            game_id,\r\n            xp_amount,\r\n            transaction_type\r\n        )\r\n        SELECT \r\n            gr.player_id,\r\n            gr.game_id,\r\n            CASE\r\n                WHEN (latest.max_seq - NEW.sequence_number) BETWEEN 0 AND 39 THEN \r\n                    5 * (40 - (latest.max_seq - NEW.sequence_number)) / 40  -- Linear taper from 5 to 0 over 40 games\r\n                ELSE 0  -- No XP for games older than 40 games ago\r\n            END as xp_amount,\r\n            'RESERVE_REWARD' as transaction_type\r\n        FROM game_registrations gr\r\n        CROSS JOIN latest_game latest\r\n        WHERE gr.game_id = NEW.id\r\n        AND gr.status = 'reserve'\r\n        AND NOT EXISTS (\r\n            SELECT 1 \r\n            FROM reserve_xp_transactions rt \r\n            WHERE rt.player_id = gr.player_id \r\n            AND rt.game_id = gr.game_id\r\n        );\r\n\r\n        -- Update player XP for all affected players\r\n        UPDATE player_xp px\r\n        SET \r\n            xp = calculate_player_xp(px.player_id),\r\n            last_calculated = CURRENT_TIMESTAMP\r\n        FROM game_registrations gr\r\n        WHERE gr.game_id = NEW.id\r\n        AND gr.player_id = px.player_id;\r\n    END IF;\r\n\r\n    RETURN NEW;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "process_reserve_xp",
    "function_definition": "CREATE OR REPLACE FUNCTION public.process_reserve_xp()\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- Get the latest game number for calculating games_ago\r\n    WITH latest_game AS (\r\n        SELECT MAX(sequence_number) as max_seq\r\n        FROM games \r\n        WHERE completed = true\r\n    )\r\n    -- Insert reserve rewards for eligible players with tapering\r\n    INSERT INTO reserve_xp_transactions (player_id, game_id, xp_amount, transaction_type)\r\n    SELECT DISTINCT\r\n        gr.player_id,\r\n        gr.game_id,\r\n        CASE\r\n            WHEN (latest.max_seq - g.sequence_number) BETWEEN 0 AND 39 THEN \r\n                5 * (40 - (latest.max_seq - g.sequence_number)) / 40  -- Linear taper from 5 to 0 over 40 games\r\n            ELSE 0  -- No XP for games older than 40 games ago\r\n        END as xp_amount,\r\n        'RESERVE_REWARD' as transaction_type\r\n    FROM game_registrations gr\r\n    JOIN games g ON g.id = gr.game_id\r\n    CROSS JOIN latest_game latest\r\n    LEFT JOIN reserve_xp_transactions rxp \r\n        ON rxp.player_id = gr.player_id \r\n        AND rxp.game_id = gr.game_id\r\n        AND rxp.transaction_type = 'RESERVE_REWARD'\r\n    WHERE \r\n        gr.status = 'reserve'\r\n        AND g.date < CURRENT_TIMESTAMP\r\n        AND g.status = 'completed'  -- Only award XP for completed games\r\n        AND rxp.id IS NULL\r\n        -- Ensure player wasn't moved from reserve to selected\r\n        AND NOT EXISTS (\r\n            SELECT 1 \r\n            FROM game_registrations gr2\r\n            WHERE gr2.game_id = gr.game_id\r\n            AND gr2.player_id = gr.player_id\r\n            AND gr2.status = 'selected'\r\n        );\r\n\r\n    -- Update player_xp table with new XP\r\n    UPDATE player_xp px\r\n    SET \r\n        xp = calculate_player_xp(px.player_id),\r\n        last_calculated = CURRENT_TIMESTAMP\r\n    WHERE EXISTS (\r\n        SELECT 1 \r\n        FROM reserve_xp_transactions rt\r\n        WHERE rt.player_id = px.player_id\r\n        AND rt.created_at > px.last_calculated\r\n    );\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "void",
    "source_code": "\r\nBEGIN\r\n    -- Get the latest game number for calculating games_ago\r\n    WITH latest_game AS (\r\n        SELECT MAX(sequence_number) as max_seq\r\n        FROM games \r\n        WHERE completed = true\r\n    )\r\n    -- Insert reserve rewards for eligible players with tapering\r\n    INSERT INTO reserve_xp_transactions (player_id, game_id, xp_amount, transaction_type)\r\n    SELECT DISTINCT\r\n        gr.player_id,\r\n        gr.game_id,\r\n        CASE\r\n            WHEN (latest.max_seq - g.sequence_number) BETWEEN 0 AND 39 THEN \r\n                5 * (40 - (latest.max_seq - g.sequence_number)) / 40  -- Linear taper from 5 to 0 over 40 games\r\n            ELSE 0  -- No XP for games older than 40 games ago\r\n        END as xp_amount,\r\n        'RESERVE_REWARD' as transaction_type\r\n    FROM game_registrations gr\r\n    JOIN games g ON g.id = gr.game_id\r\n    CROSS JOIN latest_game latest\r\n    LEFT JOIN reserve_xp_transactions rxp \r\n        ON rxp.player_id = gr.player_id \r\n        AND rxp.game_id = gr.game_id\r\n        AND rxp.transaction_type = 'RESERVE_REWARD'\r\n    WHERE \r\n        gr.status = 'reserve'\r\n        AND g.date < CURRENT_TIMESTAMP\r\n        AND g.status = 'completed'  -- Only award XP for completed games\r\n        AND rxp.id IS NULL\r\n        -- Ensure player wasn't moved from reserve to selected\r\n        AND NOT EXISTS (\r\n            SELECT 1 \r\n            FROM game_registrations gr2\r\n            WHERE gr2.game_id = gr.game_id\r\n            AND gr2.player_id = gr.player_id\r\n            AND gr2.status = 'selected'\r\n        );\r\n\r\n    -- Update player_xp table with new XP\r\n    UPDATE player_xp px\r\n    SET \r\n        xp = calculate_player_xp(px.player_id),\r\n        last_calculated = CURRENT_TIMESTAMP\r\n    WHERE EXISTS (\r\n        SELECT 1 \r\n        FROM reserve_xp_transactions rt\r\n        WHERE rt.player_id = px.player_id\r\n        AND rt.created_at > px.last_calculated\r\n    );\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "process_reserve_xp_rewards",
    "function_definition": "CREATE OR REPLACE FUNCTION public.process_reserve_xp_rewards()\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- Insert reserve rewards for eligible players\r\n    INSERT INTO reserve_xp_transactions (player_id, game_id, xp_amount, transaction_type)\r\n    SELECT DISTINCT\r\n        gr.player_id,\r\n        gr.game_id,\r\n        5 as xp_amount,\r\n        'RESERVE_REWARD' as transaction_type\r\n    FROM game_registrations gr\r\n    JOIN games g ON g.id = gr.game_id\r\n    LEFT JOIN reserve_xp_transactions rxp \r\n        ON rxp.player_id = gr.player_id \r\n        AND rxp.game_id = gr.game_id\r\n        AND rxp.transaction_type = 'RESERVE_REWARD'\r\n    WHERE \r\n        gr.status = 'reserve'\r\n        AND g.date < CURRENT_TIMESTAMP\r\n        AND g.status = 'completed'  -- Only award XP for completed games\r\n        AND rxp.id IS NULL\r\n        -- Ensure player wasn't moved from reserve to selected\r\n        AND NOT EXISTS (\r\n            SELECT 1 \r\n            FROM game_registrations gr2\r\n            WHERE gr2.game_id = gr.game_id\r\n            AND gr2.player_id = gr.player_id\r\n            AND gr2.status = 'selected'\r\n        );\r\n\r\n    -- Update player_xp table with new XP\r\n    UPDATE player_xp px\r\n    SET \r\n        xp = px.xp + (\r\n            SELECT COALESCE(SUM(xp_amount), 0)\r\n            FROM reserve_xp_transactions rt\r\n            WHERE rt.player_id = px.player_id\r\n            AND rt.created_at > px.last_calculated\r\n        ),\r\n        last_calculated = CURRENT_TIMESTAMP\r\n    WHERE EXISTS (\r\n        SELECT 1 \r\n        FROM reserve_xp_transactions rt\r\n        WHERE rt.player_id = px.player_id\r\n        AND rt.created_at > px.last_calculated\r\n    );\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "void",
    "source_code": "\r\nBEGIN\r\n    -- Insert reserve rewards for eligible players\r\n    INSERT INTO reserve_xp_transactions (player_id, game_id, xp_amount, transaction_type)\r\n    SELECT DISTINCT\r\n        gr.player_id,\r\n        gr.game_id,\r\n        5 as xp_amount,\r\n        'RESERVE_REWARD' as transaction_type\r\n    FROM game_registrations gr\r\n    JOIN games g ON g.id = gr.game_id\r\n    LEFT JOIN reserve_xp_transactions rxp \r\n        ON rxp.player_id = gr.player_id \r\n        AND rxp.game_id = gr.game_id\r\n        AND rxp.transaction_type = 'RESERVE_REWARD'\r\n    WHERE \r\n        gr.status = 'reserve'\r\n        AND g.date < CURRENT_TIMESTAMP\r\n        AND g.status = 'completed'  -- Only award XP for completed games\r\n        AND rxp.id IS NULL\r\n        -- Ensure player wasn't moved from reserve to selected\r\n        AND NOT EXISTS (\r\n            SELECT 1 \r\n            FROM game_registrations gr2\r\n            WHERE gr2.game_id = gr.game_id\r\n            AND gr2.player_id = gr.player_id\r\n            AND gr2.status = 'selected'\r\n        );\r\n\r\n    -- Update player_xp table with new XP\r\n    UPDATE player_xp px\r\n    SET \r\n        xp = px.xp + (\r\n            SELECT COALESCE(SUM(xp_amount), 0)\r\n            FROM reserve_xp_transactions rt\r\n            WHERE rt.player_id = px.player_id\r\n            AND rt.created_at > px.last_calculated\r\n        ),\r\n        last_calculated = CURRENT_TIMESTAMP\r\n    WHERE EXISTS (\r\n        SELECT 1 \r\n        FROM reserve_xp_transactions rt\r\n        WHERE rt.player_id = px.player_id\r\n        AND rt.created_at > px.last_calculated\r\n    );\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "process_team_announcements",
    "function_definition": "CREATE OR REPLACE FUNCTION public.process_team_announcements()\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    game_record RECORD;\r\nBEGIN\r\n    FOR game_record IN\r\n        SELECT id\r\n        FROM games\r\n        WHERE team_announcement_time <= NOW()\r\n        AND team_announcement_time > NOW() - INTERVAL '5 minutes'\r\n        AND teams_announced = FALSE\r\n    LOOP\r\n        -- Balance teams for this game\r\n        PERFORM balance_teams(game_record.id);\r\n        \r\n        -- Mark the game as having teams announced\r\n        UPDATE games\r\n        SET teams_announced = TRUE\r\n        WHERE id = game_record.id;\r\n    END LOOP;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "void",
    "source_code": "\r\nDECLARE\r\n    game_record RECORD;\r\nBEGIN\r\n    FOR game_record IN\r\n        SELECT id\r\n        FROM games\r\n        WHERE team_announcement_time <= NOW()\r\n        AND team_announcement_time > NOW() - INTERVAL '5 minutes'\r\n        AND teams_announced = FALSE\r\n    LOOP\r\n        -- Balance teams for this game\r\n        PERFORM balance_teams(game_record.id);\r\n        \r\n        -- Mark the game as having teams announced\r\n        UPDATE games\r\n        SET teams_announced = TRUE\r\n        WHERE id = game_record.id;\r\n    END LOOP;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": true
  },
  {
    "function_name": "promote_to_super_admin",
    "function_definition": "CREATE OR REPLACE FUNCTION public.promote_to_super_admin(target_user_id uuid)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n  IF EXISTS (\r\n    SELECT 1 FROM players \r\n    WHERE user_id = auth.uid() \r\n    AND is_super_admin = true\r\n  ) THEN\r\n    UPDATE players \r\n    SET is_super_admin = true \r\n    WHERE user_id = target_user_id;\r\n  ELSE\r\n    RAISE EXCEPTION 'Only super admins can promote other users to super admin';\r\n  END IF;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "void",
    "source_code": "\r\nBEGIN\r\n  IF EXISTS (\r\n    SELECT 1 FROM players \r\n    WHERE user_id = auth.uid() \r\n    AND is_super_admin = true\r\n  ) THEN\r\n    UPDATE players \r\n    SET is_super_admin = true \r\n    WHERE user_id = target_user_id;\r\n  ELSE\r\n    RAISE EXCEPTION 'Only super admins can promote other users to super admin';\r\n  END IF;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": true
  },
  {
    "function_name": "recalculate_all_player_xp",
    "function_definition": "CREATE OR REPLACE FUNCTION public.recalculate_all_player_xp()\n RETURNS TABLE(player_id uuid, old_xp integer, new_xp integer, friendly_name text)\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- First, get the old XP values\r\n    CREATE TEMP TABLE temp_old_xp AS\r\n    SELECT px.player_id as px_player_id, px.xp as old_xp\r\n    FROM player_xp px;\r\n\r\n    -- Then update all XP values\r\n    WITH updated_xp AS (\r\n        UPDATE player_xp px\r\n        SET \r\n            xp = calculate_player_xp(px.player_id),\r\n            last_calculated = CURRENT_TIMESTAMP\r\n        FROM players p\r\n        WHERE px.player_id = p.id\r\n        RETURNING px.player_id, px.xp as new_xp\r\n    )\r\n    -- Insert for any players that don't have an XP record\r\n    INSERT INTO player_xp (player_id, xp, last_calculated)\r\n    SELECT \r\n        p.id,\r\n        calculate_player_xp(p.id),\r\n        CURRENT_TIMESTAMP\r\n    FROM players p\r\n    WHERE NOT EXISTS (\r\n        SELECT 1 FROM player_xp px WHERE px.player_id = p.id\r\n    );\r\n\r\n    -- Return the results showing changes\r\n    RETURN QUERY\r\n    SELECT \r\n        px.player_id,\r\n        COALESCE(t.old_xp, 0),\r\n        px.xp as new_xp,\r\n        p.friendly_name\r\n    FROM player_xp px\r\n    JOIN players p ON p.id = px.player_id\r\n    LEFT JOIN temp_old_xp t ON t.px_player_id = px.player_id\r\n    WHERE COALESCE(t.old_xp, 0) != px.xp\r\n    ORDER BY ABS(px.xp - COALESCE(t.old_xp, 0)) DESC;\r\n\r\n    -- Clean up\r\n    DROP TABLE temp_old_xp;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "record",
    "source_code": "\r\nBEGIN\r\n    -- First, get the old XP values\r\n    CREATE TEMP TABLE temp_old_xp AS\r\n    SELECT px.player_id as px_player_id, px.xp as old_xp\r\n    FROM player_xp px;\r\n\r\n    -- Then update all XP values\r\n    WITH updated_xp AS (\r\n        UPDATE player_xp px\r\n        SET \r\n            xp = calculate_player_xp(px.player_id),\r\n            last_calculated = CURRENT_TIMESTAMP\r\n        FROM players p\r\n        WHERE px.player_id = p.id\r\n        RETURNING px.player_id, px.xp as new_xp\r\n    )\r\n    -- Insert for any players that don't have an XP record\r\n    INSERT INTO player_xp (player_id, xp, last_calculated)\r\n    SELECT \r\n        p.id,\r\n        calculate_player_xp(p.id),\r\n        CURRENT_TIMESTAMP\r\n    FROM players p\r\n    WHERE NOT EXISTS (\r\n        SELECT 1 FROM player_xp px WHERE px.player_id = p.id\r\n    );\r\n\r\n    -- Return the results showing changes\r\n    RETURN QUERY\r\n    SELECT \r\n        px.player_id,\r\n        COALESCE(t.old_xp, 0),\r\n        px.xp as new_xp,\r\n        p.friendly_name\r\n    FROM player_xp px\r\n    JOIN players p ON p.id = px.player_id\r\n    LEFT JOIN temp_old_xp t ON t.px_player_id = px.player_id\r\n    WHERE COALESCE(t.old_xp, 0) != px.xp\r\n    ORDER BY ABS(px.xp - COALESCE(t.old_xp, 0)) DESC;\r\n\r\n    -- Clean up\r\n    DROP TABLE temp_old_xp;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "recalculate_all_win_rates",
    "function_definition": "CREATE OR REPLACE FUNCTION public.recalculate_all_win_rates()\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    win_rate_data RECORD;\r\nBEGIN\r\n    FOR win_rate_data IN SELECT * FROM get_player_win_rates()\r\n    LOOP\r\n        UPDATE players \r\n        SET win_rate = win_rate_data.win_rate\r\n        WHERE id = win_rate_data.id;\r\n    END LOOP;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "void",
    "source_code": "\r\nDECLARE\r\n    win_rate_data RECORD;\r\nBEGIN\r\n    FOR win_rate_data IN SELECT * FROM get_player_win_rates()\r\n    LOOP\r\n        UPDATE players \r\n        SET win_rate = win_rate_data.win_rate\r\n        WHERE id = win_rate_data.id;\r\n    END LOOP;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": true
  },
  {
    "function_name": "recalculate_player_xp",
    "function_definition": "CREATE OR REPLACE FUNCTION public.recalculate_player_xp(target_player_id uuid)\n RETURNS TABLE(old_xp integer, new_xp integer, friendly_name text)\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_old_xp integer;\r\nBEGIN\r\n    -- Get old XP value\r\n    SELECT px.xp INTO v_old_xp\r\n    FROM player_xp px\r\n    WHERE px.player_id = target_player_id;\r\n\r\n    RETURN QUERY\r\n    WITH new_value AS (\r\n        INSERT INTO player_xp (player_id, xp, last_calculated)\r\n        SELECT \r\n            target_player_id,\r\n            calculate_player_xp(target_player_id),\r\n            CURRENT_TIMESTAMP\r\n        ON CONFLICT (player_id) DO UPDATE\r\n        SET \r\n            xp = EXCLUDED.xp,\r\n            last_calculated = EXCLUDED.last_calculated\r\n        RETURNING xp as new_xp\r\n    )\r\n    SELECT \r\n        COALESCE(v_old_xp, 0) as old_xp,\r\n        nv.new_xp,\r\n        p.friendly_name\r\n    FROM new_value nv\r\n    JOIN players p ON p.id = target_player_id;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "record",
    "source_code": "\r\nDECLARE\r\n    v_old_xp integer;\r\nBEGIN\r\n    -- Get old XP value\r\n    SELECT px.xp INTO v_old_xp\r\n    FROM player_xp px\r\n    WHERE px.player_id = target_player_id;\r\n\r\n    RETURN QUERY\r\n    WITH new_value AS (\r\n        INSERT INTO player_xp (player_id, xp, last_calculated)\r\n        SELECT \r\n            target_player_id,\r\n            calculate_player_xp(target_player_id),\r\n            CURRENT_TIMESTAMP\r\n        ON CONFLICT (player_id) DO UPDATE\r\n        SET \r\n            xp = EXCLUDED.xp,\r\n            last_calculated = EXCLUDED.last_calculated\r\n        RETURNING xp as new_xp\r\n    )\r\n    SELECT \r\n        COALESCE(v_old_xp, 0) as old_xp,\r\n        nv.new_xp,\r\n        p.friendly_name\r\n    FROM new_value nv\r\n    JOIN players p ON p.id = target_player_id;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "reject_slot_offer",
    "function_definition": "CREATE OR REPLACE FUNCTION public.reject_slot_offer(p_slot_offer_id uuid)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_offer record;\r\nBEGIN\r\n    -- Get offer details\r\n    SELECT * INTO v_offer\r\n    FROM slot_offers\r\n    WHERE id = p_slot_offer_id;\r\n\r\n    IF NOT FOUND THEN\r\n        RAISE EXCEPTION 'Slot offer not found';\r\n    END IF;\r\n\r\n    -- Mark this offer as rejected\r\n    UPDATE slot_offers\r\n    SET status = 'rejected'\r\n    WHERE id = p_slot_offer_id;\r\n\r\n    -- Create next slot offer\r\n    PERFORM create_next_slot_offer(v_offer.game_id, v_offer.rank);\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "void",
    "source_code": "\r\nDECLARE\r\n    v_offer record;\r\nBEGIN\r\n    -- Get offer details\r\n    SELECT * INTO v_offer\r\n    FROM slot_offers\r\n    WHERE id = p_slot_offer_id;\r\n\r\n    IF NOT FOUND THEN\r\n        RAISE EXCEPTION 'Slot offer not found';\r\n    END IF;\r\n\r\n    -- Mark this offer as rejected\r\n    UPDATE slot_offers\r\n    SET status = 'rejected'\r\n    WHERE id = p_slot_offer_id;\r\n\r\n    -- Create next slot offer\r\n    PERFORM create_next_slot_offer(v_offer.game_id, v_offer.rank);\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "reset_game_selection",
    "function_definition": "CREATE OR REPLACE FUNCTION public.reset_game_selection(game_id uuid)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nbegin\r\n  -- Reset game status to open\r\n  update games\r\n  set status = 'open'\r\n  where id = game_id;\r\n\r\n  -- Reset all registrations\r\n  update game_registrations\r\n  set status = 'registered',\r\n      randomly_selected = false\r\n  where game_id = game_id;\r\nend;\r\n$function$\n",
    "function_description": null,
    "return_type": "void",
    "source_code": "\r\nbegin\r\n  -- Reset game status to open\r\n  update games\r\n  set status = 'open'\r\n  where id = game_id;\r\n\r\n  -- Reset all registrations\r\n  update game_registrations\r\n  set status = 'registered',\r\n      randomly_selected = false\r\n  where game_id = game_id;\r\nend;\r\n",
    "volatility": "v",
    "security_definer": true
  },
  {
    "function_name": "update_all_player_xp",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_all_player_xp()\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_player record;\r\nBEGIN\r\n    FOR v_player IN SELECT id FROM players LOOP\r\n        PERFORM calculate_player_xp(v_player.id);\r\n    END LOOP;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "void",
    "source_code": "\r\nDECLARE\r\n    v_player record;\r\nBEGIN\r\n    FOR v_player IN SELECT id FROM players LOOP\r\n        PERFORM calculate_player_xp(v_player.id);\r\n    END LOOP;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "update_bench_warmer_streak",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_bench_warmer_streak()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- Update bench_warmer_streak for the affected player\r\n    IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN\r\n        UPDATE players\r\n        SET bench_warmer_streak = calculate_bench_warmer_streak(NEW.player_id)\r\n        WHERE id = NEW.player_id;\r\n    END IF;\r\n    RETURN NEW;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "trigger",
    "source_code": "\r\nBEGIN\r\n    -- Update bench_warmer_streak for the affected player\r\n    IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN\r\n        UPDATE players\r\n        SET bench_warmer_streak = calculate_bench_warmer_streak(NEW.player_id)\r\n        WHERE id = NEW.player_id;\r\n    END IF;\r\n    RETURN NEW;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "update_game_needs_completion",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_game_needs_completion()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  -- Only set needs_completion for games created from today onwards\r\n  IF NEW.created_at > '2024-11-28'::timestamp AND\r\n     (NEW.score_blue IS NULL OR NEW.score_orange IS NULL OR NEW.outcome IS NULL) THEN\r\n    NEW.needs_completion := true;\r\n  ELSE\r\n    NEW.needs_completion := false;\r\n  END IF;\r\n  RETURN NEW;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "trigger",
    "source_code": "\r\nBEGIN\r\n  -- Only set needs_completion for games created from today onwards\r\n  IF NEW.created_at > '2024-11-28'::timestamp AND\r\n     (NEW.score_blue IS NULL OR NEW.score_orange IS NULL OR NEW.outcome IS NULL) THEN\r\n    NEW.needs_completion := true;\r\n  ELSE\r\n    NEW.needs_completion := false;\r\n  END IF;\r\n  RETURN NEW;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "update_game_registration_status",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_game_registration_status(p_game_id uuid, p_player_id uuid, p_status text)\n RETURNS SETOF game_registrations\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n    -- Update the registration\r\n    RETURN QUERY\r\n    UPDATE game_registrations\r\n    SET status = p_status\r\n    WHERE game_id = p_game_id\r\n    AND player_id = p_player_id\r\n    RETURNING *;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "game_registrations",
    "source_code": "\r\nBEGIN\r\n    -- Update the registration\r\n    RETURN QUERY\r\n    UPDATE game_registrations\r\n    SET status = p_status\r\n    WHERE game_id = p_game_id\r\n    AND player_id = p_player_id\r\n    RETURNING *;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": true
  },
  {
    "function_name": "update_game_registration_status",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_game_registration_status(p_registration_id uuid, p_old_status text, p_new_status text)\n RETURNS boolean\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  v_updated boolean;\r\nBEGIN\r\n  -- Update the registration status only if it matches the old status\r\n  UPDATE game_registrations\r\n  SET status = p_new_status,\r\n      updated_at = NOW()\r\n  WHERE id = p_registration_id\r\n    AND status = p_old_status;\r\n\r\n  -- Check if a row was updated\r\n  GET DIAGNOSTICS v_updated = ROW_COUNT;\r\n  \r\n  -- Return true if a row was updated, false otherwise\r\n  RETURN v_updated > 0;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "boolean",
    "source_code": "\r\nDECLARE\r\n  v_updated boolean;\r\nBEGIN\r\n  -- Update the registration status only if it matches the old status\r\n  UPDATE game_registrations\r\n  SET status = p_new_status,\r\n      updated_at = NOW()\r\n  WHERE id = p_registration_id\r\n    AND status = p_old_status;\r\n\r\n  -- Check if a row was updated\r\n  GET DIAGNOSTICS v_updated = ROW_COUNT;\r\n  \r\n  -- Return true if a row was updated, false otherwise\r\n  RETURN v_updated > 0;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "update_game_sequence_numbers",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_game_sequence_numbers()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- Update sequence numbers for all games\r\n    -- Orders by date ascending (oldest first), then by created_at for games with same date\r\n    WITH numbered_games AS (\r\n        SELECT id,\r\n               ROW_NUMBER() OVER (ORDER BY date ASC, created_at ASC) as new_seq\r\n        FROM games\r\n    )\r\n    UPDATE games g\r\n    SET sequence_number = ng.new_seq\r\n    FROM numbered_games ng\r\n    WHERE g.id = ng.id;\r\n    \r\n    RETURN NULL;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "trigger",
    "source_code": "\r\nBEGIN\r\n    -- Update sequence numbers for all games\r\n    -- Orders by date ascending (oldest first), then by created_at for games with same date\r\n    WITH numbered_games AS (\r\n        SELECT id,\r\n               ROW_NUMBER() OVER (ORDER BY date ASC, created_at ASC) as new_seq\r\n        FROM games\r\n    )\r\n    UPDATE games g\r\n    SET sequence_number = ng.new_seq\r\n    FROM numbered_games ng\r\n    WHERE g.id = ng.id;\r\n    \r\n    RETURN NULL;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "update_player_average_ratings",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_player_average_ratings()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nBEGIN\r\n    -- For INSERT or UPDATE\r\n    IF (TG_OP = 'INSERT' OR TG_OP = 'UPDATE') THEN\r\n        -- Update the rated player's averages\r\n        UPDATE players\r\n        SET \r\n            attack_rating = (\r\n                SELECT COALESCE(AVG(attack_rating), 0)\r\n                FROM player_ratings\r\n                WHERE rated_player_id = NEW.rated_player_id\r\n            ),\r\n            defense_rating = (\r\n                SELECT COALESCE(AVG(defense_rating), 0)\r\n                FROM player_ratings\r\n                WHERE rated_player_id = NEW.rated_player_id\r\n            )\r\n        WHERE id = NEW.rated_player_id;\r\n        \r\n        RETURN NEW;\r\n    -- For DELETE\r\n    ELSIF (TG_OP = 'DELETE') THEN\r\n        -- Update the rated player's averages\r\n        UPDATE players\r\n        SET \r\n            attack_rating = (\r\n                SELECT COALESCE(AVG(attack_rating), 0)\r\n                FROM player_ratings\r\n                WHERE rated_player_id = OLD.rated_player_id\r\n            ),\r\n            defense_rating = (\r\n                SELECT COALESCE(AVG(defense_rating), 0)\r\n                FROM player_ratings\r\n                WHERE rated_player_id = OLD.rated_player_id\r\n            )\r\n        WHERE id = OLD.rated_player_id;\r\n        \r\n        RETURN OLD;\r\n    END IF;\r\n    \r\n    RETURN NULL;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "trigger",
    "source_code": "\r\nBEGIN\r\n    -- For INSERT or UPDATE\r\n    IF (TG_OP = 'INSERT' OR TG_OP = 'UPDATE') THEN\r\n        -- Update the rated player's averages\r\n        UPDATE players\r\n        SET \r\n            attack_rating = (\r\n                SELECT COALESCE(AVG(attack_rating), 0)\r\n                FROM player_ratings\r\n                WHERE rated_player_id = NEW.rated_player_id\r\n            ),\r\n            defense_rating = (\r\n                SELECT COALESCE(AVG(defense_rating), 0)\r\n                FROM player_ratings\r\n                WHERE rated_player_id = NEW.rated_player_id\r\n            )\r\n        WHERE id = NEW.rated_player_id;\r\n        \r\n        RETURN NEW;\r\n    -- For DELETE\r\n    ELSIF (TG_OP = 'DELETE') THEN\r\n        -- Update the rated player's averages\r\n        UPDATE players\r\n        SET \r\n            attack_rating = (\r\n                SELECT COALESCE(AVG(attack_rating), 0)\r\n                FROM player_ratings\r\n                WHERE rated_player_id = OLD.rated_player_id\r\n            ),\r\n            defense_rating = (\r\n                SELECT COALESCE(AVG(defense_rating), 0)\r\n                FROM player_ratings\r\n                WHERE rated_player_id = OLD.rated_player_id\r\n            )\r\n        WHERE id = OLD.rated_player_id;\r\n        \r\n        RETURN OLD;\r\n    END IF;\r\n    \r\n    RETURN NULL;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": true
  },
  {
    "function_name": "update_player_caps_on_game_completion",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_player_caps_on_game_completion()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- Only process when a game becomes historical\r\n    IF NEW.is_historical = true AND (OLD.is_historical = false OR OLD.is_historical IS NULL) THEN\r\n        -- Update caps for all players who participated in this game\r\n        UPDATE players p\r\n        SET caps = calculate_player_caps(p.id)\r\n        FROM game_registrations gr\r\n        WHERE gr.game_id = NEW.id \r\n        AND gr.player_id = p.id\r\n        AND gr.team IS NOT NULL  -- Only count actual players, not reserves\r\n        AND (p.manual_caps_override IS NULL OR p.manual_caps_override = false);\r\n    END IF;\r\n    \r\n    RETURN NEW;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "trigger",
    "source_code": "\r\nBEGIN\r\n    -- Only process when a game becomes historical\r\n    IF NEW.is_historical = true AND (OLD.is_historical = false OR OLD.is_historical IS NULL) THEN\r\n        -- Update caps for all players who participated in this game\r\n        UPDATE players p\r\n        SET caps = calculate_player_caps(p.id)\r\n        FROM game_registrations gr\r\n        WHERE gr.game_id = NEW.id \r\n        AND gr.player_id = p.id\r\n        AND gr.team IS NOT NULL  -- Only count actual players, not reserves\r\n        AND (p.manual_caps_override IS NULL OR p.manual_caps_override = false);\r\n    END IF;\r\n    \r\n    RETURN NEW;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "update_player_ranks",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_player_ranks()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- Update ranks for all players based on XP\r\n    WITH ranked_players AS (\r\n        SELECT \r\n            player_id,\r\n            ROW_NUMBER() OVER (ORDER BY xp DESC) as new_rank\r\n        FROM player_xp\r\n        WHERE xp > 0\r\n    )\r\n    UPDATE player_xp px\r\n    SET rank = rp.new_rank\r\n    FROM ranked_players rp\r\n    WHERE px.player_id = rp.player_id;\r\n\r\n    -- Set rank to NULL for players with 0 XP\r\n    UPDATE player_xp\r\n    SET rank = NULL\r\n    WHERE xp = 0;\r\n\r\n    RETURN NULL;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "trigger",
    "source_code": "\r\nBEGIN\r\n    -- Update ranks for all players based on XP\r\n    WITH ranked_players AS (\r\n        SELECT \r\n            player_id,\r\n            ROW_NUMBER() OVER (ORDER BY xp DESC) as new_rank\r\n        FROM player_xp\r\n        WHERE xp > 0\r\n    )\r\n    UPDATE player_xp px\r\n    SET rank = rp.new_rank\r\n    FROM ranked_players rp\r\n    WHERE px.player_id = rp.player_id;\r\n\r\n    -- Set rank to NULL for players with 0 XP\r\n    UPDATE player_xp\r\n    SET rank = NULL\r\n    WHERE xp = 0;\r\n\r\n    RETURN NULL;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "update_player_streak",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_player_streak()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- Only update streak for status changes that affect past games\r\n    IF EXISTS (\r\n        SELECT 1 \r\n        FROM games g \r\n        WHERE g.id = NEW.game_id \r\n        AND g.date < NOW()\r\n    ) THEN\r\n        UPDATE players \r\n        SET current_streak = calculate_player_streak(NEW.player_id)\r\n        WHERE id = NEW.player_id;\r\n    END IF;\r\n    \r\n    RETURN NEW;\r\nEND;\r\n$function$\n",
    "function_description": "Updates player streak based on consecutive selected games. Any non-selected game (including reserve) breaks the streak.",
    "return_type": "trigger",
    "source_code": "\r\nBEGIN\r\n    -- Only update streak for status changes that affect past games\r\n    IF EXISTS (\r\n        SELECT 1 \r\n        FROM games g \r\n        WHERE g.id = NEW.game_id \r\n        AND g.date < NOW()\r\n    ) THEN\r\n        UPDATE players \r\n        SET current_streak = calculate_player_streak(NEW.player_id)\r\n        WHERE id = NEW.player_id;\r\n    END IF;\r\n    \r\n    RETURN NEW;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "update_player_streaks",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_player_streaks()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- For game_registrations changes\r\n    IF TG_TABLE_NAME = 'game_registrations' THEN\r\n        -- Only update streak for completed/historical games\r\n        IF EXISTS (\r\n            SELECT 1 \r\n            FROM games g \r\n            WHERE g.id = NEW.game_id \r\n            AND ((g.completed = true AND g.needs_completion = false) OR g.is_historical = true)\r\n        ) THEN\r\n            UPDATE players \r\n            SET \r\n                current_streak = calculate_player_streak(NEW.player_id),\r\n                bench_warmer_streak = calculate_bench_warmer_streak(NEW.player_id)\r\n            WHERE id = NEW.player_id;\r\n        END IF;\r\n    \r\n    -- For games changes\r\n    ELSIF TG_TABLE_NAME = 'games' THEN\r\n        -- When a game is marked as completed or historical, or deleted\r\n        IF (TG_OP = 'UPDATE' AND \r\n            (\r\n                (NEW.completed = true AND (OLD.completed = false OR OLD.completed IS NULL))\r\n                OR (NEW.is_historical = true AND (OLD.is_historical = false OR OLD.is_historical IS NULL))\r\n            )\r\n        ) OR TG_OP = 'DELETE' THEN\r\n            -- Update streaks for all players in this game\r\n            UPDATE players p\r\n            SET \r\n                current_streak = calculate_player_streak(p.id),\r\n                bench_warmer_streak = calculate_bench_warmer_streak(p.id)\r\n            FROM game_registrations gr\r\n            WHERE gr.game_id = COALESCE(NEW.id, OLD.id)\r\n            AND gr.player_id = p.id;\r\n        END IF;\r\n    END IF;\r\n    \r\n    RETURN COALESCE(NEW, OLD);\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "trigger",
    "source_code": "\r\nBEGIN\r\n    -- For game_registrations changes\r\n    IF TG_TABLE_NAME = 'game_registrations' THEN\r\n        -- Only update streak for completed/historical games\r\n        IF EXISTS (\r\n            SELECT 1 \r\n            FROM games g \r\n            WHERE g.id = NEW.game_id \r\n            AND ((g.completed = true AND g.needs_completion = false) OR g.is_historical = true)\r\n        ) THEN\r\n            UPDATE players \r\n            SET \r\n                current_streak = calculate_player_streak(NEW.player_id),\r\n                bench_warmer_streak = calculate_bench_warmer_streak(NEW.player_id)\r\n            WHERE id = NEW.player_id;\r\n        END IF;\r\n    \r\n    -- For games changes\r\n    ELSIF TG_TABLE_NAME = 'games' THEN\r\n        -- When a game is marked as completed or historical, or deleted\r\n        IF (TG_OP = 'UPDATE' AND \r\n            (\r\n                (NEW.completed = true AND (OLD.completed = false OR OLD.completed IS NULL))\r\n                OR (NEW.is_historical = true AND (OLD.is_historical = false OR OLD.is_historical IS NULL))\r\n            )\r\n        ) OR TG_OP = 'DELETE' THEN\r\n            -- Update streaks for all players in this game\r\n            UPDATE players p\r\n            SET \r\n                current_streak = calculate_player_streak(p.id),\r\n                bench_warmer_streak = calculate_bench_warmer_streak(p.id)\r\n            FROM game_registrations gr\r\n            WHERE gr.game_id = COALESCE(NEW.id, OLD.id)\r\n            AND gr.player_id = p.id;\r\n        END IF;\r\n    END IF;\r\n    \r\n    RETURN COALESCE(NEW, OLD);\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "update_player_unpaid_games",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_player_unpaid_games()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  -- Update unpaid_games count for the player\r\n  WITH unpaid_count AS (\r\n    SELECT \r\n      gr.player_id,\r\n      COUNT(*) as count,\r\n      -0.3 * COUNT(*) as modifier  -- -30% per unpaid game\r\n    FROM game_registrations gr\r\n    JOIN games g ON gr.game_id = g.id\r\n    WHERE \r\n      gr.player_id = NEW.player_id\r\n      AND gr.paid = false  -- Only check if it's paid or not\r\n      AND gr.status != 'reserve'  -- Exclude reserves\r\n      AND g.date < (NOW() - INTERVAL '24 hours')  -- Only count games older than 24 hours\r\n    GROUP BY gr.player_id\r\n  )\r\n  UPDATE players\r\n  SET \r\n    unpaid_games = COALESCE((SELECT count FROM unpaid_count WHERE player_id = NEW.player_id), 0),\r\n    unpaid_games_modifier = COALESCE((SELECT modifier FROM unpaid_count WHERE player_id = NEW.player_id), 0)\r\n  WHERE id = NEW.player_id;\r\n  \r\n  RETURN NEW;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "trigger",
    "source_code": "\r\nBEGIN\r\n  -- Update unpaid_games count for the player\r\n  WITH unpaid_count AS (\r\n    SELECT \r\n      gr.player_id,\r\n      COUNT(*) as count,\r\n      -0.3 * COUNT(*) as modifier  -- -30% per unpaid game\r\n    FROM game_registrations gr\r\n    JOIN games g ON gr.game_id = g.id\r\n    WHERE \r\n      gr.player_id = NEW.player_id\r\n      AND gr.paid = false  -- Only check if it's paid or not\r\n      AND gr.status != 'reserve'  -- Exclude reserves\r\n      AND g.date < (NOW() - INTERVAL '24 hours')  -- Only count games older than 24 hours\r\n    GROUP BY gr.player_id\r\n  )\r\n  UPDATE players\r\n  SET \r\n    unpaid_games = COALESCE((SELECT count FROM unpaid_count WHERE player_id = NEW.player_id), 0),\r\n    unpaid_games_modifier = COALESCE((SELECT modifier FROM unpaid_count WHERE player_id = NEW.player_id), 0)\r\n  WHERE id = NEW.player_id;\r\n  \r\n  RETURN NEW;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "update_player_win_rates",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_player_win_rates()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    player_record RECORD;\r\n    win_rate_data RECORD;\r\nBEGIN\r\n    -- When a game is completed or its outcome is changed\r\n    IF (TG_OP = 'UPDATE' AND \r\n        (NEW.outcome IS DISTINCT FROM OLD.outcome OR\r\n         NEW.completed = true AND (OLD.completed = false OR OLD.completed IS NULL))\r\n    ) THEN\r\n        -- Get all players from this game\r\n        FOR player_record IN \r\n            SELECT DISTINCT player_id \r\n            FROM game_registrations \r\n            WHERE game_id = NEW.id \r\n            AND status = 'selected'\r\n        LOOP\r\n            -- Get the calculated win rate for this player\r\n            SELECT * INTO win_rate_data \r\n            FROM get_player_win_rates() \r\n            WHERE id = player_record.player_id;\r\n\r\n            -- Update the player's win rate\r\n            IF win_rate_data IS NOT NULL THEN\r\n                UPDATE players \r\n                SET win_rate = win_rate_data.win_rate\r\n                WHERE id = player_record.player_id;\r\n            END IF;\r\n        END LOOP;\r\n    END IF;\r\n    \r\n    RETURN NEW;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "trigger",
    "source_code": "\r\nDECLARE\r\n    player_record RECORD;\r\n    win_rate_data RECORD;\r\nBEGIN\r\n    -- When a game is completed or its outcome is changed\r\n    IF (TG_OP = 'UPDATE' AND \r\n        (NEW.outcome IS DISTINCT FROM OLD.outcome OR\r\n         NEW.completed = true AND (OLD.completed = false OR OLD.completed IS NULL))\r\n    ) THEN\r\n        -- Get all players from this game\r\n        FOR player_record IN \r\n            SELECT DISTINCT player_id \r\n            FROM game_registrations \r\n            WHERE game_id = NEW.id \r\n            AND status = 'selected'\r\n        LOOP\r\n            -- Get the calculated win rate for this player\r\n            SELECT * INTO win_rate_data \r\n            FROM get_player_win_rates() \r\n            WHERE id = player_record.player_id;\r\n\r\n            -- Update the player's win rate\r\n            IF win_rate_data IS NOT NULL THEN\r\n                UPDATE players \r\n                SET win_rate = win_rate_data.win_rate\r\n                WHERE id = player_record.player_id;\r\n            END IF;\r\n        END LOOP;\r\n    END IF;\r\n    \r\n    RETURN NEW;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": true
  },
  {
    "function_name": "update_player_xp",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_player_xp()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- When a game is marked as completed\r\n    IF (TG_OP = 'UPDATE' AND NEW.completed = true AND (OLD.completed = false OR OLD.completed IS NULL)) THEN\r\n        -- Update XP for all players who participated in this game\r\n        INSERT INTO player_xp (player_id, xp, last_calculated)\r\n        SELECT \r\n            gr.player_id,\r\n            calculate_player_xp(gr.player_id),\r\n            CURRENT_TIMESTAMP\r\n        FROM game_registrations gr\r\n        WHERE gr.game_id = NEW.id\r\n        ON CONFLICT (player_id) DO UPDATE\r\n        SET \r\n            xp = EXCLUDED.xp,\r\n            last_calculated = EXCLUDED.last_calculated;\r\n    END IF;\r\n    RETURN NEW;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "trigger",
    "source_code": "\r\nBEGIN\r\n    -- When a game is marked as completed\r\n    IF (TG_OP = 'UPDATE' AND NEW.completed = true AND (OLD.completed = false OR OLD.completed IS NULL)) THEN\r\n        -- Update XP for all players who participated in this game\r\n        INSERT INTO player_xp (player_id, xp, last_calculated)\r\n        SELECT \r\n            gr.player_id,\r\n            calculate_player_xp(gr.player_id),\r\n            CURRENT_TIMESTAMP\r\n        FROM game_registrations gr\r\n        WHERE gr.game_id = NEW.id\r\n        ON CONFLICT (player_id) DO UPDATE\r\n        SET \r\n            xp = EXCLUDED.xp,\r\n            last_calculated = EXCLUDED.last_calculated;\r\n    END IF;\r\n    RETURN NEW;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "update_rarity_on_xp_change",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_rarity_on_xp_change()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  IF TG_OP = 'UPDATE' AND NEW.xp <> OLD.xp THEN\r\n    PERFORM calculate_player_rarity();\r\n  ELSIF TG_OP = 'INSERT' THEN\r\n    PERFORM calculate_player_rarity();\r\n  END IF;\r\n  RETURN NEW;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "trigger",
    "source_code": "\r\nBEGIN\r\n  IF TG_OP = 'UPDATE' AND NEW.xp <> OLD.xp THEN\r\n    PERFORM calculate_player_rarity();\r\n  ELSIF TG_OP = 'INSERT' THEN\r\n    PERFORM calculate_player_rarity();\r\n  END IF;\r\n  RETURN NEW;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "update_streaks_on_game_change",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_streaks_on_game_change()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- Update attendance streaks\r\n    WITH player_streaks AS (\r\n        SELECT \r\n            p.id as player_id,\r\n            COUNT(*) as streak\r\n        FROM players p\r\n        JOIN game_registrations gr ON gr.player_id = p.id\r\n        JOIN games g ON g.id = gr.game_id\r\n        WHERE gr.status = 'selected'\r\n        AND g.completed = true\r\n        AND NOT EXISTS (\r\n            SELECT 1\r\n            FROM games g2\r\n            LEFT JOIN game_registrations gr2 ON gr2.game_id = g2.id AND gr2.player_id = p.id\r\n            WHERE g2.sequence_number > g.sequence_number\r\n            AND g2.completed = true\r\n            AND (gr2.id IS NULL OR gr2.status != 'selected')\r\n        )\r\n        GROUP BY p.id\r\n    )\r\n    UPDATE players p\r\n    SET current_streak = COALESCE(ps.streak, 0)\r\n    FROM player_streaks ps\r\n    WHERE p.id = ps.player_id;\r\n\r\n    -- Update bench warmer streaks\r\n    WITH bench_streaks AS (\r\n        SELECT \r\n            p.id as player_id,\r\n            COUNT(*) as streak\r\n        FROM players p\r\n        JOIN game_registrations gr ON gr.player_id = p.id\r\n        JOIN games g ON g.id = gr.game_id\r\n        WHERE gr.status = 'reserve'\r\n        AND g.completed = true\r\n        AND NOT EXISTS (\r\n            SELECT 1\r\n            FROM games g2\r\n            LEFT JOIN game_registrations gr2 ON gr2.game_id = g2.id AND gr2.player_id = p.id\r\n            WHERE g2.sequence_number > g.sequence_number\r\n            AND g2.completed = true\r\n            AND (gr2.id IS NULL OR gr2.status != 'reserve')\r\n        )\r\n        GROUP BY p.id\r\n    )\r\n    UPDATE players p\r\n    SET bench_warmer_streak = COALESCE(bs.streak, 0)\r\n    FROM bench_streaks bs\r\n    WHERE p.id = bs.player_id;\r\n\r\n    -- The XP will be automatically recalculated by our existing XP trigger\r\n    RETURN NULL;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "trigger",
    "source_code": "\r\nBEGIN\r\n    -- Update attendance streaks\r\n    WITH player_streaks AS (\r\n        SELECT \r\n            p.id as player_id,\r\n            COUNT(*) as streak\r\n        FROM players p\r\n        JOIN game_registrations gr ON gr.player_id = p.id\r\n        JOIN games g ON g.id = gr.game_id\r\n        WHERE gr.status = 'selected'\r\n        AND g.completed = true\r\n        AND NOT EXISTS (\r\n            SELECT 1\r\n            FROM games g2\r\n            LEFT JOIN game_registrations gr2 ON gr2.game_id = g2.id AND gr2.player_id = p.id\r\n            WHERE g2.sequence_number > g.sequence_number\r\n            AND g2.completed = true\r\n            AND (gr2.id IS NULL OR gr2.status != 'selected')\r\n        )\r\n        GROUP BY p.id\r\n    )\r\n    UPDATE players p\r\n    SET current_streak = COALESCE(ps.streak, 0)\r\n    FROM player_streaks ps\r\n    WHERE p.id = ps.player_id;\r\n\r\n    -- Update bench warmer streaks\r\n    WITH bench_streaks AS (\r\n        SELECT \r\n            p.id as player_id,\r\n            COUNT(*) as streak\r\n        FROM players p\r\n        JOIN game_registrations gr ON gr.player_id = p.id\r\n        JOIN games g ON g.id = gr.game_id\r\n        WHERE gr.status = 'reserve'\r\n        AND g.completed = true\r\n        AND NOT EXISTS (\r\n            SELECT 1\r\n            FROM games g2\r\n            LEFT JOIN game_registrations gr2 ON gr2.game_id = g2.id AND gr2.player_id = p.id\r\n            WHERE g2.sequence_number > g.sequence_number\r\n            AND g2.completed = true\r\n            AND (gr2.id IS NULL OR gr2.status != 'reserve')\r\n        )\r\n        GROUP BY p.id\r\n    )\r\n    UPDATE players p\r\n    SET bench_warmer_streak = COALESCE(bs.streak, 0)\r\n    FROM bench_streaks bs\r\n    WHERE p.id = bs.player_id;\r\n\r\n    -- The XP will be automatically recalculated by our existing XP trigger\r\n    RETURN NULL;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "update_streaks_on_game_completion",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_streaks_on_game_completion()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- When a game is marked as completed\r\n    IF (TG_OP = 'UPDATE' AND NEW.completed = true AND (OLD.completed = false OR OLD.completed IS NULL)) THEN\r\n        -- Update streaks for all players in this game\r\n        UPDATE players p\r\n        SET \r\n            current_streak = calculate_player_streak(p.id),\r\n            bench_warmer_streak = calculate_bench_warmer_streak(p.id)\r\n        FROM game_registrations gr\r\n        WHERE gr.game_id = NEW.id \r\n        AND gr.player_id = p.id;\r\n    END IF;\r\n    \r\n    RETURN NEW;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "trigger",
    "source_code": "\r\nBEGIN\r\n    -- When a game is marked as completed\r\n    IF (TG_OP = 'UPDATE' AND NEW.completed = true AND (OLD.completed = false OR OLD.completed IS NULL)) THEN\r\n        -- Update streaks for all players in this game\r\n        UPDATE players p\r\n        SET \r\n            current_streak = calculate_player_streak(p.id),\r\n            bench_warmer_streak = calculate_bench_warmer_streak(p.id)\r\n        FROM game_registrations gr\r\n        WHERE gr.game_id = NEW.id \r\n        AND gr.player_id = p.id;\r\n    END IF;\r\n    \r\n    RETURN NEW;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "update_team_assignments",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_team_assignments(p_game_id uuid, p_blue_team uuid[], p_orange_team uuid[], p_team_assignments jsonb, p_total_differential numeric, p_attack_differential numeric, p_defense_differential numeric)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\ndeclare\r\n  v_current_status text;\r\nbegin\r\n  -- First check the current game status\r\n  select status into v_current_status\r\n  from games\r\n  where id = p_game_id;\r\n\r\n  -- Only proceed if status is correct\r\n  if v_current_status != 'players_announced' then\r\n    return false;\r\n  end if;\r\n\r\n  -- Update blue team registrations\r\n  update game_registrations\r\n  set team = 'blue'\r\n  where game_id = p_game_id\r\n  and player_id = any(p_blue_team);\r\n\r\n  -- Update orange team registrations\r\n  update game_registrations\r\n  set team = 'orange'\r\n  where game_id = p_game_id\r\n  and player_id = any(p_orange_team);\r\n\r\n  -- Update or insert balanced team assignments\r\n  insert into balanced_team_assignments (\r\n    game_id,\r\n    team_assignments,\r\n    total_differential,\r\n    attack_differential,\r\n    defense_differential\r\n  )\r\n  values (\r\n    p_game_id,\r\n    p_team_assignments,\r\n    p_total_differential,\r\n    p_attack_differential,\r\n    p_defense_differential\r\n  )\r\n  on conflict (game_id)\r\n  do update set\r\n    team_assignments = excluded.team_assignments,\r\n    total_differential = excluded.total_differential,\r\n    attack_differential = excluded.attack_differential,\r\n    defense_differential = excluded.defense_differential;\r\n\r\n  -- Update game status\r\n  update games\r\n  set \r\n    status = 'teams_announced',\r\n    teams_announced = true\r\n  where id = p_game_id\r\n  and status = 'players_announced';\r\n\r\n  return true;\r\nexception\r\n  when others then\r\n    -- Log the error (optional, depending on your needs)\r\n    raise notice 'Error in update_team_assignments: %', SQLERRM;\r\n    return false;\r\nend;\r\n$function$\n",
    "function_description": null,
    "return_type": "boolean",
    "source_code": "\r\ndeclare\r\n  v_current_status text;\r\nbegin\r\n  -- First check the current game status\r\n  select status into v_current_status\r\n  from games\r\n  where id = p_game_id;\r\n\r\n  -- Only proceed if status is correct\r\n  if v_current_status != 'players_announced' then\r\n    return false;\r\n  end if;\r\n\r\n  -- Update blue team registrations\r\n  update game_registrations\r\n  set team = 'blue'\r\n  where game_id = p_game_id\r\n  and player_id = any(p_blue_team);\r\n\r\n  -- Update orange team registrations\r\n  update game_registrations\r\n  set team = 'orange'\r\n  where game_id = p_game_id\r\n  and player_id = any(p_orange_team);\r\n\r\n  -- Update or insert balanced team assignments\r\n  insert into balanced_team_assignments (\r\n    game_id,\r\n    team_assignments,\r\n    total_differential,\r\n    attack_differential,\r\n    defense_differential\r\n  )\r\n  values (\r\n    p_game_id,\r\n    p_team_assignments,\r\n    p_total_differential,\r\n    p_attack_differential,\r\n    p_defense_differential\r\n  )\r\n  on conflict (game_id)\r\n  do update set\r\n    team_assignments = excluded.team_assignments,\r\n    total_differential = excluded.total_differential,\r\n    attack_differential = excluded.attack_differential,\r\n    defense_differential = excluded.defense_differential;\r\n\r\n  -- Update game status\r\n  update games\r\n  set \r\n    status = 'teams_announced',\r\n    teams_announced = true\r\n  where id = p_game_id\r\n  and status = 'players_announced';\r\n\r\n  return true;\r\nexception\r\n  when others then\r\n    -- Log the error (optional, depending on your needs)\r\n    raise notice 'Error in update_team_assignments: %', SQLERRM;\r\n    return false;\r\nend;\r\n",
    "volatility": "v",
    "security_definer": true
  },
  {
    "function_name": "update_updated_at",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_updated_at()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    NEW.updated_at = CURRENT_TIMESTAMP;\r\n    RETURN NEW;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "trigger",
    "source_code": "\r\nBEGIN\r\n    NEW.updated_at = CURRENT_TIMESTAMP;\r\n    RETURN NEW;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "update_updated_at_column",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_updated_at_column()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    NEW.updated_at = CURRENT_TIMESTAMP;\r\n    RETURN NEW;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "trigger",
    "source_code": "\r\nBEGIN\r\n    NEW.updated_at = CURRENT_TIMESTAMP;\r\n    RETURN NEW;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "update_xp_on_streak_change",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_xp_on_streak_change()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- If bench_warmer_streak or current_streak has changed\r\n    IF (TG_OP = 'UPDATE' AND (\r\n        NEW.bench_warmer_streak IS DISTINCT FROM OLD.bench_warmer_streak OR \r\n        NEW.current_streak IS DISTINCT FROM OLD.current_streak\r\n    )) THEN\r\n        -- Update player_xp table\r\n        INSERT INTO player_xp (player_id, xp, last_calculated)\r\n        VALUES (\r\n            NEW.id,\r\n            calculate_player_xp(NEW.id),\r\n            CURRENT_TIMESTAMP\r\n        )\r\n        ON CONFLICT (player_id) \r\n        DO UPDATE SET \r\n            xp = EXCLUDED.xp,\r\n            last_calculated = EXCLUDED.last_calculated;\r\n    END IF;\r\n    \r\n    RETURN NEW;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "trigger",
    "source_code": "\r\nBEGIN\r\n    -- If bench_warmer_streak or current_streak has changed\r\n    IF (TG_OP = 'UPDATE' AND (\r\n        NEW.bench_warmer_streak IS DISTINCT FROM OLD.bench_warmer_streak OR \r\n        NEW.current_streak IS DISTINCT FROM OLD.current_streak\r\n    )) THEN\r\n        -- Update player_xp table\r\n        INSERT INTO player_xp (player_id, xp, last_calculated)\r\n        VALUES (\r\n            NEW.id,\r\n            calculate_player_xp(NEW.id),\r\n            CURRENT_TIMESTAMP\r\n        )\r\n        ON CONFLICT (player_id) \r\n        DO UPDATE SET \r\n            xp = EXCLUDED.xp,\r\n            last_calculated = EXCLUDED.last_calculated;\r\n    END IF;\r\n    \r\n    RETURN NEW;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  },
  {
    "function_name": "void_other_slot_offers",
    "function_definition": "CREATE OR REPLACE FUNCTION public.void_other_slot_offers()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_selected_count INTEGER;\r\n    v_max_players INTEGER;\r\nBEGIN\r\n    -- If a slot offer is being accepted\r\n    IF NEW.status = 'accepted' AND (OLD.status IS NULL OR OLD.status != 'accepted') THEN\r\n        -- Get the current selected player count and add 1 for the current acceptance\r\n        SELECT COUNT(*) + 1 INTO v_selected_count\r\n        FROM game_registrations\r\n        WHERE game_id = NEW.game_id\r\n        AND status = 'selected';\r\n\r\n        -- Get max players for the game\r\n        SELECT max_players INTO v_max_players\r\n        FROM games\r\n        WHERE id = NEW.game_id;\r\n\r\n        -- Check if accepting would exceed max players\r\n        IF v_selected_count > v_max_players THEN\r\n            RAISE EXCEPTION 'Cannot accept offer: maximum players reached';\r\n        END IF;\r\n\r\n        -- Void all other pending offers for this game\r\n        UPDATE slot_offers\r\n        SET status = 'voided',\r\n            updated_at = NOW()\r\n        WHERE game_id = NEW.game_id\r\n        AND id != NEW.id\r\n        AND status = 'pending';\r\n\r\n        -- Update the player's registration status to selected\r\n        UPDATE game_registrations\r\n        SET status = 'selected'\r\n        WHERE game_id = NEW.game_id\r\n        AND player_id = NEW.player_id;\r\n    END IF;\r\n    \r\n    RETURN NEW;\r\nEND;\r\n$function$\n",
    "function_description": null,
    "return_type": "trigger",
    "source_code": "\r\nDECLARE\r\n    v_selected_count INTEGER;\r\n    v_max_players INTEGER;\r\nBEGIN\r\n    -- If a slot offer is being accepted\r\n    IF NEW.status = 'accepted' AND (OLD.status IS NULL OR OLD.status != 'accepted') THEN\r\n        -- Get the current selected player count and add 1 for the current acceptance\r\n        SELECT COUNT(*) + 1 INTO v_selected_count\r\n        FROM game_registrations\r\n        WHERE game_id = NEW.game_id\r\n        AND status = 'selected';\r\n\r\n        -- Get max players for the game\r\n        SELECT max_players INTO v_max_players\r\n        FROM games\r\n        WHERE id = NEW.game_id;\r\n\r\n        -- Check if accepting would exceed max players\r\n        IF v_selected_count > v_max_players THEN\r\n            RAISE EXCEPTION 'Cannot accept offer: maximum players reached';\r\n        END IF;\r\n\r\n        -- Void all other pending offers for this game\r\n        UPDATE slot_offers\r\n        SET status = 'voided',\r\n            updated_at = NOW()\r\n        WHERE game_id = NEW.game_id\r\n        AND id != NEW.id\r\n        AND status = 'pending';\r\n\r\n        -- Update the player's registration status to selected\r\n        UPDATE game_registrations\r\n        SET status = 'selected'\r\n        WHERE game_id = NEW.game_id\r\n        AND player_id = NEW.player_id;\r\n    END IF;\r\n    \r\n    RETURN NEW;\r\nEND;\r\n",
    "volatility": "v",
    "security_definer": false
  }
]