import {
  TeamAssignment,
  PositionType,
  PositionWeights,
  PlayerPositionAssignment,
  FormationTemplate,
  FormationSuggestion,
  FormationResult
} from '../../components/admin/team-balancing/types';
import { findBestMatchingPlaystyle, PlaystyleWeights, PLAYSTYLE_DEFINITIONS } from './playstyleDefinitions';

/**
 * Enhanced position weight configurations using all 6 attributes
 * These weights determine how important each attribute is for a given position
 */
interface EnhancedPositionWeights extends PositionWeights {
  pace: number;
  shooting: number;
  passing: number;
  dribbling: number;
  defending: number;
  physical: number;
}

const ENHANCED_POSITION_WEIGHTS: Record<PositionType, EnhancedPositionWeights> = {
  ST: {
    attack: 0.10,
    defense: 0.02,
    gameIq: 0.08,
    shooting: 0.35,
    pace: 0.25,
    dribbling: 0.20,
    physical: 0.10,
    passing: 0.00,
    defending: 0.00
  },
  W: {
    attack: 0.08,
    defense: 0.05,
    gameIq: 0.07,
    pace: 0.35,
    dribbling: 0.30,
    passing: 0.20,
    shooting: 0.15,
    defending: 0.00,
    physical: 0.00
  },
  WB: {
    attack: 0.05,
    defense: 0.08,
    gameIq: 0.07,
    defending: 0.30,
    pace: 0.25,
    physical: 0.20,
    passing: 0.15,
    dribbling: 0.10,
    shooting: 0.00
  },
  CAM: {
    attack: 0.08,
    defense: 0.02,
    gameIq: 0.10,
    passing: 0.35,
    dribbling: 0.25,
    shooting: 0.20,
    pace: 0.10,
    defending: 0.00,
    physical: 0.00
  },
  CM: {
    attack: 0.06,
    defense: 0.06,
    gameIq: 0.08,
    passing: 0.30,
    physical: 0.25,
    defending: 0.25,
    dribbling: 0.10,
    pace: 0.05,
    shooting: 0.05
  },
  CDM: {
    attack: 0.03,
    defense: 0.09,
    gameIq: 0.08,
    defending: 0.35,
    physical: 0.30,
    passing: 0.20,
    pace: 0.10,
    dribbling: 0.05,
    shooting: 0.00
  },
  DEF: {
    attack: 0.02,
    defense: 0.10,
    gameIq: 0.08,
    defending: 0.40,
    physical: 0.30,
    pace: 0.20,
    passing: 0.10,
    dribbling: 0.00,
    shooting: 0.00
  }
};

/**
 * Map of playstyle IDs to their names (from database)
 * These are the predefined playstyles from the playstyles table
 */
const PLAYSTYLE_ID_TO_NAME: Record<string, string> = {
  // Attacking (all 19 from database)
  '63d39f4f-fa86-45df-b460-1646ae883e6b': 'Ace',
  '6d76cd60-fed9-4acf-9955-9d3e5f291899': 'Attacker',
  '805eda95-b70f-45c6-98e8-6a6a0ee9a62b': 'Deadeye',
  'eeae4c3e-d006-4d48-addc-df55b69a369d': 'Dribbler',
  'b0f29c12-db18-4ae6-9d76-51f47240b3fe': 'Finisher',
  'defb5e68-7dae-45a1-af76-9f25dc1f60e9': 'Forward',
  '14bed117-fe73-494d-b600-022d4a7b06de': 'Genius',
  '0d6622ab-b07f-4b57-bf43-d41b37b2fc9f': 'Hawk',
  '3b6c8e35-aff2-4e0b-8f9d-70f2cd561c1b': 'Hunter',
  '8e89a996-1c15-4876-a4dc-deabfadc465e': 'Magician',
  '625e3030-e57c-411f-bf58-6bc85486a5f2': 'Marksman',
  '26cc03a3-bde7-4e6d-b822-d8affbedc03d': 'Phenomenon',
  '70a2c1a4-4d22-411c-86b9-2c13fc301251': 'Poacher',
  '88dde498-6f3d-4354-892a-422d7b9ec1e8': 'Predator',
  'd8c868b9-04b5-43cc-b1ae-e740f783788f': 'Shooter',
  '95619cd5-caf6-401f-9aec-dc6f24f1767f': 'Sniper',
  'd5c54379-4229-4305-9728-d84508c83073': 'Speedster',
  '8b72a3a3-0420-4a50-94f7-072b048fdd67': 'Striker',
  '1a01bec7-b944-4709-ac8e-b37a5ecc610d': 'Target Man',

  // Midfield (all 24 from database)
  '4870d6fd-f6ee-4fab-8337-551eb0e97bc8': 'All-Rounder',
  '29ab3d96-d6d9-40ea-8dac-0b34e0008aac': 'Architect',
  'a74e47ef-9663-4b8d-9483-22838d11207c': 'Artist',
  'fdd48802-dc17-4a1c-a0c7-44f123db5e1b': 'Box-to-Box',
  '7f04ab71-4bee-4c6e-820e-b1aff2a7785e': 'Captain',
  '8aa5db61-1b0f-4376-bad0-a7508e93b849': 'Catalyst',
  'c4c89505-04c0-4f62-9686-2452cdf13256': 'Conductor',
  '341d3deb-b40c-43a2-bb43-70d2ee78ce1b': 'Dynamo',
  'ee15bfff-7911-4a1b-ae70-661569c4dcbe': 'Enforcer',
  '45c223d7-3de7-46f1-af30-9861fd26137b': 'Engine',
  'c6716b40-6050-41b7-a78b-9a4b0d4b06f2': 'Leader',
  '33f73992-1115-4f94-a141-b666424239ed': 'Legend',
  '8c828370-ac09-4350-864f-aebc4bee6272': 'Locomotive',
  'f50d01df-1901-4887-89b6-7a8c228aae1e': 'Maestro',
  '628bb7d6-cf26-4ee4-944c-2b87afa40302': 'Mastermind',
  '74173611-c766-4a66-8fef-3e8efad27197': 'Orchestrator',
  '8f076a5e-18b5-4601-b57d-9f984622a7ea': 'Playmaker',
  '5a1e237b-e747-4bce-bf94-6e5f2c9e2f2d': 'Powerhouse',
  '6553224c-8499-4d7c-8c23-fe00cff0b826': 'Powerplayer',
  '2409d027-8339-4335-9330-c9f84883a7dc': 'Regista',
  'f3796f78-a832-4496-afff-17a16567a0d6': 'Sprinter',
  'b392ef95-9aa0-4f84-ae55-77a38f80d74e': 'Tactician',
  'a9b381e7-8d2d-4a5a-a044-a0e6f7daea6f': 'Technician',
  '185e04c6-3016-452c-b4f6-f27a699ab949': 'Virtuoso',

  // Defensive (all 20 from database)
  'c99e86bc-a30d-49a7-b709-4f2e99836ba1': 'Anchor',
  '06794967-d4cb-4b4f-8f08-e6f1591cec83': 'Backbone',
  '7b7816be-39df-41b8-9893-25d24bf85322': 'Ball Winner',
  '60390bb3-be73-4836-98d8-bc55cd1e9598': 'Commander',
  'fabe8865-ad30-4d00-b17f-baa7afba10a6': 'Defender',
  'b76b4f0c-07f0-402f-8828-f00a4534cbb5': 'Destroyer',
  '31ce58fc-dd22-4390-b6c1-f75d6364c7ad': 'General',
  '60dfeae6-1f4d-44dd-82e7-4becf13b9a8d': 'Gladiator',
  '6dcb1d90-3996-4372-b98b-8b2a9cf837ef': 'Guardian',
  '1bcee34a-bbc0-4291-bba1-f3dbbea9aacf': 'Interceptor',
  '864ee073-b38f-4f0b-b609-35ca655479c6': 'Libero',
  'e205a70d-354b-4afc-a717-d74251c93aae': 'Machine',
  '68220d0a-793f-46e1-b023-7041ac496001': 'Sentinel',
  '38298184-9fdb-44fe-855b-85846fd44676': 'Shadow',
  'f7889b1a-85e7-4ca0-8b9c-430e04e82c6d': 'Stopper',
  'fd8753fe-4e6f-45ac-a58b-f277b3ea6177': 'Sweeper',
  '0abf8256-d4a0-4a98-82e7-7cac9cd787f6': 'Tank',
  '5b68e96e-8a64-4d87-a4e3-7eaf33c27151': 'Terminator',
  '3b3b4b82-484d-47c7-9982-6308280e0d16': 'Titan',
  '97d0a665-8b50-466d-816d-376ce38423c1': 'Warrior'
};

/**
 * Playstyle to ideal positions mapping
 */
const PLAYSTYLE_IDEAL_POSITIONS: Record<string, PositionType[]> = {
  // Attacking styles
  'Ace': ['ST', 'CAM'],
  'Attacker': ['ST', 'W'],
  'Complete Forward': ['ST'],
  'Deadeye': ['CAM', 'CM'],
  'Dribbler': ['W', 'CAM'],
  'Finisher': ['ST'],
  'Forward': ['ST'],
  'Genius': ['CAM', 'ST'],
  'Hawk': ['ST'],
  'Hunter': ['ST', 'W'],
  'Magician': ['CAM', 'W'],
  'Marksman': ['ST', 'CAM'],
  'Phenomenon': ['ST', 'CAM'],
  'Poacher': ['ST'],
  'Predator': ['ST', 'W'],
  'Shooter': ['ST'],
  'Sniper': ['CAM', 'ST'],
  'Speedster': ['W', 'ST'],
  'Striker': ['ST'],
  'Target Man': ['ST'],

  // Midfield styles
  'All-Rounder': ['CM', 'CAM', 'CDM'],
  'Architect': ['CDM', 'CM'],
  'Artist': ['CAM', 'CM'],
  'Box-to-Box': ['CM', 'CDM'],
  'Captain': ['CM', 'CDM'],
  'Catalyst': ['CM', 'W'],
  'Conductor': ['CM', 'CAM'],
  'Dynamo': ['CM', 'W'],
  'Enforcer': ['CDM', 'CM'],
  'Engine': ['CM', 'W', 'CAM'],
  'Leader': ['CM', 'CDM'],
  'Legend': ['CM', 'CAM', 'CDM'],
  'Locomotive': ['CM', 'CDM'],
  'Maestro': ['CAM'],
  'Mastermind': ['CAM', 'CM'],
  'Orchestrator': ['CAM', 'CM'],
  'Playmaker': ['CAM', 'CM'],
  'Powerhouse': ['CDM', 'CM'],
  'Powerplayer': ['CDM', 'CM'],
  'Regista': ['CDM', 'CM'],
  'Sprinter': ['W', 'CM'],
  'Tactician': ['CM', 'CDM'],
  'Technician': ['CAM', 'CM'],
  'Virtuoso': ['CAM', 'CM'],

  // Defensive styles
  'Anchor': ['DEF', 'CDM'],
  'Backbone': ['CDM', 'DEF'],
  'Ball Winner': ['CDM', 'DEF'],
  'Commander': ['DEF', 'CDM'],
  'Complete Defender': ['DEF'],
  'Defender': ['DEF'],
  'Destroyer': ['CDM', 'DEF'],
  'General': ['DEF', 'CDM', 'WB'],
  'Gladiator': ['DEF', 'WB'],
  'Guardian': ['DEF', 'WB'],
  'Interceptor': ['DEF', 'CDM', 'WB'],
  'Libero': ['DEF', 'CDM'],
  'Machine': ['CDM', 'DEF'],
  'Sentinel': ['DEF', 'CDM'],
  'Shadow': ['DEF', 'CDM'],
  'Stopper': ['DEF'],
  'Sweeper': ['DEF'],
  'Tank': ['DEF', 'CDM'],
  'Terminator': ['DEF', 'CDM'],
  'Titan': ['DEF'],
  'Warrior': ['DEF', 'CDM'],

  // Balanced/Versatile styles
  'Versatile': ['CM', 'W', 'CDM'], // Multiple high attributes - adaptable player
  'Complete Player': ['CM', 'CAM', 'CDM']
};

/**
 * Calculate statistics for player attributes
 */
interface AttributeStats {
  mean: number;
  stdDev: number;
  percentiles: {
    p10: number;
    p25: number;
    p50: number;
    p75: number;
    p90: number;
  };
}

function calculateAttributeStats(values: number[]): AttributeStats {
  if (values.length === 0) {
    return {
      mean: 0.5,
      stdDev: 0.2,
      percentiles: { p10: 0.1, p25: 0.25, p50: 0.5, p75: 0.75, p90: 0.9 }
    };
  }

  const sorted = [...values].sort((a, b) => a - b);
  const n = values.length;

  const mean = values.reduce((sum, v) => sum + v, 0) / n;
  const variance = values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / n;
  const stdDev = Math.sqrt(variance);

  const getPercentile = (p: number) => {
    const index = (p / 100) * (n - 1);
    const lower = Math.floor(index);
    const upper = Math.ceil(index);
    const weight = index % 1;
    return sorted[lower] * (1 - weight) + sorted[upper] * weight;
  };

  return {
    mean,
    stdDev: stdDev || 0.2, // Prevent zero std dev
    percentiles: {
      p10: getPercentile(10),
      p25: getPercentile(25),
      p50: getPercentile(50),
      p75: getPercentile(75),
      p90: getPercentile(90)
    }
  };
}

/**
 * Calculate relative position requirements based on player pool
 */
interface RelativeRequirements {
  pace: AttributeStats;
  shooting: AttributeStats;
  passing: AttributeStats;
  dribbling: AttributeStats;
  defending: AttributeStats;
  physical: AttributeStats;
}

function calculateRelativeRequirements(players: TeamAssignment[]): RelativeRequirements {
  const attributes = {
    pace: [] as number[],
    shooting: [] as number[],
    passing: [] as number[],
    dribbling: [] as number[],
    defending: [] as number[],
    physical: [] as number[]
  };

  players.forEach(player => {
    if (player.derived_attributes) {
      attributes.pace.push(player.derived_attributes.pace);
      attributes.shooting.push(player.derived_attributes.shooting);
      attributes.passing.push(player.derived_attributes.passing);
      attributes.dribbling.push(player.derived_attributes.dribbling);
      attributes.defending.push(player.derived_attributes.defending);
      attributes.physical.push(player.derived_attributes.physical);
    }
  });

  return {
    pace: calculateAttributeStats(attributes.pace),
    shooting: calculateAttributeStats(attributes.shooting),
    passing: calculateAttributeStats(attributes.passing),
    dribbling: calculateAttributeStats(attributes.dribbling),
    defending: calculateAttributeStats(attributes.defending),
    physical: calculateAttributeStats(attributes.physical)
  };
}

/**
 * Check if a player meets relative requirements for a position
 */
function meetsRelativeRequirements(
  player: TeamAssignment,
  position: PositionType,
  requirements: RelativeRequirements
): { meets: boolean; penalty: number; reasons: string[] } {
  if (!player.derived_attributes) {
    return { meets: true, penalty: 0, reasons: [] }; // No penalty if no attributes
  }

  const attrs = player.derived_attributes;
  const weights = ENHANCED_POSITION_WEIGHTS[position];
  let penalty = 0;
  const reasons: string[] = [];

  // Check critical attributes for each position (those with weight > 0.25)
  type AttrKey = 'pace' | 'shooting' | 'passing' | 'dribbling' | 'defending' | 'physical';
  const criticalChecks: Array<{ attr: AttrKey; weight: number; name: string }> = [];

  if (weights.pace > 0.25) criticalChecks.push({ attr: 'pace', weight: weights.pace, name: 'Pace' });
  if (weights.shooting > 0.25) criticalChecks.push({ attr: 'shooting', weight: weights.shooting, name: 'Shooting' });
  if (weights.passing > 0.25) criticalChecks.push({ attr: 'passing', weight: weights.passing, name: 'Passing' });
  if (weights.dribbling > 0.25) criticalChecks.push({ attr: 'dribbling', weight: weights.dribbling, name: 'Dribbling' });
  if (weights.defending > 0.25) criticalChecks.push({ attr: 'defending', weight: weights.defending, name: 'Defending' });
  if (weights.physical > 0.25) criticalChecks.push({ attr: 'physical', weight: weights.physical, name: 'Physical' });

  for (const check of criticalChecks) {
    const value = attrs[check.attr];
    const stats = requirements[check.attr];

    // If player is more than 1 std dev below mean in a critical attribute
    if (value < stats.mean - stats.stdDev) {
      penalty += check.weight * 2; // Double the weight as penalty
      reasons.push(`${check.name} too low (${value.toFixed(2)} vs avg ${stats.mean.toFixed(2)})`);
    }
    // If player is below 25th percentile in a critical attribute
    else if (value < stats.percentiles.p25) {
      penalty += check.weight;
      reasons.push(`Below average ${check.name}`);
    }
  }

  return {
    meets: penalty < 0.5, // Allow some flexibility
    penalty,
    reasons
  };
}

/**
 * Classify an attribute value as 'high', 'medium', or 'low' relative to the player pool
 */
function getRelativeClassification(value: number, stats: AttributeStats): 'high' | 'medium' | 'low' {
  // High: Above 75th percentile (top 25% of players)
  if (value >= stats.percentiles.p75) {
    return 'high';
  }

  // Low: Below 25th percentile (bottom 25% of players)
  if (value <= stats.percentiles.p25) {
    return 'low';
  }

  // Medium: Middle 50% of players
  return 'medium';
}

/**
 * Get ideal positions based on player's actual ratings (override playstyle when appropriate)
 */
function getRatingBasedIdealPositions(player: TeamAssignment): PositionType[] {
  const attack = player.attack_rating ?? 5;
  const defense = player.defense_rating ?? 5;
  const gameIq = player.game_iq_rating ?? 5;
  const attrs = player.derived_attributes;

  const positions: PositionType[] = [];

  // Strong defensive orientation
  if (defense > attack + 1.0) {
    positions.push('DEF');
    if (defense > 6.5 && gameIq > 6.0) positions.push('CDM');
    // Wingback: defensive player with pace
    if (attrs?.pace > 0.6 && (attrs?.defending > 0.3 || defense > 5.5)) {
      positions.push('WB');
    }
  }
  // Strong attacking orientation
  else if (attack > defense + 1.0) {
    if (attrs?.shooting > 0.7) positions.push('ST');
    if (attack > 6.5 && gameIq > 6.0) positions.push('CAM');
    // Winger: attacking player with pace (must have attack > defense)
    if (attrs?.pace > 0.7 && (attrs?.shooting > 0.4 || attrs?.dribbling > 0.6)) {
      positions.push('W');
    }
  }
  // Balanced player
  else if (Math.abs(attack - defense) < 1.0 && gameIq > 6.5) {
    positions.push('CM');
    if (defense > 6.0) positions.push('CDM');
    if (attack > 6.0) positions.push('CAM');
    // Balanced player with pace could be wingback
    if (attrs?.pace > 0.7 && defense > 5.0) {
      positions.push('WB');
    }
  }

  // Add position based on specific attributes
  if (attrs) {
    if (attrs.defending > 0.7 && defense >= attack && !positions.includes('DEF')) positions.push('DEF');
    if (attrs.shooting > 0.7 && attack > defense && !positions.includes('ST')) positions.push('ST');
    if (attrs.passing > 0.8 && gameIq > 6.5 && !positions.includes('CM')) positions.push('CM');
    // Only suggest W if attacking, only suggest WB if defensive
    if (attrs.pace > 0.8) {
      if (attack > defense && !positions.includes('W')) positions.push('W');
      if (defense >= attack && !positions.includes('WB')) positions.push('WB');
    }
  }
  // High Game IQ players (8.0+) are natural fits for central positions
  if (gameIq >= 8.0) {
    // Exceptional tactical intelligence means they excel in orchestrating play
    if (!positions.includes('CM')) positions.push('CM');
    if (gameIq >= 8.5 && !positions.includes('CDM')) positions.push('CDM'); // Can read defensive play
    if (gameIq >= 9.0 && !positions.includes('CAM')) positions.push('CAM'); // Elite playmaker

    // Remove wide positions for high IQ players if they were added
    // Their tactical intelligence is better utilized centrally
    const wIndex = positions.indexOf('W');
    if (wIndex > -1) positions.splice(wIndex, 1);
    const wbIndex = positions.indexOf('WB');
    if (wbIndex > -1) positions.splice(wbIndex, 1);
  }

  return positions;
}

/**
 * Detect playstyle for a player using similarity-based matching
 * This finds the best match among all 65 predefined playstyles based on actual averaged attributes
 */
function detectPlaystyleForPlayer(
  player: TeamAssignment,
  requirements: RelativeRequirements
): string | null {
  if (!player.derived_attributes) {
    return null;
  }

  const attrs = player.derived_attributes;

  // Convert player attributes to weights object for similarity calculation
  const playerWeights: PlaystyleWeights = {
    pace: attrs.pace,
    shooting: attrs.shooting,
    passing: attrs.passing,
    dribbling: attrs.dribbling,
    defending: attrs.defending,
    physical: attrs.physical
  };

  // Find the best matching playstyle based on actual averaged attributes
  // Using 0.3 (30%) as minimum similarity threshold
  const match = findBestMatchingPlaystyle(playerWeights, 0.3);

  if (match) {
    // Store the match confidence for debugging (optional)
    (player as any).__playstyleSimilarity = match.similarity;
    return match.playstyle.name;
  }

  // If no good match (very rare), fall back to relative detection
  return detectPlaystyleFromAttributesRelative(attrs, requirements);
}

/**
 * Detect playstyle from attributes with fuzzy matching tolerance
 */
function detectPlaystyleFromAttributesWithFuzzyMatch(
  attrs: NonNullable<TeamAssignment['derived_attributes']>,
  requirements: RelativeRequirements,
  tolerance: number = 0.15
): string | null {
  // Try exact predefined playstyle matches with tolerance
  const predefinedMatches: Array<{name: string, diff: number}> = [];

  // Check Hunter: Pace + Shooting
  const hunterDiff = Math.abs((attrs.pace + attrs.shooting) - 2.0);
  if (hunterDiff <= tolerance * 2) predefinedMatches.push({name: 'Hunter', diff: hunterDiff});

  // Check Engine: Pace + Passing + Dribbling
  const engineDiff = Math.abs((attrs.pace + attrs.passing + attrs.dribbling) - 3.0);
  if (engineDiff <= tolerance * 3) predefinedMatches.push({name: 'Engine', diff: engineDiff});

  // Check Sentinel: Defending + Physical
  const sentinelDiff = Math.abs((attrs.defending + attrs.physical) - 2.0);
  if (sentinelDiff <= tolerance * 2) predefinedMatches.push({name: 'Sentinel', diff: sentinelDiff});

  // Check Powerhouse: Passing + Defending
  const powerhouseDiff = Math.abs((attrs.passing + attrs.defending) - 2.0);
  if (powerhouseDiff <= tolerance * 2) predefinedMatches.push({name: 'Powerhouse', diff: powerhouseDiff});

  // Check Finisher: Shooting + Physical
  const finisherDiff = Math.abs((attrs.shooting + attrs.physical) - 2.0);
  if (finisherDiff <= tolerance * 2) predefinedMatches.push({name: 'Finisher', diff: finisherDiff});

  // Check Speedster: Pace + Dribbling
  const speedsterDiff = Math.abs((attrs.pace + attrs.dribbling) - 2.0);
  if (speedsterDiff <= tolerance * 2) predefinedMatches.push({name: 'Speedster', diff: speedsterDiff});

  // Return best fuzzy match if found
  if (predefinedMatches.length > 0) {
    predefinedMatches.sort((a, b) => a.diff - b.diff);
    return predefinedMatches[0].name;
  }

  // Fall back to relative classification method
  return detectPlaystyleFromAttributesRelative(attrs, requirements);
}

/**
 * Detect playstyle from attributes using relative comparisons to player pool
 */
function detectPlaystyleFromAttributesRelative(
  attrs: NonNullable<TeamAssignment['derived_attributes']>,
  requirements: RelativeRequirements
): string | null {
  // Calculate relative classifications for this player
  const classifications = {
    pace: getRelativeClassification(attrs.pace, requirements.pace),
    shooting: getRelativeClassification(attrs.shooting, requirements.shooting),
    passing: getRelativeClassification(attrs.passing, requirements.passing),
    dribbling: getRelativeClassification(attrs.dribbling, requirements.dribbling),
    defending: getRelativeClassification(attrs.defending, requirements.defending),
    physical: getRelativeClassification(attrs.physical, requirements.physical)
  };

  // Complete players (most attributes are high relative to pool)
  const highCount = Object.values(classifications).filter(c => c === 'high').length;
  if (highCount >= 5) {
    return 'Complete Player';
  }

  // Extract boolean flags for readability
  const pace = classifications.pace !== 'low';
  const shooting = classifications.shooting !== 'low';
  const passing = classifications.passing !== 'low';
  const dribbling = classifications.dribbling !== 'low';
  const defending = classifications.defending !== 'low';
  const physical = classifications.physical !== 'low';

  const highPace = classifications.pace === 'high';
  const highShooting = classifications.shooting === 'high';
  const highPassing = classifications.passing === 'high';
  const highDribbling = classifications.dribbling === 'high';
  const highDefending = classifications.defending === 'high';
  const highPhysical = classifications.physical === 'high';

  // Attacking playstyles (prioritize high attributes)
  if (highPace && highShooting) return 'Hunter';
  if (pace && shooting && physical) return 'Hawk';
  if (highShooting && dribbling && physical) return 'Marksman';
  if (highShooting && physical && !pace) return 'Finisher';
  if (shooting && highDribbling && !physical) return 'Sniper';
  if (shooting && highPassing && !dribbling) return 'Deadeye';
  if (highPace && highDribbling && !shooting) return 'Speedster';

  // Midfield playstyles
  if (highPassing && highDribbling && !shooting) return 'Artist';
  if (pace && passing && dribbling && !defending) return 'Engine';
  if (highPassing && physical && !shooting) return 'Architect';
  if (highPassing && defending) return 'Powerhouse';
  if (shooting && passing && dribbling) return 'Maestro';
  if (highPace && passing && !dribbling) return 'Catalyst';
  if (pace && highPhysical && !passing) return 'Locomotive';
  if (dribbling && highPhysical && !pace) return 'Enforcer';

  // Defensive playstyles
  if (pace && highDefending && !shooting) return 'Shadow';
  if (pace && highDefending && physical) return 'Anchor';
  if (shooting && defending) return 'Gladiator';
  if (dribbling && highDefending && !shooting) return 'Guardian';
  if (highDefending && highPhysical && !pace) return 'Sentinel';
  if (passing && highDefending && physical) return 'Backbone';

  // Check for dominant single attribute (must be 'high' relative to pool)
  const highAttributes = Object.entries(classifications)
    .filter(([_, classification]) => classification === 'high')
    .map(([attr, _]) => attr);

  if (highAttributes.length === 1) {
    // Single dominant attribute
    const dominantAttr = highAttributes[0];
    switch (dominantAttr) {
      case 'pace': return 'Speedster';
      case 'shooting': return 'Finisher';
      case 'passing': return 'Artist';
      case 'dribbling': return 'Artist';
      case 'defending': return 'Sentinel';
      case 'physical': return 'Enforcer';
    }
  }

  // Multiple balanced high attributes - create a compound classification
  if (highAttributes.length >= 2) {
    if (highAttributes.includes('pace') && highAttributes.includes('physical')) {
      return 'Locomotive';
    }
    if (highAttributes.includes('passing') && highAttributes.includes('defending')) {
      return 'Powerhouse';
    }
    if (highAttributes.includes('pace') && highAttributes.includes('dribbling')) {
      return 'Speedster';
    }
    // Default for multiple high attributes
    return 'Versatile';
  }

  return null;
}

/**
 * Score formations based on how many natural fits they would have
 */
function scoreFormationFit(
  team: TeamAssignment[],
  formation: FormationTemplate,
  requirements: RelativeRequirements
): { score: number; naturalFits: number; details: string } {
  // Track which players naturally fit which positions
  const playerPositionFits = new Map<string, { natural: PositionType[], adequate: PositionType[], flexibility: number }>();
  const positionCandidates: Record<PositionType, { natural: string[], adequate: string[] }> = {
    DEF: { natural: [], adequate: [] },
    WB: { natural: [], adequate: [] },
    W: { natural: [], adequate: [] },
    CDM: { natural: [], adequate: [] },
    CM: { natural: [], adequate: [] },
    CAM: { natural: [], adequate: [] },
    ST: { natural: [], adequate: [] }
  };

  // Analyze each player's position suitability
  team.forEach(player => {
    const natural: PositionType[] = [];
    const adequate: PositionType[] = [];

    // Check playstyle-based natural positions
    const playstyle = detectPlaystyleForPlayer(player, requirements);
    const idealPositions = playstyle ? PLAYSTYLE_IDEAL_POSITIONS[playstyle] || [] : [];

    // Check each position
    for (const position of Object.keys(ENHANCED_POSITION_WEIGHTS) as PositionType[]) {
      const check = meetsRelativeRequirements(player, position, requirements);

      if (idealPositions.includes(position)) {
        natural.push(position);
        positionCandidates[position].natural.push(player.player_id);
      } else if (check.meets) {
        adequate.push(position);
        positionCandidates[position].adequate.push(player.player_id);
      }
    }

    // Calculate flexibility score (how many positions they can play)
    const flexibility = natural.length + (adequate.length * 0.5);
    playerPositionFits.set(player.player_id, { natural, adequate, flexibility });
  });

  // Score the formation
  let naturalFits = 0;
  let adequateFits = 0;
  let forcedFits = 0;
  let totalScore = 0;
  const positionBreakdown: string[] = [];

  for (const [position, requiredCount] of Object.entries(formation.positions) as [PositionType, number][]) {
    if (requiredCount === 0) continue;

    const candidates = positionCandidates[position];
    const naturalCount = candidates.natural.length;
    const adequateCount = candidates.adequate.length;
    const totalAvailable = naturalCount + adequateCount;

    if (naturalCount >= requiredCount) {
      // All positions can be filled naturally
      naturalFits += requiredCount;
      totalScore += requiredCount * 10;
      positionBreakdown.push(`${position}:✓${requiredCount}`);
    } else if (totalAvailable >= requiredCount) {
      // Mix of natural and adequate fits
      naturalFits += naturalCount;
      adequateFits += (requiredCount - naturalCount);
      totalScore += naturalCount * 10 + (requiredCount - naturalCount) * 5;
      positionBreakdown.push(`${position}:⚠${naturalCount}+${requiredCount - naturalCount}`);
    } else {
      // Some positions will need forced assignments
      naturalFits += naturalCount;
      adequateFits += adequateCount;
      forcedFits += (requiredCount - totalAvailable);
      totalScore += naturalCount * 10 + adequateCount * 5 - (requiredCount - totalAvailable) * 5;
      positionBreakdown.push(`${position}:✗${totalAvailable}/${requiredCount}`);
    }
  }

  // Bonus for flexibility (players who can cover multiple needed positions)
  let flexibilityBonus = 0;
  let teamFlexibility = 0;
  playerPositionFits.forEach((fits, playerId) => {
    const usableNatural = fits.natural.filter(p => formation.positions[p] > 0);
    const usableAdequate = fits.adequate.filter(p => formation.positions[p] > 0);
    if (usableNatural.length > 1) {
      flexibilityBonus += (usableNatural.length - 1) * 3;
    } else if (usableNatural.length + usableAdequate.length > 1) {
      flexibilityBonus += (usableNatural.length + usableAdequate.length - 1);
    }
    teamFlexibility += fits.flexibility;
  });
  totalScore += flexibilityBonus;

  // Weight the score: 60% natural fits, 30% team composition, 10% flexibility
  const naturalFitScore = naturalFits * 10;
  const compositionScore = (team.length - forcedFits) * 5;
  const flexScore = teamFlexibility;
  totalScore = (naturalFitScore * 0.6) + (compositionScore * 0.3) + (flexScore * 0.1);

  const details = `N:${naturalFits} A:${adequateFits} F:${forcedFits} Flex:+${flexibilityBonus} [${positionBreakdown.join(' ')}]`;
  return {
    score: Math.max(0, totalScore),
    naturalFits,
    details
  };
}

/**
 * Try alternative formations with minor adjustments
 */
function tryFormationVariants(
  baseFormation: FormationTemplate,
  team: TeamAssignment[],
  requirements: RelativeRequirements
): FormationTemplate {
  // Check if we have natural CAMs who could benefit from a CAM position
  const naturalCAMs = team.filter(player => {
    const playstyle = detectPlaystyleForPlayer(player, requirements);
    const idealPositions = playstyle ? PLAYSTYLE_IDEAL_POSITIONS[playstyle] || [] : [];
    return idealPositions.includes('CAM');
  }).length;

  // If we have natural CAMs but formation has no CAM slot, try to adjust
  if (naturalCAMs > 0 && baseFormation.positions.CAM === 0 && baseFormation.positions.CM > 1) {
    // Try converting one CM to CAM
    const variant: FormationTemplate = {
      name: baseFormation.name.replace('-4-', '-3-1-').replace('-3-', '-2-1-'),
      positions: { ...baseFormation.positions },
      minPlayers: baseFormation.minPlayers,
      maxPlayers: baseFormation.maxPlayers
    };
    variant.positions.CM -= 1;
    variant.positions.CAM = 1;

    // Test if variant is better
    const baseScore = scoreFormationFit(team, baseFormation, requirements);
    const variantScore = scoreFormationFit(team, variant, requirements);

    if (variantScore.score > baseScore.score * 1.1) { // Needs 10% improvement to switch
      console.log(`Formation adjusted: ${baseFormation.name} → ${variant.name} (CAM added for natural fits)`);
      return variant;
    }
  }

  return baseFormation;
}

/**
 * Select best formation based on player pool
 */
function selectBestFormation(
  team: TeamAssignment[],
  requirements: RelativeRequirements
): FormationTemplate {
  const outfieldCount = team.length; // All players are outfield (rotating keeper)

  const validFormations = FORMATION_TEMPLATES.filter(
    f => outfieldCount >= f.minPlayers && outfieldCount <= f.maxPlayers
  );

  if (validFormations.length === 0) {
    return {
      name: 'Custom',
      positions: {
        DEF: Math.floor(outfieldCount * 0.35),
        WB: 0,
        W: 0,
        CDM: 1,
        CM: Math.floor(outfieldCount * 0.35),
        CAM: 0,
        ST: Math.max(1, Math.ceil(outfieldCount * 0.15))
      },
      minPlayers: outfieldCount,
      maxPlayers: outfieldCount
    };
  }

  // Count WB candidates
  const wbCandidates = team.filter(player => {
    const ratingBasedPos = getRatingBasedIdealPositions(player);
    const playstyle = detectPlaystyleForPlayer(player, requirements);
    const playstylePos = playstyle ? PLAYSTYLE_IDEAL_POSITIONS[playstyle] || [] : [];
    const idealPositions = [...new Set([...ratingBasedPos, ...playstylePos])];
    // WB requires minimum pace (0.4) to be considered a viable candidate
    if (idealPositions.includes('WB')) {
      const pace = player.derived_attributes?.pace ?? 0;
      return pace >= 0.4;
    }
    return false;
  }).length;

  // Count W candidates (attacking wingers)
  const wCandidates = team.filter(player => {
    const ratingBasedPos = getRatingBasedIdealPositions(player);
    const playstyle = detectPlaystyleForPlayer(player, requirements);
    const playstylePos = playstyle ? PLAYSTYLE_IDEAL_POSITIONS[playstyle] || [] : [];
    const idealPositions = [...new Set([...ratingBasedPos, ...playstylePos])];
    // W requires minimum pace (0.5) to be considered a viable candidate
    if (idealPositions.includes('W')) {
      const pace = player.derived_attributes?.pace ?? 0;
      return pace >= 0.5;
    }
    return false;
  }).length;
  // Count high Game IQ players (8.0+) who would excel in central positions
  const highIqCandidates = team.filter(player => {
    const gameIq = player.game_iq_rating ?? 5;
    return gameIq >= 8.0;
  }).length;

  // Prefer formations based on available candidates
  let formationsToScore = validFormations;

  // Prioritize formations based on player pool capabilities
  if (highIqCandidates >= 3) {
    // With many high IQ players, prefer central-heavy formations
    formationsToScore = [...validFormations].sort((a, b) => {
      const centralA = a.positions.CDM + a.positions.CM + a.positions.CAM;
      const centralB = b.positions.CDM + b.positions.CM + b.positions.CAM;
      return centralB - centralA; // Prefer more central positions
    });
  } else if (wbCandidates >= 2) {
    // Only prefer WB formations if we have enough viable candidates
    formationsToScore = [...validFormations].sort((a, b) => {
      if (a.positions.WB === 2 && b.positions.WB !== 2) return -1;
      if (b.positions.WB === 2 && a.positions.WB !== 2) return 1;
      return b.positions.WB - a.positions.WB;
    });
  } else if (wCandidates >= 2) {
    // Only prefer W formations if we have enough viable candidates
    formationsToScore = [...validFormations].sort((a, b) => {
      if (a.positions.W === 2 && b.positions.W !== 2) return -1;
      if (b.positions.W === 2 && a.positions.W !== 2) return 1;
      return b.positions.W - a.positions.W;
    });
  }

  // Score each formation
  let bestFormation = formationsToScore[0];
  let bestScore = -1;
  let bestDetails = '';

  for (const formation of formationsToScore) {
    const { score, naturalFits, details } = scoreFormationFit(team, formation, requirements);

    // Bonus for matching WB/W positions to candidates
    let bonusScore = score;
    if (wbCandidates >= 2 && formation.positions.WB === 2) {
      bonusScore *= 1.15; // 15% bonus for matching WB formation
    } else if (wCandidates >= 2 && formation.positions.W === 2) {
      bonusScore *= 1.1; // 10% bonus for matching W formation
    }
    // PENALTY for formations requiring more wide players than available
    if (formation.positions.WB > wbCandidates) {
      // Significant penalty for each missing WB candidate
      const deficit = formation.positions.WB - wbCandidates;
      bonusScore *= (1 - deficit * 0.15); // 15% penalty per missing WB
    }
    if (formation.positions.W > wCandidates) {
      // Significant penalty for each missing W candidate
      const deficit = formation.positions.W - wCandidates;
      bonusScore *= (1 - deficit * 0.15); // 15% penalty per missing W
    }
    // Bonus for formations with more central positions when high IQ players are available
    if (highIqCandidates >= 2) {
      const centralPositions = formation.positions.CDM + formation.positions.CM + formation.positions.CAM;
      const totalPositions = Object.values(formation.positions).reduce((a, b) => a + b, 0);
      const centralRatio = centralPositions / totalPositions;

      // Bonus increases with more central positions (up to 25% bonus)
      if (centralRatio > 0.4) {
        bonusScore *= 1 + (centralRatio * 0.25); // Up to 25% bonus for highly central formations
      }
    }

    if (bonusScore > bestScore) {
      bestScore = bonusScore;
      bestFormation = formation;
      bestDetails = details;
    }
  }

  console.log(`Selected formation ${bestFormation.name}: ${bestDetails} (WB candidates: ${wbCandidates}, W candidates: ${wCandidates}, High IQ: ${highIqCandidates})`);

  // Try formation variants for better fit
  const optimizedFormation = tryFormationVariants(bestFormation, team, requirements);

  return optimizedFormation;
}

/**
 * Formation templates
 */
const FORMATION_TEMPLATES: FormationTemplate[] = [
  // 7 player formations
  {
    name: '3-3-1',
    positions: { DEF: 3, WB: 0, W: 0, CDM: 1, CM: 2, CAM: 0, ST: 1 },
    minPlayers: 7,
    maxPlayers: 7
  },
  {
    name: '2-2WB-2-1',
    positions: { DEF: 2, WB: 2, W: 0, CDM: 1, CM: 1, CAM: 0, ST: 1 },
    minPlayers: 7,
    maxPlayers: 7
  },
  {
    name: '2-2W-2-1',
    positions: { DEF: 2, WB: 0, W: 2, CDM: 1, CM: 1, CAM: 0, ST: 1 },
    minPlayers: 7,
    maxPlayers: 7
  },
  {
    name: '3-2-1-1',
    positions: { DEF: 3, WB: 0, W: 0, CDM: 0, CM: 2, CAM: 1, ST: 1 },
    minPlayers: 7,
    maxPlayers: 7
  },

  // 8 player formations
  {
    name: '4-3-1',
    positions: { DEF: 4, WB: 0, W: 0, CDM: 1, CM: 2, CAM: 0, ST: 1 },
    minPlayers: 8,
    maxPlayers: 8
  },
  {
    name: '3-4-1',
    positions: { DEF: 3, WB: 0, W: 0, CDM: 1, CM: 3, CAM: 0, ST: 1 },
    minPlayers: 8,
    maxPlayers: 8
  },
  {
    name: '3-2WB-2-1',
    positions: { DEF: 3, WB: 2, W: 0, CDM: 0, CM: 2, CAM: 0, ST: 1 },
    minPlayers: 8,
    maxPlayers: 8
  },
  {
    name: '3-2W-2-1',
    positions: { DEF: 3, WB: 0, W: 2, CDM: 1, CM: 1, CAM: 0, ST: 1 },
    minPlayers: 8,
    maxPlayers: 8
  },
  {
    name: '3-3-2',
    positions: { DEF: 3, WB: 0, W: 0, CDM: 1, CM: 2, CAM: 0, ST: 2 },
    minPlayers: 8,
    maxPlayers: 8
  },
  {
    name: '3-2-1-2',
    positions: { DEF: 3, WB: 0, W: 0, CDM: 0, CM: 2, CAM: 1, ST: 2 },
    minPlayers: 8,
    maxPlayers: 8
  },

  // 9 player formations (standard for rotating keeper)
  {
    name: '4-4-1',
    positions: { DEF: 4, WB: 0, W: 0, CDM: 1, CM: 3, CAM: 0, ST: 1 },
    minPlayers: 9,
    maxPlayers: 9
  },
  {
    name: '3-2WB-3-1',
    positions: { DEF: 3, WB: 2, W: 0, CDM: 1, CM: 2, CAM: 0, ST: 1 },
    minPlayers: 9,
    maxPlayers: 9
  },
  {
    name: '5-3-1',
    positions: { DEF: 5, WB: 0, W: 0, CDM: 0, CM: 3, CAM: 0, ST: 1 },
    minPlayers: 9,
    maxPlayers: 9
  },
  {
    name: '3-5-1',
    positions: { DEF: 3, WB: 0, W: 0, CDM: 1, CM: 4, CAM: 0, ST: 1 },
    minPlayers: 9,
    maxPlayers: 9
  },
  {
    name: '3-2W-3-1',
    positions: { DEF: 3, WB: 0, W: 2, CDM: 1, CM: 2, CAM: 0, ST: 1 },
    minPlayers: 9,
    maxPlayers: 9
  },
  {
    name: '4-3-2',
    positions: { DEF: 4, WB: 0, W: 0, CDM: 1, CM: 2, CAM: 0, ST: 2 },
    minPlayers: 9,
    maxPlayers: 9
  },
  {
    name: '3-3-3',
    positions: { DEF: 3, WB: 0, W: 0, CDM: 0, CM: 3, CAM: 0, ST: 3 },
    minPlayers: 9,
    maxPlayers: 9
  },
  {
    name: '3-2-2-2',
    positions: { DEF: 3, WB: 0, W: 0, CDM: 2, CM: 2, CAM: 0, ST: 2 },
    minPlayers: 9,
    maxPlayers: 9
  },
  {
    name: '3-1-3-2',
    positions: { DEF: 3, WB: 0, W: 0, CDM: 1, CM: 3, CAM: 0, ST: 2 },
    minPlayers: 9,
    maxPlayers: 9
  },
  {
    name: '2-2WB-2-1-2',
    positions: { DEF: 2, WB: 2, W: 0, CDM: 2, CM: 1, CAM: 0, ST: 2 },
    minPlayers: 9,
    maxPlayers: 9
  },
  // 10 player formations (not used in 9v9)
  {
    name: '4-5-1',
    positions: { DEF: 4, WB: 0, W: 0, CDM: 1, CM: 4, CAM: 0, ST: 1 },
    minPlayers: 10,
    maxPlayers: 10
  },
  {
    name: '3-2WB-4-1',
    positions: { DEF: 3, WB: 2, W: 0, CDM: 1, CM: 3, CAM: 0, ST: 1 },
    minPlayers: 10,
    maxPlayers: 10
  },
  {
    name: '4-2W-3-1',
    positions: { DEF: 4, WB: 0, W: 2, CDM: 1, CM: 2, CAM: 0, ST: 1 },
    minPlayers: 10,
    maxPlayers: 10
  },
  {
    name: '4-4-2',
    positions: { DEF: 4, WB: 0, W: 0, CDM: 1, CM: 3, CAM: 0, ST: 2 },
    minPlayers: 10,
    maxPlayers: 10
  },
  {
    name: '3-2W-3-2',
    positions: { DEF: 3, WB: 0, W: 2, CDM: 1, CM: 2, CAM: 0, ST: 2 },
    minPlayers: 10,
    maxPlayers: 10
  },

  // 11 outfield (12 total with keeper)
  {
    name: '4-5-2',
    positions: { DEF: 4, WB: 0, W: 0, CDM: 2, CM: 3, CAM: 0, ST: 2 },
    minPlayers: 11,
    maxPlayers: 11
  },
  {
    name: '4-2W-3-1-1',
    positions: { DEF: 4, WB: 0, W: 2, CDM: 1, CM: 2, CAM: 1, ST: 1 },
    minPlayers: 11,
    maxPlayers: 11
  },
  {
    name: '5-4-2',
    positions: { DEF: 5, WB: 0, W: 0, CDM: 1, CM: 3, CAM: 0, ST: 2 },
    minPlayers: 11,
    maxPlayers: 11
  }
];

/**
 * Calculate position score with penalties
 */
function calculateEnhancedPositionScore(
  player: TeamAssignment,
  position: PositionType,
  requirements: RelativeRequirements
): number {
  const weights = ENHANCED_POSITION_WEIGHTS[position];
  let score = 0;
  let fromAttributes = 0;
  let fromRatings = 0;

  if (player.derived_attributes) {
    const attrs = player.derived_attributes;
    fromAttributes = (
      attrs.pace * weights.pace +
      attrs.shooting * weights.shooting +
      attrs.passing * weights.passing +
      attrs.dribbling * weights.dribbling +
      attrs.defending * weights.defending +
      attrs.physical * weights.physical
    ) * 10;

    // Apply penalty for not meeting requirements (more gradual)
    const reqCheck = meetsRelativeRequirements(player, position, requirements);
    if (!reqCheck.meets) {
      // More gradual penalty: instead of harsh multiplication, use gentler reduction
      fromAttributes *= Math.max(0.5, 1 - (reqCheck.penalty * 0.3));
    }
  }

  const attack = player.attack_rating ?? 5;
  const defense = player.defense_rating ?? 5;
  const gameIq = player.game_iq_rating ?? 5;

  fromRatings = (
    attack * weights.attack +
    defense * weights.defense +
    gameIq * weights.gameIq
  );

  if (player.derived_attributes) {
    score = fromAttributes * 0.7 + fromRatings * 0.3;
  } else {
    score = fromRatings;
  }

  return score;
}

/**
 * Determine if player is attacking, defensive, or balanced based on attributes
 */
function getPlayerType(
  player: TeamAssignment,
  requirements: RelativeRequirements
): 'attacking' | 'defensive' | 'balanced' {
  const attrs = player.derived_attributes;

  // Without attributes, use traditional ratings
  if (!attrs) {
    const attack = player.attack_rating || 0;
    const defense = player.defense_rating || 0;

    if (attack > defense + 1) return 'attacking';
    if (defense > attack + 1) return 'defensive';
    return 'balanced';
  }

  // Calculate attacking and defensive scores
  const attackingScore = (attrs.shooting || 0) + (attrs.pace || 0) + (attrs.dribbling || 0);
  const defensiveScore = (attrs.defending || 0) + (attrs.physical || 0);

  // Use relative thresholds
  if (attackingScore > defensiveScore * 1.3) return 'attacking';
  if (defensiveScore > attackingScore * 1.3) return 'defensive';
  return 'balanced';
}

/**
 * Position importance weights for optimization priority
 */
const POSITION_IMPORTANCE: Record<PositionType, number> = {
  ST: 1.0,   // Most critical - primary scorer
  CAM: 0.9,  // Very important - playmaker
  CDM: 0.8,  // Important - defensive anchor
  DEF: 0.7,  // Important - defensive stability
  WB: 0.65,  // Important - defensive width
  W: 0.6,    // Moderate - attacking width
  CM: 0.5    // Most flexible position
};

/**
 * Check if two positions are adjacent and swappable
 */
function arePositionsAdjacent(pos1: PositionType, pos2: PositionType): boolean {
  const adjacentPairs: [PositionType, PositionType][] = [
    ['DEF', 'CDM'],  // Defensive line continuity
    ['DEF', 'WB'],   // Defender to wingback
    ['WB', 'CDM'],   // Wingback to defensive mid
    ['WB', 'W'],     // Wingback to winger (same flank, different role)
    ['CDM', 'CM'],
    ['CM', 'CAM'],
    ['CAM', 'ST'],   // Attacking partnership
    ['W', 'CM'],
    ['W', 'CAM'],
    ['W', 'ST']      // Winger can play as forward
  ];

  return adjacentPairs.some(([p1, p2]) =>
    (pos1 === p1 && pos2 === p2) || (pos1 === p2 && pos2 === p1)
  );
}

/**
 * Check if two players are from the same tier
 */
function areSameTier(player1: TeamAssignment, player2: TeamAssignment): boolean {
  return player1.tier !== undefined &&
         player2.tier !== undefined &&
         player1.tier === player2.tier;
}

/**
 * Try to optimize poor assignments through swapping
 */
function optimizeAssignments(
  positions: FormationSuggestion['positions'],
  team: TeamAssignment[],
  requirements: RelativeRequirements,
  debugLog: ConsolidatedFormationDebugLog,
  teamColor: 'blue' | 'orange'
): boolean {
  let improved = false;
  const swaps: Array<{ from: string; to: string; reason: string; improvement: number }> = [];

  // Find problematic assignments based on relative requirements
  const problems: Array<{
    player: TeamAssignment;
    position: PositionType;
    score: number;
    issues: string[];
    priority: number;
  }> = [];

  // Check all positions for poor assignments
  (Object.keys(positions) as PositionType[]).forEach(position => {
    positions[position].forEach(assignment => {
      const check = meetsRelativeRequirements(assignment.player, position, requirements);
      const weights = ENHANCED_POSITION_WEIGHTS[position];

      // Position priority (higher = more critical)
      const positionPriority: Record<PositionType, number> = {
        ST: 5, CAM: 4, CDM: 3, CM: 2, W: 2, WB: 2, DEF: 1
      };

      // Check for critical attribute mismatches
      const criticalIssues: string[] = [];
      const attrs = assignment.player.derived_attributes;

      if (weights.shooting > 0.3 && (attrs?.shooting || 0) < requirements.shooting.percentiles.p25) {
        criticalIssues.push(`Low shooting (${(attrs?.shooting || 0).toFixed(2)} < ${requirements.shooting.percentiles.p25.toFixed(2)})`);
      }
      if (weights.passing > 0.3 && (attrs?.passing || 0) < requirements.passing.percentiles.p25) {
        criticalIssues.push(`Low passing (${(attrs?.passing || 0).toFixed(2)} < ${requirements.passing.percentiles.p25.toFixed(2)})`);
      }
      if (weights.defending > 0.3 && (attrs?.defending || 0) < requirements.defending.percentiles.p25) {
        criticalIssues.push(`Low defending (${(attrs?.defending || 0).toFixed(2)} < ${requirements.defending.percentiles.p25.toFixed(2)})`);
      }
      if (weights.pace > 0.3 && (attrs?.pace || 0) < requirements.pace.percentiles.p25) {
        criticalIssues.push(`Low pace (${(attrs?.pace || 0).toFixed(2)} < ${requirements.pace.percentiles.p25.toFixed(2)})`);
      }

      // Recalculate score to ensure it's accurate
      const actualScore = calculateEnhancedPositionScore(assignment.player, position, requirements);

      // Flag problematic assignments
      if (!check.meets || actualScore < 4.0 || criticalIssues.length > 0) {
        problems.push({
          player: assignment.player,
          position,
          score: actualScore,
          issues: [...check.reasons, ...criticalIssues],
          priority: positionPriority[position] || 0
        });
      }
    });
  });

  // Add cross-position mismatches (players in wrong area of the field)
  team.forEach(player => {
    // Find where this player is assigned
    let currentPosition: PositionType | null = null;
    (Object.keys(positions) as PositionType[]).forEach(pos => {
      if (positions[pos].some(a => a.player.player_id === player.player_id)) {
        currentPosition = pos;
      }
    });

    if (!currentPosition) return;

    const attack = player.attack_rating ?? 5;
    const defense = player.defense_rating ?? 5;
    const attrs = player.derived_attributes;

    // Check for clear mismatches
    const isDefensivePlayer = defense > attack + 1.5 || (attrs && attrs.defending > 0.7);
    const isAttackingPlayer = attack > defense + 1.5 || (attrs && attrs.shooting > 0.7);

    const defensivePositions: PositionType[] = ['DEF', 'CDM'];
    const attackingPositions: PositionType[] = ['ST', 'CAM', 'W'];

    // Defensive player in attacking position
    if (isDefensivePlayer && attackingPositions.includes(currentPosition)) {
      problems.push({
        player,
        position: currentPosition,
        score: calculateEnhancedPositionScore(player, currentPosition, requirements),
        issues: [`Defensive player (DEF: ${defense.toFixed(1)}) in attacking position`],
        priority: 10 // High priority
      });
    }

    // Attacking player in defensive position
    if (isAttackingPlayer && defensivePositions.includes(currentPosition)) {
      problems.push({
        player,
        position: currentPosition,
        score: calculateEnhancedPositionScore(player, currentPosition, requirements),
        issues: [`Attacking player (ATK: ${attack.toFixed(1)}) in defensive position`],
        priority: 10 // High priority
      });
    }
  });

  // Sort problems by priority and severity
  problems.sort((a, b) => {
    // First by position priority
    if (a.priority !== b.priority) return b.priority - a.priority;
    // Then by score (lower = worse)
    return a.score - b.score;
  });

  // Track swapped players to avoid double swapping
  const swappedPlayers = new Set<string>();

  // Try to swap with better suited players
  for (const problem of problems) {
    if (swappedPlayers.has(problem.player.player_id)) continue;

    let bestSwap: {
      player: TeamAssignment;
      fromPosition: PositionType;
      improvement: number;
      details: string;
    } | null = null;
    let bestImprovement = 0;

    // Check all other positions for better swaps (including adjacent positions)
    (Object.keys(positions) as PositionType[]).forEach(sourcePosition => {
      if (sourcePosition === problem.position) return; // Skip same position

      // For adjacent positions, be more lenient with swaps
      const isAdjacent = arePositionsAdjacent(problem.position, sourcePosition);

      positions[sourcePosition].forEach(candidate => {
        if (swappedPlayers.has(candidate.player.player_id)) return;

        // Calculate improvement if we swap
        const problemPlayerNewScore = calculateEnhancedPositionScore(problem.player, sourcePosition, requirements);
        const candidateNewScore = calculateEnhancedPositionScore(candidate.player, problem.position, requirements);

        // Calculate current scores accurately
        const problemCurrentScore = problem.score;
        const candidateCurrentScore = calculateEnhancedPositionScore(candidate.player, sourcePosition, requirements);

        const currentTotal = problemCurrentScore + candidateCurrentScore;
        const swappedTotal = problemPlayerNewScore + candidateNewScore;
        const improvement = swappedTotal - currentTotal;

        // Check if candidate actually meets requirements better
        const candidateCheck = meetsRelativeRequirements(candidate.player, problem.position, requirements);
        const problemCheck = meetsRelativeRequirements(problem.player, sourcePosition, requirements);

        // Get player types for hierarchy check
        const problemPlayerType = getPlayerType(problem.player, requirements);
        const candidatePlayerType = getPlayerType(candidate.player, requirements);

        // Position hierarchy (attacking to defensive)
        const positionHierarchy: Record<PositionType, number> = {
          ST: 6, CAM: 5, W: 4.5, CM: 4, CDM: 3, WB: 2, DEF: 1
        };

        // Don't move attacking players to significantly more defensive positions
        const problemCurrentLevel = positionHierarchy[problem.position];
        const problemNewLevel = positionHierarchy[sourcePosition];
        const candidateCurrentLevel = positionHierarchy[sourcePosition];
        const candidateNewLevel = positionHierarchy[problem.position];

        // Check for critical mismatch BEFORE hierarchy rules
        const isCriticalMismatch = problemCurrentScore < 2.0;

        // Block swaps that move players inappropriately down the hierarchy
        // EXCEPT for critical mismatches
        const maxLevelDrop = problemPlayerType === 'attacking' ? 1 : 2;
        const problemMovingDown = problemNewLevel < problemCurrentLevel - maxLevelDrop;

        const maxCandidateDrop = candidatePlayerType === 'attacking' ? 1 : 2;
        const candidateMovingDown = candidateNewLevel < candidateCurrentLevel - maxCandidateDrop;

        // Skip hierarchy check if fixing critical mismatch
        if (!isCriticalMismatch && (problemMovingDown || candidateMovingDown)) {
          return; // Block this swap UNLESS it's fixing a critical mismatch
        }

        // Additional validation for critical positions
        const candidateAttrs = candidate.player.derived_attributes;
        const problemAttrs = problem.player.derived_attributes;
        const targetWeights = ENHANCED_POSITION_WEIGHTS[problem.position];
        const sourceWeights = ENHANCED_POSITION_WEIGHTS[sourcePosition];

        // Check mutual benefit - both players should be better in their new positions
        if (candidateAttrs && problemAttrs) {
          // Calculate how well each player fits their target position
          const candidateTargetFit =
            (targetWeights.passing > 0.3 ? candidateAttrs.passing : 0) +
            (targetWeights.shooting > 0.3 ? candidateAttrs.shooting : 0) +
            (targetWeights.defending > 0.3 ? candidateAttrs.defending : 0) +
            (targetWeights.pace > 0.3 ? candidateAttrs.pace : 0);

          const problemCurrentFit =
            (targetWeights.passing > 0.3 ? problemAttrs.passing : 0) +
            (targetWeights.shooting > 0.3 ? problemAttrs.shooting : 0) +
            (targetWeights.defending > 0.3 ? problemAttrs.defending : 0) +
            (targetWeights.pace > 0.3 ? problemAttrs.pace : 0);

          // Calculate how well each player fits the source position
          const problemSourceFit =
            (sourceWeights.passing > 0.3 ? problemAttrs.passing : 0) +
            (sourceWeights.shooting > 0.3 ? problemAttrs.shooting : 0) +
            (sourceWeights.defending > 0.3 ? problemAttrs.defending : 0) +
            (sourceWeights.pace > 0.3 ? problemAttrs.pace : 0);

          const candidateCurrentFit =
            (sourceWeights.passing > 0.3 ? candidateAttrs.passing : 0) +
            (sourceWeights.shooting > 0.3 ? candidateAttrs.shooting : 0) +
            (sourceWeights.defending > 0.3 ? candidateAttrs.defending : 0) +
            (sourceWeights.pace > 0.3 ? candidateAttrs.pace : 0);

          // Only proceed if swap improves overall suitability or addresses critical gaps
          const currentTotalFit = problemCurrentFit + candidateCurrentFit;
          const swappedTotalFit = candidateTargetFit + problemSourceFit;

          // More lenient for adjacent positions
          const improvementThreshold = isAdjacent ? 1.05 : 1.1;
          const criticalThreshold = isAdjacent ? 0.4 : 0.3;

          // Allow swap if either:
          // 1. Overall suitability improves (threshold depends on adjacency)
          // 2. It fixes a critical mismatch (problem player has very poor fit)
          if (swappedTotalFit <= currentTotalFit * improvementThreshold && problemCurrentFit > criticalThreshold) {
            return; // Skip this swap
          }
        }

        // Calculate improvements
        const problemPlayerImprovement = problemPlayerNewScore - problemCurrentScore;
        const candidateImprovement = candidateNewScore - candidateCurrentScore;
        let totalImprovement = problemPlayerImprovement + candidateImprovement;

        // Bonus for keeping same-tier players together
        if (areSameTier(problem.player, candidate.player) && !isAdjacent) {
          totalImprovement += 0.5; // Small bonus for maintaining tier cohesion
        }

        // Critical mismatch: Player terribly misplaced (already checked above)
        const isCriticalFix = problemCurrentScore < 2.0 && problemPlayerImprovement > 2.0;

        // Cross-position mismatch fix (e.g., defensive player moving from attack to defense)
        const isCrossPositionFix = problem.priority === 10 &&
                                  problemPlayerImprovement > 1.0 &&
                                  candidateNewScore > problemCurrentScore;

        // Both benefit
        const bothBenefit = problemPlayerImprovement > 0.5 && candidateImprovement > -0.5;

        // Net positive with acceptable trade-off
        const acceptableTradeoff = totalImprovement > 2.0 && candidateNewScore > 3.0;

        const swapAllowed = isCriticalFix || isCrossPositionFix || bothBenefit || acceptableTradeoff;

        // For critical mismatches, be very lenient
        if (isCriticalFix && totalImprovement > 0 && candidateNewScore > 3.0) {
          if (totalImprovement > bestImprovement) {
            bestImprovement = totalImprovement;
            bestSwap = {
              player: candidate.player,
              fromPosition: sourcePosition,
              improvement: totalImprovement,
              details: `CRITICAL FIX: ${problem.player.friendly_name} ${problemCurrentScore.toFixed(1)}→${problemPlayerNewScore.toFixed(1)} (+${problemPlayerImprovement.toFixed(1)}), ${candidate.player.friendly_name} ${candidateCurrentScore.toFixed(1)}→${candidateNewScore.toFixed(1)} (${candidateImprovement > 0 ? '+' : ''}${candidateImprovement.toFixed(1)})`
            };
          }
        } else {
          // Standard swap evaluation for non-critical cases
          const candidateBetterFit = candidateNewScore >= problemCurrentScore;

          if (totalImprovement > bestImprovement &&
              totalImprovement > 0.5 &&
              swapAllowed &&
              candidateBetterFit) {
            bestImprovement = totalImprovement;
            bestSwap = {
              player: candidate.player,
              fromPosition: sourcePosition,
              improvement: totalImprovement,
              details: `Both benefit: ${problem.player.friendly_name} ${problemCurrentScore.toFixed(1)}→${problemPlayerNewScore.toFixed(1)} (+${problemPlayerImprovement.toFixed(1)}), ${candidate.player.friendly_name} ${candidateCurrentScore.toFixed(1)}→${candidateNewScore.toFixed(1)} (+${candidateImprovement.toFixed(1)})`
            };
          }
        }
      });
    });

    // Perform swap if improvement is meaningful (much lower thresholds)
    const isCriticalFix = bestSwap?.details?.includes('CRITICAL FIX');
    const isCrossPositionFix = problem.priority === 10;

    let minThreshold = 0.8; // Default threshold
    if (isCriticalFix) minThreshold = 0.1;
    else if (isCrossPositionFix) minThreshold = 0.5;

    if (bestSwap && bestImprovement > minThreshold) {
      // Perform the swap
      const sourceIndex = positions[bestSwap.fromPosition].findIndex(
        a => a.player.player_id === bestSwap.player.player_id
      );
      const targetIndex = positions[problem.position].findIndex(
        a => a.player.player_id === problem.player.player_id
      );

      if (sourceIndex !== -1 && targetIndex !== -1) {
        // Calculate specialist status for swapped players
        const problemPlayerPlaystyle = detectPlaystyleForPlayer(problem.player, requirements);
        const problemPlayerIdealPositions = problemPlayerPlaystyle ? PLAYSTYLE_IDEAL_POSITIONS[problemPlayerPlaystyle] || [] : [];
        const problemPlayerIsSpecialist = problemPlayerIdealPositions.includes(bestSwap.fromPosition);

        const swapPlayerPlaystyle = detectPlaystyleForPlayer(bestSwap.player, requirements);
        const swapPlayerIdealPositions = swapPlayerPlaystyle ? PLAYSTYLE_IDEAL_POSITIONS[swapPlayerPlaystyle] || [] : [];
        const swapPlayerIsSpecialist = swapPlayerIdealPositions.includes(problem.position);

        // Swap the players
        const temp = positions[bestSwap.fromPosition][sourceIndex];
        positions[bestSwap.fromPosition][sourceIndex] = {
          player: problem.player,
          position: bestSwap.fromPosition,
          score: calculateEnhancedPositionScore(problem.player, bestSwap.fromPosition, requirements),
          isSpecialist: problemPlayerIsSpecialist,
          alternativePositions: []
        };
        positions[problem.position][targetIndex] = {
          player: bestSwap.player,
          position: problem.position,
          score: calculateEnhancedPositionScore(bestSwap.player, problem.position, requirements),
          isSpecialist: swapPlayerIsSpecialist,
          alternativePositions: []
        };

        swaps.push({
          from: `${problem.player.friendly_name} (${problem.position})`,
          to: `${bestSwap.player.friendly_name} (${bestSwap.fromPosition})`,
          reason: bestSwap.details,
          improvement: bestImprovement
        });

        // Update the debug log's playerAnalysis to reflect the swap
        const problemPlayerAnalysis = debugLog.playerAnalysis.find(
          p => p.playerId === problem.player.player_id && p.team === teamColor
        );
        const swapPlayerAnalysis = debugLog.playerAnalysis.find(
          p => p.playerId === bestSwap.player.player_id && p.team === teamColor
        );

        if (problemPlayerAnalysis) {
          problemPlayerAnalysis.assignedPosition = bestSwap.fromPosition;
          problemPlayerAnalysis.assignmentReason = `Optimized via swap (was ${problem.position}, score: ${calculateEnhancedPositionScore(problem.player, bestSwap.fromPosition, requirements).toFixed(2)})`;
        }
        if (swapPlayerAnalysis) {
          swapPlayerAnalysis.assignedPosition = problem.position;
          swapPlayerAnalysis.assignmentReason = `Optimized via swap (was ${bestSwap.fromPosition}, score: ${calculateEnhancedPositionScore(bestSwap.player, problem.position, requirements).toFixed(2)})`;
        }

        // Mark both as swapped to avoid further swaps
        swappedPlayers.add(problem.player.player_id);
        swappedPlayers.add(bestSwap.player.player_id);

        improved = true;
      }
    }
  }

  // Log swaps to debug with detailed reasons
  if (swaps.length > 0) {
    const swapDetails = swaps.map(s => {
      // Parse the swap details to show the actual positions after swap
      const fromMatch = s.from.match(/(.+) \((.+)\)/);
      const toMatch = s.to.match(/(.+) \((.+)\)/);
      if (fromMatch && toMatch) {
        const [, fromPlayer, fromPos] = fromMatch;
        const [, toPlayer, toPos] = toMatch;
        return `${fromPlayer}: ${fromPos}→${toPos}, ${toPlayer}: ${toPos}→${fromPos} (${s.reason})`;
      }
      return `${s.from} ↔ ${s.to} (${s.reason})`;
    }).join('; ');

    debugLog.optimizationNotes.push(
      `${teamColor.toUpperCase()} team optimizations (${swaps.length} swaps): ${swapDetails}`
    );

    // Also log total improvement
    const totalImprovement = swaps.reduce((sum, s) => sum + s.improvement, 0);
    debugLog.optimizationNotes.push(
      `Total score improvement: +${totalImprovement.toFixed(1)}`
    );
  } else if (problems.length > 0) {
    debugLog.optimizationNotes.push(
      `${teamColor.toUpperCase()} team: ${problems.length} suboptimal assignments found but no beneficial swaps available`
    );
  }

  return improved;
}

/**
 * Consolidated debug log
 */
export interface ConsolidatedFormationDebugLog {
  timestamp: string;
  totalPlayers: number;
  blueTeamSize: number;
  orangeTeamSize: number;
  leagueStats: {
    attributeAverages: {
      pace: number;
      shooting: number;
      passing: number;
      dribbling: number;
      defending: number;
      physical: number;
    };
    ratingAverages: {
      attack: number;
      defense: number;
      gameIq: number;
    };
  };
  playerAnalysis: Array<{
    team: 'blue' | 'orange';
    playerId: string;
    playerName: string;
    ratings: {
      attack: number;
      defense: number;
      gameIq: number;
      overall: number;
    };
    attributes: {
      pace: number;
      shooting: number;
      passing: number;
      dribbling: number;
      defending: number;
      physical: number;
    } | null;
    detectedPlaystyle: string | null;
    idealPositions: PositionType[];
    positionScores: Record<PositionType, {
      score: number;
      breakdown: {
        fromAttributes: number;
        fromRatings: number;
        bonus: string | null;
      };
    }>;
    assignedPosition: PositionType;
    assignmentReason: string;
    isNaturalPosition: boolean;
    alternativePositions: PositionType[];
  }>;
  formationSelection: {
    blue: {
      formation: string;
      reasoning: string;
      teamComposition: {
        withPlaystyles: number;
        withoutPlaystyles: number;
        attackingPlayers: number;
        defensivePlayers: number;
        balancedPlayers: number;
      };
    };
    orange: {
      formation: string;
      reasoning: string;
      teamComposition: {
        withPlaystyles: number;
        withoutPlaystyles: number;
        attackingPlayers: number;
        defensivePlayers: number;
        balancedPlayers: number;
      };
    };
  };
  positionAnalysis: {
    blue: Record<PositionType, {
      requiredCount: number;
      assignedCount: number;
      players: string[];
      averageScore: number;
      naturalFits: number;
      compromises: number;
    }>;
    orange: Record<PositionType, {
      requiredCount: number;
      assignedCount: number;
      players: string[];
      averageScore: number;
      naturalFits: number;
      compromises: number;
    }>;
  };
  qualityMetrics: {
    blue: {
      overallScore: number;
      naturalPositionRate: number;
      attributeCoverage: number;
      tierCohesion?: number; // Percentage of tier pairs maintained
      confidence: 'high' | 'medium' | 'low';
      confidenceReason: string;
    };
    orange: {
      overallScore: number;
      naturalPositionRate: number;
      attributeCoverage: number;
      tierCohesion?: number; // Percentage of tier pairs maintained
      confidence: 'high' | 'medium' | 'low';
      confidenceReason: string;
    };
  };
  optimizationNotes: string[];
}

/**
 * Assign players to positions with optimization
 */
function assignPlayersToPositions(
  team: TeamAssignment[],
  formation: FormationTemplate,
  requirements: RelativeRequirements,
  debugLog: ConsolidatedFormationDebugLog,
  teamColor: 'blue' | 'orange'
): FormationSuggestion {
  const positions: FormationSuggestion['positions'] = {
    DEF: [], WB: [], W: [], CDM: [], CM: [], CAM: [], ST: []
  };

  const positionAnalysis = debugLog.positionAnalysis[teamColor];

  // Initialize position requirements
  Object.keys(formation.positions).forEach(pos => {
    const position = pos as PositionType;
    positionAnalysis[position] = {
      requiredCount: formation.positions[position],
      assignedCount: 0,
      players: [],
      averageScore: 0,
      naturalFits: 0,
      compromises: 0
    };
  });

  // Calculate all position scores
  const playerScores: Array<{
    player: TeamAssignment;
    position: PositionType;
    score: number;
    isNatural: boolean;
  }> = [];

  team.forEach(player => {
    const playstyle = detectPlaystyleForPlayer(player, requirements);
    const playstyleIdealPositions = playstyle ? PLAYSTYLE_IDEAL_POSITIONS[playstyle] || [] : [];
    const ratingBasedPositions = getRatingBasedIdealPositions(player);

    // Combine both approaches - union of playstyle and rating-based positions
    let idealPositions = [...new Set([...playstyleIdealPositions, ...ratingBasedPositions])];

    // CAM fallback: If player only has CAM but formation lacks it, add fallback positions
    if (idealPositions.includes('CAM') && formation.positions.CAM === 0) {
      const attrs = player.derived_attributes;
      // Remove CAM from ideal positions since it's not available
      idealPositions = idealPositions.filter(p => p !== 'CAM');

      // Add fallback positions based on attributes
      if (attrs?.passing > 0.7 || player.game_iq_rating > 6.5) {
        idealPositions.push('CM');  // Good passers/smart players go to CM
      }
      if ((attrs?.shooting > 0.6 || player.attack_rating > 6.0) && !idealPositions.includes('ST')) {
        idealPositions.push('ST');  // Good shooters/attackers can play ST
      }
      if (attrs?.pace > 0.6 && attrs?.dribbling > 0.5 && !idealPositions.includes('W')) {
        idealPositions.push('W');  // Pacey dribblers can play W
      }
      // If still no positions, default to CM
      if (idealPositions.length === 0) {
        idealPositions.push('CM');
      }
    }

    // Log mismatches for debugging
    const hasConflict = ratingBasedPositions.length > 0 &&
                       playstyleIdealPositions.length > 0 &&
                       !ratingBasedPositions.some(p => playstyleIdealPositions.includes(p));

    if (hasConflict) {
      debugLog.optimizationNotes.push(
        `${player.friendly_name}: Rating-playstyle conflict - ${playstyle} suggests ${playstyleIdealPositions.join('/')} but ratings suggest ${ratingBasedPositions.join('/')}`
      );
    }

    // Update player analysis
    const playerAnalysis = debugLog.playerAnalysis.find(
      p => p.playerId === player.player_id && p.team === teamColor
    );
    if (playerAnalysis) {
      playerAnalysis.detectedPlaystyle = playstyle;
      playerAnalysis.idealPositions = idealPositions;
    }

    // Calculate scores for each position
    const positionScoreMap: Record<PositionType, any> = {} as any;

    (['DEF', 'WB', 'W', 'CDM', 'CM', 'CAM', 'ST'] as PositionType[]).forEach(position => {
      const score = calculateEnhancedPositionScore(player, position, requirements);
      const isNatural = idealPositions.includes(position);
      const finalScore = isNatural ? score * 1.2 : score;  // Reduced from 1.3x to 1.2x

      playerScores.push({
        player,
        position,
        score: finalScore,
        isNatural
      });

      positionScoreMap[position] = {
        score: finalScore,
        breakdown: {
          fromAttributes: 0,
          fromRatings: 0,
          bonus: isNatural ? 'Natural position (+30%)' : null
        }
      };
    });

    if (playerAnalysis) {
      playerAnalysis.positionScores = positionScoreMap;
    }
  });

  // Sort by score descending
  playerScores.sort((a, b) => b.score - a.score);

  const assignedPlayers = new Set<string>();
  const positionCounts: Record<PositionType, number> = {
    DEF: 0, WB: 0, W: 0, CDM: 0, CM: 0, CAM: 0, ST: 0
  };

  // Calculate player flexibility for Phase 1 prioritization
  const playerFlexibility = new Map<string, number>();
  team.forEach(player => {
    const naturalPositions = playerScores.filter(ps =>
      ps.player.player_id === player.player_id && ps.isNatural
    ).length;
    playerFlexibility.set(player.player_id, naturalPositions);
  });

  // Phase 1: Assign natural fits first, choosing best position for multi-position players
  // Group natural fits by player to handle multi-position players
  const naturalFitsByPlayer = new Map<string, Array<{player: TeamAssignment, position: PositionType, score: number, isNatural: boolean}>>();

  playerScores.filter(ps => ps.isNatural).forEach(ps => {
    const existing = naturalFitsByPlayer.get(ps.player.player_id) || [];
    existing.push(ps);
    naturalFitsByPlayer.set(ps.player.player_id, existing);
  });

  // Sort players by flexibility (less flexible first)
  const sortedPlayers = Array.from(naturalFitsByPlayer.entries()).sort((a, b) => {
    const flexA = playerFlexibility.get(a[0]) || 99;
    const flexB = playerFlexibility.get(b[0]) || 99;
    return flexA - flexB;
  });

  // Assign each player to their best available natural position
  sortedPlayers.forEach(([playerId, playerPositions]) => {
    if (assignedPlayers.has(playerId)) return;

    // For players with multiple natural positions, choose the best one based on:
    // 1. Formation needs (positions with fewer candidates)
    // 2. Player attributes matching position requirements
    // 3. Position score
    let bestAssignment: typeof playerPositions[0] | null = null;
    let bestPriority = -1;

    for (const ps of playerPositions) {
      const { player, position, score } = ps;

      // Skip if position is full
      if (positionCounts[position] >= formation.positions[position]) continue;
      // Hard pace requirements for certain positions
      const attrs = player.derived_attributes;
      if (attrs) {
        // W (winger) requires minimum pace - skip if too slow
        if (position === 'W' && attrs.pace < 0.5) continue;
        // WB (wingback) also requires some pace for overlapping runs
        if (position === 'WB' && attrs.pace < 0.4) continue;
      }

      // Calculate priority for this position assignment
      let priority = score;

      // Bonus for positions with fewer natural candidates
      const naturalCandidatesForPosition = Array.from(naturalFitsByPlayer.values())
        .flat()
        .filter(p => p.position === position && !assignedPlayers.has(p.player.player_id))
        .length;
      priority += (10 - naturalCandidatesForPosition) * 0.5;

      // Special handling for wide positions based on attributes
      if (attrs) {
        // Strong preference for WB if player has high pace + defending
        if (position === 'WB' && attrs.pace > 0.6 && attrs.defending > 0.3) {
          priority += 2.0;  // Strong bonus for natural wingbacks
        }
        // Strong preference for W if player has high pace + attacking attributes
        if (position === 'W' && attrs.pace > 0.6 && (attrs.shooting > 0.4 || attrs.dribbling > 0.5)) {
          priority += 2.0;  // Strong bonus for natural wingers
        }
        // Strong preference for ST if player has high pace (crucial for strikers)
        if (position === 'ST') {
          priority += attrs.pace * 5.0;  // Pace is critical for strikers (increased weight)
          priority += attrs.shooting * 1.5;  // Shooting also important
        }
        // Avoid DEF for pacey players who could be WB
        if (position === 'DEF' && attrs.pace > 0.7 && formation.positions.WB > 0) {
          priority -= 1.0;  // Penalty for wasting pace at DEF
        }
      }
      // Game IQ bonuses and penalties for tactical intelligence utilization
      const gameIq = player.game_iq_rating ?? 5;
      const leagueAverageIq = 6.21; // From debug log league averages
      const iqAdvantage = gameIq - leagueAverageIq;

      // High Game IQ players (8.0+) get strong bonuses for central positions
      if (gameIq >= 8.0) {
        if (position === 'CDM') priority += iqAdvantage * 1.5; // Defensive midfield orchestrator
        if (position === 'CM') priority += iqAdvantage * 1.8; // Central playmaker
        if (position === 'CAM') priority += iqAdvantage * 1.5; // Attacking midfielder

        // Penalty for high-IQ players in wide positions (waste of tactical intelligence)
        if (position === 'WB' || position === 'W') {
          priority -= iqAdvantage * 1.2; // Significant penalty for wasting intelligence
        }
      }

      // Medium Game IQ players (6.5-8.0) get moderate central bonuses
      if (gameIq >= 6.5 && gameIq < 8.0) {
        if (position === 'CDM' || position === 'CM' || position === 'CAM') {
          priority += iqAdvantage * 0.8; // Moderate bonus for central positions
        }
      }

      if (priority > bestPriority) {
        bestPriority = priority;
        bestAssignment = ps;
      }
    }

    // Assign player to their best natural position
    if (bestAssignment) {
      const { player, position, score } = bestAssignment;

      positions[position].push({
        player,
        position,
        score,
        isSpecialist: true,
        alternativePositions: []
      });

      assignedPlayers.add(player.player_id);
      positionCounts[position]++;
      positionAnalysis[position].players.push(player.friendly_name);
      positionAnalysis[position].naturalFits++;

      const playerAnalysis = debugLog.playerAnalysis.find(
        p => p.playerId === player.player_id && p.team === teamColor
      );
      if (playerAnalysis) {
        playerAnalysis.assignedPosition = position;
        playerAnalysis.assignmentReason = `Natural position fit (Phase 1) - best of ${playerPositions.length} natural positions`;
        playerAnalysis.isNaturalPosition = true;
      }
    }
  });  // Phase 2: Fill remaining by best score with suitability constraints
  playerScores.forEach(({ player, position, score, isNatural }) => {
    if (assignedPlayers.has(player.player_id)) return;
    if (positionCounts[position] >= formation.positions[position]) return;

    // Add position suitability constraints based on ratings
    const attack = player.attack_rating ?? 5;
    const defense = player.defense_rating ?? 5;
    const attrs = player.derived_attributes;

    // Prevent terrible mismatches in Phase 2 - stronger constraints
    let skipAssignment = false;

    // DEF position constraints: need good defense OR defensive attributes (relaxed)
    if (position === 'DEF') {
      const hasDefensiveCapability = defense > 6.0 || // Good defense rating alone is sufficient
                                     (defense > 5.0 && (attrs?.defending > 0.3 || attrs?.physical > 0.5));
      const clearlyAttacking = attack > defense + 1.5 && attrs?.shooting > 0.6;
      if (!hasDefensiveCapability || clearlyAttacking) {
        skipAssignment = true;
      }
    }

    // WB position constraints: defensive player with pace
    if (position === 'WB') {
      const hasDefensiveCapability = defense > 4.5 && (attrs?.defending > 0.3 || attrs?.physical > 0.5);
      const hasPace = attrs?.pace > 0.5;
      const clearlyAttacking = attack > defense + 1.0 && attrs?.shooting > 0.6;
      if (!hasDefensiveCapability || !hasPace || clearlyAttacking) {
        skipAssignment = true;
      }
    }

    // W position constraints: attacking player with pace
    if (position === 'W') {
      const hasAttackingCapability = attack > 5.0 && (attrs?.shooting > 0.4 || attrs?.dribbling > 0.5);
      const hasPace = attrs?.pace > 0.5;
      const clearlyDefensive = defense > attack + 1.0;
      if (!hasAttackingCapability || !hasPace || clearlyDefensive) {
        skipAssignment = true;
      }
    }

    // ST position constraints: need good attack AND attacking attributes
    if (position === 'ST') {
      const hasAttackingCapability = attack > 5.0 && (attrs?.shooting > 0.5 || attrs?.pace > 0.7);
      const clearlyDefensive = defense > attack + 1.0;
      if (!hasAttackingCapability || clearlyDefensive) {
        skipAssignment = true;
      }
    }

    // CDM position constraints: need defensive capability (relaxed)
    if (position === 'CDM') {
      const hasDefensiveCapability = defense > 5.5 || // Good defense rating alone is sufficient
                                     (defense > 4.5 && attrs?.defending > 0.25);
      const clearlyAttacking = attrs?.shooting > 0.7 && attack > defense + 1.0;
      if (!hasDefensiveCapability || clearlyAttacking) {
        skipAssignment = true;
      }
    }
    // Game IQ constraints: prevent high IQ players from being assigned to wide positions
    const gameIq = player.game_iq_rating ?? 5;
    if (gameIq >= 8.0) {
      // High IQ players (8.0+) should not be assigned to wide positions in Phase 2
      if (position === 'WB' || position === 'W') {
        skipAssignment = true; // Block wide position assignment for tactical masterminds
      }
    }
    // Skip if position is clearly unsuitable
    if (skipAssignment) return;

    positions[position].push({
      player,
      position,
      score,
      isSpecialist: false,
      alternativePositions: []
    });

    assignedPlayers.add(player.player_id);
    positionCounts[position]++;
    positionAnalysis[position].players.push(player.friendly_name);

    const playerAnalysis = debugLog.playerAnalysis.find(
      p => p.playerId === player.player_id && p.team === teamColor
    );
    if (playerAnalysis) {
      playerAnalysis.assignedPosition = position;
      playerAnalysis.assignmentReason = `Best available fit (Phase 2, score: ${score.toFixed(2)})`;
      playerAnalysis.isNaturalPosition = false;
    }
  });

  // Phase 3: Force assign remaining players
  team.forEach(player => {
    if (assignedPlayers.has(player.player_id)) return;

    let bestPosition: PositionType = 'CM';
    let bestScore = 0; // Start at 0, not negative

    // First try with constraints
    let foundPosition = false;
    (['CM', 'WB', 'W', 'DEF', 'CDM', 'CAM', 'ST'] as PositionType[]).forEach(position => {
      if (positionCounts[position] < formation.positions[position]) {
        // Hard constraints: prevent critical mismatches
        const attrs = player.derived_attributes;

        // Skip positions with critical attribute deficiencies (relative to player pool)
        if (attrs && requirements) {
          const weights = ENHANCED_POSITION_WEIGHTS[position];

          // For critical attributes (weight > 0.3), require at least 10th percentile
          if (weights.passing > 0.3 && attrs.passing < requirements.passing.percentiles.p10) {
            // CM/CAM need decent passing
            if (position === 'CM' || position === 'CAM') return;
          }
          if (weights.defending > 0.3 && attrs.defending < requirements.defending.percentiles.p10) {
            // CDM needs decent defending
            if (position === 'CDM') return;
          }
          if (weights.shooting > 0.3 && attrs.shooting < requirements.shooting.percentiles.p10) {
            // ST needs decent shooting
            if (position === 'ST') return;
          }
          if (weights.pace > 0.3 && attrs.pace < requirements.pace.percentiles.p10) {
            // W needs decent pace
            if (position === 'W') return;
          }
        }

        const score = calculateEnhancedPositionScore(player, position, requirements);
        if (score > bestScore) {
          bestScore = score;
          bestPosition = position;
          foundPosition = true;
        }
      }
    });

    // If no position found with constraints, force assign to least bad position
    if (!foundPosition) {
      (['DEF', 'WB', 'W', 'CM', 'CDM', 'CAM', 'ST'] as PositionType[]).forEach(position => {
        if (positionCounts[position] < formation.positions[position]) {
          const score = calculateEnhancedPositionScore(player, position, requirements);
          if (score > bestScore || bestScore === 0) {
            bestScore = score;
            bestPosition = position;
            foundPosition = true;  // Mark that we found a position
          }
        }
      });
    }

    // Only assign if we actually found an available position
    if (foundPosition && positionCounts[bestPosition] < formation.positions[bestPosition]) {
      positions[bestPosition].push({
        player,
        position: bestPosition,
        score: bestScore,
        isSpecialist: false,
        alternativePositions: []
      });

      assignedPlayers.add(player.player_id);
      positionCounts[bestPosition]++;
      positionAnalysis[bestPosition].players.push(player.friendly_name);
      positionAnalysis[bestPosition].compromises++;

      const playerAnalysis = debugLog.playerAnalysis.find(
        p => p.playerId === player.player_id && p.team === teamColor
      );
      if (playerAnalysis) {
        playerAnalysis.assignedPosition = bestPosition;
        playerAnalysis.assignmentReason = 'Forced assignment (Phase 3)';
        playerAnalysis.isNaturalPosition = false;
      }
    } else {
      // Log if we couldn't assign a player (should not happen in balanced teams)
      debugLog.optimizationNotes.push(
        `${player.friendly_name}: Could not assign to any position (all positions full)`
      );
    }  });

  // Optimize poor assignments
  optimizeAssignments(positions, team, requirements, debugLog, teamColor);

  // Calculate metrics
  Object.keys(positions).forEach(pos => {
    const position = pos as PositionType;
    const players = positions[position];
    if (players.length > 0) {
      const avgScore = players.reduce((sum, p) => sum + p.score, 0) / players.length;
      positionAnalysis[position].averageScore = avgScore;
      positionAnalysis[position].assignedCount = players.length;
    }
  });

  // Calculate balance
  const calculateAreaScore = (players: PlayerPositionAssignment[]) => {
    if (players.length === 0) return 0;
    return players.reduce((sum, p) => sum + p.score, 0) / players.length;
  };

  const defense = calculateAreaScore([...positions.DEF, ...positions.WB]);
  const midfield = calculateAreaScore([...positions.CDM, ...positions.CM, ...positions.CAM]);
  const attack = calculateAreaScore([...positions.ST, ...positions.W]);
  const overall = (defense + midfield + attack) / 3;

  // Determine confidence
  const naturalRate = team.filter(p => {
    const analysis = debugLog.playerAnalysis.find(
      a => a.playerId === p.player_id && a.team === teamColor
    );
    return analysis?.isNaturalPosition;
  }).length / team.length;

  let confidence: 'high' | 'medium' | 'low';
  let confidenceReason: string;

  if (naturalRate > 0.7 && overall > 6) {
    confidence = 'high';
    confidenceReason = `${(naturalRate * 100).toFixed(0)}% natural positions, strong overall score`;
  } else if (naturalRate > 0.5 || overall > 5) {
    confidence = 'medium';
    confidenceReason = `${(naturalRate * 100).toFixed(0)}% natural positions, decent overall score`;
  } else {
    confidence = 'low';
    confidenceReason = `Only ${(naturalRate * 100).toFixed(0)}% natural positions, compromises made`;
  }

  // Calculate tier cohesion if tier data is available
  let tierCohesion: number | undefined;
  if (team.some(p => p.tier !== undefined)) {
    // Count how many players are in positions with teammates from the same tier
    let sameTierPairs = 0;
    let totalPairs = 0;

    Object.keys(positions).forEach(pos => {
      const playersInPosition = positions[pos as PositionType];
      if (playersInPosition.length > 1) {
        for (let i = 0; i < playersInPosition.length - 1; i++) {
          for (let j = i + 1; j < playersInPosition.length; j++) {
            totalPairs++;
            if (areSameTier(playersInPosition[i].player, playersInPosition[j].player)) {
              sameTierPairs++;
            }
          }
        }
      }
    });

    tierCohesion = totalPairs > 0 ? sameTierPairs / totalPairs : 1;
  }

  debugLog.qualityMetrics[teamColor] = {
    overallScore: overall,
    naturalPositionRate: naturalRate,
    attributeCoverage: team.filter(p => p.derived_attributes).length / team.length,
    tierCohesion,
    confidence,
    confidenceReason
  };

  return {
    formation: formation.name,
    positions,
    confidence,
    rationale: [
      `Formation: ${formation.name}`,
      `Natural fits: ${Math.round(naturalRate * 100)}%`
    ],
    balanceScore: { defense, midfield, attack, overall }
  };
}

/**
 * Analyze team composition
 */
function analyzeTeamComposition(team: TeamAssignment[]): any {
  const composition = {
    withPlaystyles: 0,
    withoutPlaystyles: 0,
    attackingPlayers: 0,
    defensivePlayers: 0,
    balancedPlayers: 0
  };

  team.forEach(player => {
    if (player.derived_attributes) {
      composition.withPlaystyles++;
      const attrs = player.derived_attributes;
      const attackScore = attrs.pace + attrs.shooting + attrs.dribbling;
      const defenseScore = attrs.defending + attrs.physical;

      if (attackScore > defenseScore * 1.5) {
        composition.attackingPlayers++;
      } else if (defenseScore > attackScore * 1.2) {
        composition.defensivePlayers++;
      } else {
        composition.balancedPlayers++;
      }
    } else {
      composition.withoutPlaystyles++;
      const attack = player.attack_rating ?? 5;
      const defense = player.defense_rating ?? 5;

      if (attack > defense + 2) {
        composition.attackingPlayers++;
      } else if (defense > attack + 2) {
        composition.defensivePlayers++;
      } else {
        composition.balancedPlayers++;
      }
    }
  });

  return composition;
}

/**
 * Main function to suggest formations
 */
export function suggestFormations(
  blueTeam: TeamAssignment[],
  orangeTeam: TeamAssignment[]
): FormationResult & { consolidatedDebugLog?: ConsolidatedFormationDebugLog } {
  // Create debug log
  const debugLog: ConsolidatedFormationDebugLog = {
    timestamp: new Date().toISOString(),
    totalPlayers: blueTeam.length + orangeTeam.length,
    blueTeamSize: blueTeam.length,
    orangeTeamSize: orangeTeam.length,
    leagueStats: {
      attributeAverages: {
        pace: 0, shooting: 0, passing: 0,
        dribbling: 0, defending: 0, physical: 0
      },
      ratingAverages: { attack: 0, defense: 0, gameIq: 0 }
    },
    playerAnalysis: [],
    formationSelection: {
      blue: { formation: '', reasoning: '', teamComposition: analyzeTeamComposition(blueTeam) },
      orange: { formation: '', reasoning: '', teamComposition: analyzeTeamComposition(orangeTeam) }
    },
    positionAnalysis: { blue: {} as any, orange: {} as any },
    qualityMetrics: { blue: {} as any, orange: {} as any },
    optimizationNotes: []
  };

  // Calculate league stats and requirements
  const allPlayers = [...blueTeam, ...orangeTeam];
  const requirements = calculateRelativeRequirements(allPlayers);

  // Calculate averages for debug
  let attrCount = 0;
  allPlayers.forEach(player => {
    debugLog.leagueStats.ratingAverages.attack += player.attack_rating ?? 5;
    debugLog.leagueStats.ratingAverages.defense += player.defense_rating ?? 5;
    debugLog.leagueStats.ratingAverages.gameIq += player.game_iq_rating ?? 5;

    if (player.derived_attributes) {
      attrCount++;
      debugLog.leagueStats.attributeAverages.pace += player.derived_attributes.pace;
      debugLog.leagueStats.attributeAverages.shooting += player.derived_attributes.shooting;
      debugLog.leagueStats.attributeAverages.passing += player.derived_attributes.passing;
      debugLog.leagueStats.attributeAverages.dribbling += player.derived_attributes.dribbling;
      debugLog.leagueStats.attributeAverages.defending += player.derived_attributes.defending;
      debugLog.leagueStats.attributeAverages.physical += player.derived_attributes.physical;
    }
  });

  debugLog.leagueStats.ratingAverages.attack /= allPlayers.length;
  debugLog.leagueStats.ratingAverages.defense /= allPlayers.length;
  debugLog.leagueStats.ratingAverages.gameIq /= allPlayers.length;

  if (attrCount > 0) {
    Object.keys(debugLog.leagueStats.attributeAverages).forEach(key => {
      debugLog.leagueStats.attributeAverages[key as keyof typeof debugLog.leagueStats.attributeAverages] /= attrCount;
    });
  }

  // Initialize player analysis
  [...blueTeam.map(p => ({ ...p, teamColor: 'blue' as const })),
   ...orangeTeam.map(p => ({ ...p, teamColor: 'orange' as const }))]
    .forEach(player => {
      debugLog.playerAnalysis.push({
        team: player.teamColor,
        playerId: player.player_id,
        playerName: player.friendly_name,
        ratings: {
          attack: player.attack_rating ?? 5,
          defense: player.defense_rating ?? 5,
          gameIq: player.game_iq_rating ?? 5,
          overall: ((player.attack_rating ?? 5) + (player.defense_rating ?? 5) + (player.game_iq_rating ?? 5)) / 3
        },
        attributes: player.derived_attributes || null,
        detectedPlaystyle: null,
        idealPositions: [],
        positionScores: {} as any,
        assignedPosition: 'CM' as PositionType,
        assignmentReason: '',
        isNaturalPosition: false,
        alternativePositions: []
      });
    });

  // Select best formations
  const blueFormation = selectBestFormation(blueTeam, requirements);
  const orangeFormation = selectBestFormation(orangeTeam, requirements);

  // Update debug log
  const blueComposition = analyzeTeamComposition(blueTeam);
  const orangeComposition = analyzeTeamComposition(orangeTeam);

  debugLog.formationSelection.blue = {
    formation: blueFormation.name,
    reasoning: `${blueComposition.attackingPlayers} attacking, ${blueComposition.defensivePlayers} defensive, ${blueComposition.balancedPlayers} balanced players`,
    teamComposition: blueComposition
  };

  debugLog.formationSelection.orange = {
    formation: orangeFormation.name,
    reasoning: `${orangeComposition.attackingPlayers} attacking, ${orangeComposition.defensivePlayers} defensive, ${orangeComposition.balancedPlayers} balanced players`,
    teamComposition: orangeComposition
  };

  // Initialize position analysis
  (['DEF', 'WB', 'W', 'CDM', 'CM', 'CAM', 'ST'] as PositionType[]).forEach(pos => {
    debugLog.positionAnalysis.blue[pos] = {
      requiredCount: 0, assignedCount: 0, players: [],
      averageScore: 0, naturalFits: 0, compromises: 0
    };
    debugLog.positionAnalysis.orange[pos] = {
      requiredCount: 0, assignedCount: 0, players: [],
      averageScore: 0, naturalFits: 0, compromises: 0
    };
  });

  // Assign players
  const blueResult = assignPlayersToPositions(blueTeam, blueFormation, requirements, debugLog, 'blue');
  const orangeResult = assignPlayersToPositions(orangeTeam, orangeFormation, requirements, debugLog, 'orange');

  // Add notes
  if (blueComposition.withPlaystyles < blueTeam.length * 0.5) {
    debugLog.optimizationNotes.push(
      `Blue team has limited playstyle data (${blueComposition.withPlaystyles}/${blueTeam.length} players)`
    );
  }

  if (orangeComposition.withPlaystyles < orangeTeam.length * 0.5) {
    debugLog.optimizationNotes.push(
      `Orange team has limited playstyle data (${orangeComposition.withPlaystyles}/${orangeTeam.length} players)`
    );
  }

  // Check tier cohesion and add warnings if necessary
  const checkTierCohesion = (team: TeamAssignment[], teamColor: 'blue' | 'orange') => {
    if (!team.some(p => p.tier !== undefined)) return;

    const tierCounts = new Map<number, number>();
    team.forEach(player => {
      if (player.tier !== undefined) {
        tierCounts.set(player.tier, (tierCounts.get(player.tier) || 0) + 1);
      }
    });

    // Check if any tier got split too much
    tierCounts.forEach((count, tier) => {
      if (count >= 3) {
        // Check how many are in the same position
        const positionDistribution = new Map<PositionType, number>();
        const result = teamColor === 'blue' ? blueResult : orangeResult;

        Object.keys(result.positions).forEach(pos => {
          const position = pos as PositionType;
          const playersInPos = result.positions[position].filter(
            p => p.player.tier === tier
          );
          if (playersInPos.length > 0) {
            positionDistribution.set(position, playersInPos.length);
          }
        });

        // If a tier is split across 3+ positions, warn
        if (positionDistribution.size >= 3) {
          debugLog.optimizationNotes.push(
            `⚠️ ${teamColor.toUpperCase()} team: Tier ${tier} players split across ${positionDistribution.size} positions (cohesion may be affected)`
          );
        }
      }
    });
  };

  checkTierCohesion(blueTeam, 'blue');
  checkTierCohesion(orangeTeam, 'orange');

  const formationNotes: string[] = [];
  formationNotes.push(`Teams: Blue (${blueTeam.length}) vs Orange (${orangeTeam.length})`);
  formationNotes.push(`Formations: Blue ${blueFormation.name} vs Orange ${orangeFormation.name}`);

  return {
    blueFormation: blueResult,
    orangeFormation: orangeResult,
    formationNotes,
    consolidatedDebugLog: debugLog
  };
}

/**
 * Export position display names for UI
 */
export const POSITION_DISPLAY_NAMES: Record<PositionType, string> = {
  DEF: 'Defense',
  WB: 'Wingback',
  W: 'Winger',
  CDM: 'Defensive Midfield',
  CM: 'Central Midfield',
  CAM: 'Attacking Midfield',
  ST: 'Striker/Forward'
};

/**
 * Export position colors for UI
 */
export const POSITION_COLORS: Record<PositionType, string> = {
  DEF: 'bg-red-100 text-red-800 border-red-300',
  WB: 'bg-amber-100 text-amber-800 border-amber-300',
  W: 'bg-purple-100 text-purple-800 border-purple-300',
  CDM: 'bg-orange-100 text-orange-800 border-orange-300',
  CM: 'bg-yellow-100 text-yellow-800 border-yellow-300',
  CAM: 'bg-green-100 text-green-800 border-green-300',
  ST: 'bg-blue-100 text-blue-800 border-blue-300'
};